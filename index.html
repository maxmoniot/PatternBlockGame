<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programmation motifs - par Max</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: #f0f0f0;
            min-height: 100vh;
            overflow: hidden;
        }

        .app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: white;
        }

        .header {
            background: linear-gradient(135deg, #4C97FF 0%, #3373CC 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .header.teacher-mode {
            background: linear-gradient(135deg, #9C27B0 0%, #6A1B9A 100%);
        }

        .header h1 {
            font-size: 20px;
            font-weight: bold;
            flex: 1;
        }
        
        .header-subtitle {
            font-size: 13px;
            font-weight: normal;
            opacity: 0.9;
            margin-top: 2px;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
        }

        .mode-btn {
            padding: 8px 16px;
            border: 2px solid white;
            background: rgba(255,255,255,0.2);
            color: white;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
            transition: all 0.3s;
        }

        .mode-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .mode-btn.active {
            background: white;
            color: #4C97FF;
        }

        .main-content {
            display: flex;
            height: calc(100vh - 60px);
            overflow: hidden;
        }

        /* Colonne de gauche - Grille et contr√¥les */
        .left-panel {
            width: 350px;
            background: #FFFFFF;
            border-right: 1px solid #E0E0E0;
            padding: 10px 20px 20px 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        /* Colonne du milieu - Palette de blocs */
        .middle-panel {
            width: 280px;
            background: #F9F9F9;
            border-right: 1px solid #E0E0E0;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            position: relative;
            transition: all 0.3s ease;
        }
        
        /* Ajustement des colonnes pour √©crans moyens (769px - 1150px) */
        @media (min-width: 769px) and (max-width: 1150px) {
            .left-panel {
                width: 280px !important; /* R√©duit de 350px √† 280px */
                padding: 10px 10px 20px 10px !important; /* R√©duit padding gauche/droite : 20px -> 10px */
            }
            
            .middle-panel {
                width: 220px !important; /* R√©duit de 280px √† 220px */
            }
            
            /* R√©duire les cellules de la grille pour qu'elle rentre dans 280px - 20px padding = 260px */
            .grid-cell {
                width: 24px !important;  /* 22px -> 24px pour meilleur ratio */
                height: 24px !important;
                border: 1px solid #E0E0E0 !important; /* Bordure fine uniforme */
            }
            
            /* S'assurer que la bordure de la grille reste visible */
            .grid {
                border: 2px solid #999 !important; /* Forcer bordure compl√®te */
                box-sizing: content-box !important; /* Ne pas inclure bordure dans width */
                gap: 0 !important; /* Pas de gap entre cellules */
                background: #D0D0D0 !important; /* Fond gris visible */
            }
            
            /* CRITIQUE : Forcer TOUTES les grilles √† rester CARR√âES */
            #teacher-grid,
            #student-grid,
            #target-grid {
                aspect-ratio: 1 / 1 !important;
                width: fit-content !important;
                max-width: 100% !important;
            }
            
            /* Mon programme aura plus d'espace : 769px - 280px - 220px = 269px minimum */
        }

        .middle-panel.delete-zone {
            background: rgba(255, 85, 85, 0.4);
        }

        .middle-panel.delete-zone::before {
            content: 'üóëÔ∏è';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 100px;
            opacity: 1;
            pointer-events: none;
            z-index: 1000;
            filter: drop-shadow(0 2px 8px rgba(0,0,0,0.3));
        }

        /* Colonne de droite - Zone de programmation */
        .right-panel {
            flex: 1;
            background: #FFFFFF;
            padding: 20px;
            overflow-y: auto;
        }

        .score-display {
            background: #FFD700;
            color: #333;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .level-info {
            background: #E3F2FD;
            border-left: 4px solid #2196F3;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .level-info h3 {
            color: #1976D2;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .consigne-box {
            background: #FFF9C4;
            border-left: 4px solid #FBC02D;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .consigne-box h3 {
            color: #F57F17;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .cursus-selector, .level-selector {
            margin-bottom: 15px;
        }

        .cursus-selector label, .level-selector label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 13px;
            color: #555;
        }

        .cursus-selector select, .level-selector select {
            width: 100%;
            padding: 8px;
            border: 2px solid #E0E0E0;
            border-radius: 4px;
            font-size: 13px;
            background: white;
        }

        /* Grille de dessin */
        .grid-container {
            margin: 2px 0;
            display: flex;
            justify-content: center;
        }

        .grid {
            display: grid;
            gap: 0;
            background: #D0D0D0;
            border: 2px solid #999;
            width: fit-content;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .grid-cell {
            width: 25px;
            height: 25px;
            background: white;
            border: 1px solid #E0E0E0;
        }

        /* Palette de blocs style Scratch */
        .blocks-palette {
            padding: 10px;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .blocks-category {
            margin-bottom: 3px;
        }

        .category-header {
            background: #E8E8E8;
            padding: 6px 10px;
            cursor: pointer;
            user-select: none;
            font-weight: bold;
            font-size: 12px;
            color: #333;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 3px;
        }

        .category-header:hover {
            background: #D8D8D8;
        }

        .category-header.collapsed::before {
            content: '‚ñ∂';
            font-size: 9px;
        }

        .category-header.expanded::before {
            content: '‚ñº';
            font-size: 9px;
        }

        .category-blocks {
            padding: 3px 5px;
            display: block;
        }

        .category-blocks.hidden {
            display: none;
        }

        /* Blocs style Scratch */
        .block {
            padding: 4px 8px;
            margin: 4px 0;
            border-radius: 4px;
            cursor: grab;
            color: white;
            font-weight: 500;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            position: relative;
            box-shadow: 0 2px 3px rgba(0,0,0,0.2);
            user-select: none;
            min-height: 28px;
        }

        /* Forme de puzzle Scratch */
        .block::before {
            content: '';
            position: absolute;
            top: -3px;
            left: 20px;
            width: 12px;
            height: 3px;
            background: inherit;
            border-radius: 2px 2px 0 0;
        }

        .block::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 20px;
            width: 12px;
            height: 4px;
            background: rgba(0,0,0,0.15);
            border-radius: 0 0 2px 2px;
        }

        .block:active {
            cursor: grabbing;
        }

        /* Blocs capsule pour boucles et conditions */
        .block-capsule {
            position: relative;
            margin: 8px 0;
        }

        .block-capsule .block {
            border-radius: 8px 8px 0 0;
        }

        .block-capsule .block::after {
            display: none;
        }

        .block-capsule-bottom {
            background: inherit;
            height: 8px;
            border-radius: 0 0 8px 8px;
            margin-top: -4px;
            position: relative;
            box-shadow: 0 2px 3px rgba(0,0,0,0.2);
        }

        .block-capsule-bottom::before {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 20px;
            width: 12px;
            height: 4px;
            background: rgba(0,0,0,0.15);
            border-radius: 0 0 2px 2px;
        }

        /* Couleurs des blocs */
        .block.motion { background: #4C97FF; }
        .block.looks { background: #9966FF; }
        .block.sound { background: #CF63CF; }
        .block.events { background: #FFD500; color: #333; }
        .block.control { background: #FFAB19; }
        .block.sensing { background: #5CB1D6; }
        .block.operators { background: #59C059; }
        .block.variables { background: #FF8C1A; }
        .block.custom { background: #FF6680; }

        .block input, .block select {
            padding: 3px 6px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.9);
            min-width: 40px;
            font-size: 11px;
            color: #333;
            text-align: center;
        }

        .block input[type="number"] {
            max-width: 50px;
        }

        .block input[type="text"] {
            min-width: 60px;
        }

        /* R√©duire la taille des inputs pour les op√©rateurs */
        .block.operators input[type="text"] {
            min-width: 35px;
            max-width: 40px;
        }
        
        /* Ajuster la taille pour les blocs de comparaison */
        .block.sensing input[type="text"] {
            min-width: 30px;
            max-width: 35px;
        }
        
        /* Bloc variable simple plus large */
        .block.variables .var-select {
            min-width: 70px;
        }

        .block select {
            padding: 3px 2px;
            max-width: 50px;
        }

        /* Slot pour condition dans le bloc "si" */
        .condition-slot {
            display: inline-block;
            min-width: 80px;
            padding: 2px 6px;
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
            border: 1px dashed rgba(255,255,255,0.5);
            text-align: center;
            font-size: 10px;
        }

        .condition-slot.filled {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
        }

        .condition-slot .block {
            display: inline-flex;
            margin: 0;
            font-size: 11px;
            padding: 2px 6px;
        }
        
        /* Slot pour variable dans le bloc de comparaison */
        .var-slot {
            display: inline-block;
            min-width: 50px;
            padding: 2px 6px;
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
            border: 1px dashed rgba(255,255,255,0.5);
            text-align: center;
            font-size: 10px;
        }

        .var-slot.filled {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
        }

        .var-slot .block {
            display: inline-flex;
            margin: 0;
            font-size: 11px;
            padding: 2px 4px;
        }

        .value-slot {
            display: inline-block;
        }

        .value-slot input {
            width: 60px;
            padding: 2px 4px;
            border: 1px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
            font-size: 11px;
            text-align: center;
        }

        /* Zone de programmation */
        .program-area {
            min-height: calc(100vh - 120px);
            border: 2px dashed #D0D0D0;
            border-radius: 8px;
            padding: 20px;
            background: #F8F8F8;
            display: flex;
            flex-direction: column;
        }

        .program-area h3 {
            color: #555;
            margin-bottom: 15px;
            font-size: 16px;
            flex-shrink: 0;
        }

        .program-area.drag-over {
            background: #E3F2FD;
            border-color: #4C97FF;
        }

        .program-blocks-container {
            flex: 1;
            min-height: 350px;
        }

        .program-block {
            margin: 8px 0;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .program-block .block {
            cursor: move;
            box-shadow: 0 3px 5px rgba(0,0,0,0.2);
        }

        .remove-btn {
            position: absolute;
            right: -8px;
            top: -8px;
            background: #FF5555;
            border: 2px solid white;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 10;
        }

        .remove-btn:hover {
            background: #FF0000;
            transform: scale(1.1);
        }

        /* Blocs imbriqu√©s (pour les boucles et conditions) */
        .nested-blocks {
            margin-left: 15px;
            margin-top: 4px;
            margin-bottom: 4px;
            padding: 8px;
            background: rgba(0,0,0,0.08);
            border-left: 3px solid rgba(0,0,0,0.15);
            border-radius: 4px;
            min-height: 40px;
            transition: background 0.2s;
        }

        .nested-blocks.empty::after {
            content: 'Glisse des blocs ici';
            color: #999;
            font-size: 11px;
            font-style: italic;
        }
        
        .nested-blocks.drag-over {
            background: rgba(76, 151, 255, 0.2);
            border-left-color: #4C97FF;
        }

        /* Rendre les blocs dans la zone de programmation d√©pla√ßables */
        .program-blocks-container .program-block {
            cursor: move;
        }

        .program-blocks-container .block {
            cursor: move;
        }

        .program-block.dragging {
            opacity: 0.5;
        }

        .program-block.drag-over-top {
            border-top: 3px solid #4C97FF;
            margin-top: 8px;
        }

        .program-block.drag-over-bottom {
            border-bottom: 3px solid #4C97FF;
            margin-bottom: 8px;
        }

        /* Boutons de contr√¥le */
        .controls {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            flex-wrap: nowrap;
        }

        .controls .btn {
            flex: 1;
            justify-content: center;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
        }

        .btn-success {
            background: #2196F3;
            color: white;
        }

        .btn-success:hover {
            background: #0b7dda;
        }
        
        /* Forcer les boutons de la modal auto-create en pleine largeur */
        #auto-create-modal .btn {
            display: block !important;
            width: 100% !important;
            max-width: 100% !important;
            box-sizing: border-box !important;
            text-align: center !important;
        }
        
        #generate-btn-top,
        #generate-btn-bottom,
        #quick-apply-btn {
            display: block !important;
            width: 100% !important;
            max-width: 100% !important;
            box-sizing: border-box !important;
            text-align: center !important;
        }

        .btn-danger {
            background: #FF5252;
            color: white;
        }

        .btn-danger:hover {
            background: #ff1744;
        }

        .btn-warning {
            background: #FFC107;
            color: #333;
        }

        .btn-warning:hover {
            background: #FFB300;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1100; /* Au-dessus des boutons menu (1001) */
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            position: relative;
            overflow: visible; /* IMPORTANT : permet √† la croix de d√©passer */
        }

        .modal-close {
            position: absolute;
            top: -14px;
            right: 6px; /* Au lieu de -14px, soit +20px vers la gauche */
            background: #FF5555;
            border: 3px solid white;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            font-weight: bold;
            line-height: 1;
            box-shadow: 0 3px 8px rgba(0,0,0,0.4);
            z-index: 10;
            transition: all 0.2s;
        }
        
        /* CRITIQUE : La croix ne doit PAS √™tre clipp√©e */
        #level-manager-modal .modal-wrapper-large,
        #auto-create-modal .modal-wrapper-large {
            overflow: visible !important;
        }
        
        #level-manager-modal .modal-content,
        #auto-create-modal .modal-content {
            overflow: visible !important;
        }
        
        #level-manager-modal .modal-close,
        #auto-create-modal .modal-close,
        #password-modal .modal-close {
            z-index: 1200; /* Au-dessus de la modal (1100) */
        }
        
        /* Positionner les croix des grandes modals - elles suivent automatiquement */
        .level-manager-close,
        .auto-create-close {
            right: 6px !important; /* Position normale PC */
        }
        
        /* D√©calage de 20px vers la gauche UNIQUEMENT sur mobile */
        @media (max-width: 768px) {
            #level-manager-modal .level-manager-close,
            #auto-create-modal .auto-create-close {
                right: 26px !important; /* 6px + 20px = 26px */
            }
        }

        .modal-close:hover {
            background: #FF0000;
            transform: scale(1.1);
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: #333;
            font-size: 20px;
        }
        
        /* Styles pour le header avec bouton */
        .modal-header-with-button {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .modal-header-with-button h2 {
            margin: 0;
        }
        
        .auto-create-btn {
            background: #9C27B0;
            color: white;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .auto-create-btn:hover {
            background: #7B1FA2;
        }

        .modal-content input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 2px solid #E0E0E0;
            border-radius: 6px;
            font-size: 14px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons .btn {
            flex: 1;
        }

        /* Messages de r√©sultat */
        .result-message {
            padding: 12px;
            border-radius: 6px;
            margin-top: 15px;
            font-weight: bold;
            text-align: center;
            font-size: 13px;
        }

        .result-message.success {
            background: #C8E6C9;
            color: #2E7D32;
            border: 2px solid #4CAF50;
        }

        /* Popup de f√©licitations */
        .success-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            z-index: 10000;
            text-align: center;
            min-width: 400px;
            animation: popupAppear 0.3s ease-out;
        }

        @keyframes popupAppear {
            from {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .success-popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 9999;
        }

        .success-popup.show,
        .success-popup-overlay.show {
            display: block;
        }

        .success-popup h2 {
            color: #4CAF50;
            font-size: 28px;
            margin-bottom: 15px;
        }

        .success-popup .emoji {
            font-size: 60px;
            margin-bottom: 10px;
        }

        .success-popup p {
            font-size: 16px;
            color: #555;
            margin: 10px 0;
            line-height: 1.6;
        }

        .success-popup .bonus-message {
            background: #FFF9C4;
            border: 2px solid #FBC02D;
            border-radius: 8px;
            padding: 12px;
            margin: 15px 0;
            font-size: 14px;
            color: #F57F17;
            font-weight: bold;
        }

        .success-popup-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .success-popup-buttons button {
            flex: 1;
            padding: 15px 20px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .success-popup-buttons .btn-icon {
            font-size: 24px;
            display: block;
            line-height: 1;
        }
        
        .success-popup-buttons .btn-text {
            display: block;
            margin-top: 8px;
        }

        .success-popup-buttons .btn-restart {
            background: #FF9800;
            color: white;
        }

        .success-popup-buttons .btn-restart:hover {
            background: #F57C00;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .success-popup-buttons .btn-next {
            background: #4CAF50;
            color: white;
        }

        .success-popup-buttons .btn-next:hover {
            background: #388E3C;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .result-message.error {
            background: #FFCDD2;
            color: #C62828;
            border: 2px solid #F44336;
        }

        /* Affichage des variables */
        .variable-display {
            background: #FFF3E0;
            border-left: 4px solid #FF9800;
            border-radius: 4px;
            padding: 12px;
            margin: 15px 0;
        }

        .variable-display h4 {
            color: #E65100;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .variables-list {
            font-size: 12px;
            color: #555;
        }

        .variables-list div {
            padding: 4px 0;
        }

        /* Module Pinceau */
        .paint-module {
            background: #F5F5F5;
            border: 2px solid #E0E0E0;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .color-picker {
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: center;
        }

        .color-option {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .color-option:hover {
            transform: scale(1.15);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .color-option.selected {
            border-color: #333;
            transform: scale(1.2);
            box-shadow: 0 0 0 2px white, 0 0 0 4px #333;
        }

        .color-option.eraser {
            border: 2px solid #999;
        }

        /* Motifs g√©om√©triques pour difficult√© 3 */
        .pattern-picker {
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: center;
        }

        .pattern-option {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            background: white;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px;
        }

        .pattern-option:hover {
            transform: scale(1.15);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .pattern-option.selected {
            border-color: #4C97FF;
            background: #E3F2FD;
            transform: scale(1.2);
            box-shadow: 0 0 0 2px white, 0 0 0 4px #4C97FF;
        }

        .pattern-option svg {
            width: 100%;
            height: 100%;
        }

        .grid-cell.paintable {
            cursor: crosshair;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .left-panel, .middle-panel {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #E0E0E0;
            }
        }
        /* Styles pour la sauvegarde en ligne */
        .online-save-buttons {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            padding: 15px;
            background: #E8F5E9;
            border-radius: 8px;
            border: 2px solid #4CAF50;
        }

        .online-save-buttons button {
            flex: 1;
            padding: 12px;
            font-size: 13px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-save-online {
            background: #4CAF50;
            color: white;
        }

        .btn-save-online:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .btn-load-online {
            background: #2196F3;
            color: white;
        }

        .btn-load-online:hover {
            background: #0b7dda;
            transform: translateY(-2px);
        }

        /* Modal pour sauvegarde/chargement en ligne */
        .online-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            animation: fadeIn 0.3s;
        }

        .online-modal.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .online-modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
            animation: slideDown 0.3s;
            position: relative;
        }

        .online-modal-content h2 {
            margin: 0 0 20px 0;
            color: #333;
        }

        .online-modal-content input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 2px solid #E0E0E0;
            border-radius: 6px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .online-modal-content input:focus {
            outline: none;
            border-color: #4C97FF;
        }

        .captcha-box {
            background: #F5F5F5;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .captcha-question {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }

        .captcha-input {
            width: 80px !important;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
        }

        .online-modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .online-modal-buttons button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-confirm {
            background: #4CAF50;
            color: white;
        }

        .btn-confirm:hover {
            background: #45a049;
        }

        .btn-cancel {
            background: #f44336;
            color: white;
        }

        .btn-cancel:hover {
            background: #da190b;
        }

        .success-url-box {
            background: #E8F5E9;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border: 2px solid #4CAF50;
        }

        .success-url-box strong {
            color: #2E7D32;
        }

        .success-url-box a {
            color: #1976D2;
            text-decoration: none;
            word-break: break-all;
        }

        .success-url-box a:hover {
            text-decoration: underline;
        }

        .info-box {
            background: #E3F2FD;
            padding: 12px;
            border-radius: 6px;
            margin: 15px 0;
            font-size: 13px;
            color: #1565C0;
            border-left: 4px solid #2196F3;
        }

        .error-message {
            background: #FFEBEE;
            padding: 12px;
            border-radius: 6px;
            margin: 15px 0;
            color: #C62828;
            border-left: 4px solid #f44336;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* ===================================
           STYLES MOBILE RESPONSIVE
           =================================== */
        
        /* Menu hamburger (cach√© par d√©faut sur desktop) */
        .mobile-menu-btn {
            display: none;
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1001;
            background: #4C97FF;
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 8px;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            pointer-events: auto;
            touch-action: manipulation;
        }
        
        .mobile-menu-btn:active {
            transform: scale(0.95);
        }
        
        /* Menu hamburger ORANGE √† droite pour les modes */
        .mobile-mode-menu-btn {
            display: none;
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 1001;
            background: #FF9800;
            color: white;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 8px;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            pointer-events: auto;
            touch-action: manipulation;
        }
        
        .mobile-mode-menu-btn:active {
            transform: scale(0.95);
        }
        
        /* Panneau lat√©ral des blocs (gauche) */
        .mobile-blocks-panel {
            display: none;
            position: fixed;
            top: 0;
            left: -100%;
            width: 280px;
            height: 100vh;
            background: white;
            box-shadow: 4px 0 12px rgba(0,0,0,0.3);
            z-index: 1000;
            transition: left 0.3s ease;
            overflow-y: auto;
            padding: 10px 15px 15px 15px; /* Tr√®s peu de padding en haut */
        }
        
        .mobile-blocks-panel.active {
            left: 0;
        }
        
        /* Premi√®re cat√©gorie coll√©e en haut */
        .mobile-blocks-panel .mobile-category-header:first-child {
            margin-top: 5px !important;
            margin-left: 60px; /* Augment√© de 50px √† 60px pour √©viter le bouton */
            padding-left: 5px; /* Un peu d'espace suppl√©mentaire */
        }
        
        /* Panneau lat√©ral des modes (droite) */
        .mobile-mode-panel {
            display: none;
            position: fixed;
            top: 0;
            right: -100%;
            width: 280px;
            height: 100vh;
            background: white;
            box-shadow: -4px 0 12px rgba(0,0,0,0.3);
            z-index: 1000;
            transition: right 0.3s ease;
            overflow-y: auto;
            padding: 70px 15px 15px 15px;
        }
        
        .mobile-mode-panel.active {
            right: 0;
        }
        
        .mobile-mode-panel h3 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }
        
        .mobile-mode-panel .mode-btn {
            display: block !important;
            width: 100%;
            margin-bottom: 15px;
            padding: 18px;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid transparent;
            font-weight: bold;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        
        .mobile-mode-panel .mode-btn:active {
            transform: scale(0.95);
        }
        
        .mobile-mode-panel .mode-btn.active {
            border-color: #FF9800;
            background: linear-gradient(135deg, #4C97FF 0%, #3373CC 100%);
        }
        
        /* Overlay pour fermer le menu */
        .mobile-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none; /* Par d√©faut ne bloque rien */
        }
        
        .mobile-overlay.active {
            opacity: 1;
            pointer-events: auto; /* Seulement quand actif */
        }
        
        /* ========== STYLES TEACHER MODE (PC ET MOBILE) ========== */
        
        /* Cacher les √©l√©ments √©l√®ve en mode professeur */
        body.teacher-mode #student-left {
            display: none !important;
        }
        
        /* Afficher les √©l√©ments professeur en mode professeur */
        body.teacher-mode #teacher-left {
            display: block !important;
        }
        
        /* ========== MODE PROFESSEUR PC : Boutons SOUS la grille ========== */
        /* S'applique uniquement sur GRAND √âCRAN (>768px) */
        @media (min-width: 769px) {
            .teacher-grid-and-buttons-wrapper {
                display: flex !important;
                flex-direction: column !important;
                gap: 15px !important;
                margin-top: 15px !important;
                align-items: center !important;
            }
            
            .teacher-grid-and-buttons-wrapper .grid-container {
                width: 100% !important;
                max-width: 600px !important;
                display: flex !important;
                justify-content: center !important;
            }
            
            .teacher-grid-and-buttons-wrapper #teacher-grid {
                width: fit-content !important; /* Adapter √† la taille du contenu */
                max-width: 100% !important;
                aspect-ratio: 1 !important;
            }
            
            /* Boutons en grille 2x2 SOUS la grille */
            .teacher-action-buttons {
                display: grid !important;
                grid-template-columns: repeat(2, 1fr) !important;
                grid-template-rows: repeat(2, 1fr) !important;
                gap: 10px !important;
                width: 100% !important;
                max-width: 600px !important;
            }
            
            .teacher-action-buttons button {
                width: 100% !important;
                padding: 15px 10px !important;
                font-size: 14px !important;
                line-height: 1.3 !important;
                white-space: normal !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                gap: 6px !important;
                text-align: center !important;
                min-height: 70px !important;
                border-radius: 8px !important;
            }
        }
        
        /* Media Query pour Mobile */
        @media (max-width: 768px) {
            /* Afficher les menus hamburger */
            .mobile-menu-btn,
            .mobile-mode-menu-btn {
                display: block;
            }
            
            .mobile-blocks-panel,
            .mobile-mode-panel {
                display: block;
            }
            
            .mobile-overlay {
                display: block;
            }
            
            /* Modifier le body pour √©viter le scroll */
            body {
                overflow: auto;
            }
            
            .app-container {
                height: auto;
                min-height: 100vh;
                overflow: visible;
            }
            
            /* Header compact */
            .header {
                padding: 8px 70px 8px 70px; /* Espace pour les 2 hamburgers */
                min-height: 50px;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .header h1 {
                display: none;
            }
            
            .header-subtitle {
                display: none;
            }
            
            .header > div:first-child {
                display: none;
            }
            
            /* Score dans le header */
            .score-display {
                font-size: 13px !important;
                padding: 6px 12px !important;
                margin: 0 auto !important;
            }
            
            /* CACHER les boutons de mode dans le header */
            .mode-selector {
                display: none !important;
            }
            
            /* Container principal scrollable */
            .main-content {
                display: flex;
                flex-direction: column;
                overflow-y: auto;
                padding: 10px;
                gap: 10px;
                flex: 1;
            }
            
            /* Panels √† 100% */
            .left-panel,
            .right-panel {
                width: 100% !important;
                max-width: none !important;
                padding: 10px !important;
            }
            
            /* FORCER student-left en flex container */
            #student-left {
                display: flex !important;
                flex-wrap: wrap !important;
                gap: 0 !important;
                position: relative !important;
                z-index: 1 !important;
            }
            
            /* Les 2 premiers enfants (cursus et niveau) c√¥te √† c√¥te */
            #student-left > .cursus-selector {
                flex: 0 0 48% !important;
                width: 48% !important;
                max-width: 48% !important;
                margin: 0 4% 10px 0 !important;
                display: block !important;
                position: relative !important;
                z-index: 10 !important;
            }
            
            #student-left > .level-selector {
                flex: 0 0 48% !important;
                width: 48% !important;
                max-width: 48% !important;
                margin: 0 0 10px 0 !important;
                display: block !important;
                position: relative !important;
                z-index: 10 !important;
            }
            
            .cursus-selector select,
            .level-selector select {
                width: 100% !important;
                font-size: 14px !important;
                padding: 8px !important;
                box-sizing: border-box !important;
                pointer-events: auto !important;
                touch-action: manipulation !important;
                position: relative !important;
                z-index: 10 !important;
            }
            
            .cursus-selector label,
            .level-selector label {
                font-size: 12px !important;
                margin-bottom: 4px !important;
                display: block !important;
                pointer-events: none !important;
            }
            
            /* Les 2 div de grilles (3√®me et 4√®me enfants) c√¥te √† c√¥te */
            #student-left > div:nth-child(3) {
                flex: 0 0 48% !important;
                width: 48% !important;
                max-width: 48% !important;
                margin: 0 4% 10px 0 !important;
                display: block !important;
                position: relative !important;
                z-index: 1 !important;
            }
            
            #student-left > div:nth-child(4) {
                flex: 0 0 48% !important;
                width: 48% !important;
                max-width: 48% !important;
                margin: 0 0 10px 0 !important;
                display: block !important;
                position: relative !important;
                z-index: 1 !important;
            }
            
            /* Les controls et result-message en 100% */
            #student-left > .controls,
            #student-left > #result-message {
                flex: 0 0 100% !important;
                width: 100% !important;
                margin: 0 !important;
                position: relative !important;
                z-index: 100 !important;
            }
            
            /* Boutons FORC√âS cliquables */
            .controls button,
            .btn {
                pointer-events: auto !important;
                touch-action: manipulation !important;
                cursor: pointer !important;
                -webkit-tap-highlight-color: rgba(0,0,0,0.1) !important;
            }
            
            /* Titres des grilles */
            #student-left h4 {
                font-size: 10px !important;
                margin: 10px 0 3px 0 !important;
                text-align: center !important;
                height: auto !important;
                min-height: 24px !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                line-height: 1.2 !important;
            }
            
            /* Conteneur de grille */
            .grid-container {
                display: flex !important;
                justify-content: center !important;
                width: 100% !important;
                padding: 0 !important;
                box-sizing: border-box !important;
            }
            
            /* Grilles avec max-width pour ne jamais d√©border */
            #teacher-grid,
            #student-grid,
            #target-grid {
                width: calc(100% - 4px) !important; /* -4px pour les bordures */
                height: auto !important;
                max-width: calc(100% - 4px) !important;
                aspect-ratio: 1 / 1 !important;
                margin: 0 auto !important;
                display: grid !important;
                grid-template-columns: repeat(10, 1fr) !important;
                grid-template-rows: repeat(10, 1fr) !important;
                box-sizing: border-box !important;
                overflow: hidden !important; /* Emp√™cher tout d√©bordement */
            }
            
            /* Cellules responsives - pas de taille fixe */
            #teacher-grid .cell,
            #student-grid .cell,
            #target-grid .cell {
                width: 100% !important;
                height: 100% !important;
                min-width: 0 !important; /* Permettre de r√©tr√©cir */
                min-height: 0 !important;
                border: 1px solid #ddd !important;
                box-sizing: border-box !important;
                position: relative !important;
                overflow: hidden !important;
            }
            
            /* Alias pour grid-cell (au cas o√π) */
            .grid-cell {
                width: 100% !important;
                height: 100% !important;
                min-width: 0 !important;
                min-height: 0 !important;
                font-size: 10px !important; /* R√©duire la taille des fl√®ches */
                line-height: 1 !important;
            }
            
            /* Tortue centr√©e dans la cellule */
            .turtle {
                width: 70% !important;
                height: 70% !important;
                position: absolute !important;
                top: 50% !important;
                left: 50% !important;
                transform: translate(-50%, -50%) !important;
            }
            
            /* Boutons sous les grilles */
            .controls {
                display: flex !important;
                gap: 8px !important;
                justify-content: center !important;
                flex-wrap: wrap !important;
                margin: 15px 0 !important;
                clear: both !important;
                width: 100% !important;
                position: relative !important;
                z-index: 10 !important;
            }
            
            .controls button,
            .btn {
                flex: 1 !important;
                min-width: 80px !important;
                max-width: 120px !important;
                padding: 12px 8px !important;
                font-size: 13px !important;
                border-radius: 6px !important;
                cursor: pointer !important;
                font-weight: bold !important;
                height: auto !important;
                line-height: 1.2 !important;
                pointer-events: auto !important;
                position: relative !important;
                z-index: 10 !important;
            }
            
            .controls button:active,
            .btn:active {
                transform: scale(0.95) !important;
            }
            
            /* Zone programme */
            .program-section {
                margin-top: 15px !important;
                width: 100% !important;
            }
            
            .program-section h2 {
                font-size: 16px !important;
                margin-bottom: 10px !important;
            }
            
            #program-blocks {
                min-height: 200px !important;
                padding: 15px !important;
            }
            
            /* Les vrais blocs .block dans le programme - PLUS GROS */
            #program-blocks .block {
                min-height: 56px !important;
                font-size: 16px !important;
                padding: 14px !important;
                line-height: 1.4 !important;
            }
            
            /* Program-block container */
            .program-block {
                margin-bottom: 10px !important;
                cursor: move !important;
            }
            
            .nested-blocks {
                min-height: 60px !important;
                margin-top: 8px !important;
                padding: 8px !important;
            }
            
            .nested-blocks .block {
                min-height: 52px !important;
                font-size: 15px !important;
            }
            
            /* Inputs dans les blocs plus gros */
            #program-blocks input[type="number"],
            #program-blocks input[type="text"],
            #program-blocks .value-slot input {
                font-size: 16px !important;
                padding: 8px !important;
                min-width: 60px !important;
                min-height: 40px !important;
                -webkit-appearance: none !important;
                -moz-appearance: textfield !important;
                appearance: none !important;
            }
            
            /* Selects (dropdowns) dans les blocs PLUS GROS et cliquables */
            #program-blocks select,
            #program-blocks .var-select {
                font-size: 16px !important;
                padding: 8px !important;
                min-height: 44px !important;
                min-width: 80px !important;
                pointer-events: auto !important;
                touch-action: manipulation !important;
                z-index: 100 !important;
                background: white !important;
                border: 2px solid #ddd !important;
                border-radius: 4px !important;
                cursor: pointer !important;
            }
            
            /* Masquer les fl√®ches spinner sur mobile */
            #program-blocks input[type="number"]::-webkit-inner-spin-button,
            #program-blocks input[type="number"]::-webkit-outer-spin-button {
                -webkit-appearance: none !important;
                margin: 0 !important;
            }
            
            /* Aussi dans le menu mobile */
            #mobile-blocks-list input[type="number"],
            #mobile-blocks-list input[type="text"] {
                font-size: 16px !important;
                padding: 8px !important;
                min-width: 60px !important;
                min-height: 40px !important;
                -webkit-appearance: none !important;
                -moz-appearance: textfield !important;
                appearance: none !important;
            }
            
            #mobile-blocks-list select {
                font-size: 16px !important;
                padding: 8px !important;
                min-height: 44px !important;
                pointer-events: auto !important;
            }
            
            #mobile-blocks-list input[type="number"]::-webkit-inner-spin-button,
            #mobile-blocks-list input[type="number"]::-webkit-outer-spin-button {
                -webkit-appearance: none !important;
                margin: 0 !important;
            }
            
            /* Bouton de suppression √ó plus gros */
            #program-blocks .remove-btn {
                min-width: 44px !important;
                min-height: 44px !important;
                font-size: 24px !important;
                padding: 8px !important;
            }
            
            /* Cacher la palette de blocs originale */
            .blocks-palette {
                display: none !important;
            }
            
            /* Sidebar cach√©e */
            .sidebar {
                display: none !important;
            }
            
            /* Variables plus grosses */
            .variable-item {
                padding: 10px !important;
                font-size: 15px !important;
            }
            
            /* Modals adapt√©es */
            .modal-content {
                width: 95% !important;
                max-width: 400px !important;
                max-height: 90vh !important;
                overflow-y: auto !important;
            }
            
            /* Inputs plus gros */
            input[type="text"],
            input[type="number"],
            select {
                font-size: 16px !important;
                padding: 10px !important;
            }
            
            /* Message de r√©sultat */
            #result-message {
                margin-top: 10px !important;
                font-size: 14px !important;
            }
            
            /* ========== MODE PROFESSEUR MOBILE ========== */
            
            /* En mode professeur : cacher les √©l√©ments √©l√®ve */
            body.teacher-mode #student-left {
                display: none !important;
            }
            
            /* En mode professeur : afficher les √©l√©ments professeur */
            body.teacher-mode #teacher-left {
                display: block !important;
            }
            
            /* Paint module : bouton g√©n√©ration automatique m√™me largeur que la ligne du dessus */
            body.teacher-mode .paint-module {
                width: 100% !important;
            }
            
            body.teacher-mode .paint-module button[onclick="generateRandomPattern()"] {
                width: 100% !important;
                max-width: none !important; /* CRUCIAL : Enlever la limite de 120px */
                min-width: 0 !important;
                flex: none !important; /* Ne pas √™tre affect√© par flex */
                margin-left: 0 !important;
                margin-right: 0 !important;
                box-sizing: border-box !important;
            }
            
            /* Assurez que la ligne avec difficult√© + g√©n√©rer prend toute la largeur */
            body.teacher-mode .paint-module > div[style*="display: flex"] {
                width: 100% !important;
            }
            
            /* Wrapper grille + boutons en flex horizontal */
            .teacher-grid-and-buttons-wrapper {
                display: flex !important;
                gap: 10px !important;
                margin-top: 15px !important;
                align-items: stretch !important; /* √âtirer sur toute la hauteur */
            }
            
            /* Grille prend 75% de l'espace */
            .teacher-grid-and-buttons-wrapper .grid-container {
                flex: 0 0 calc(75% - 7.5px) !important;
                display: flex !important;
                align-items: center !important;
            }
            
            /* Forcer la grille √† d√©finir la hauteur */
            .teacher-grid-and-buttons-wrapper #teacher-grid {
                width: 100% !important;
                aspect-ratio: 1 !important;
            }
            
            /* Boutons prennent 25% de l'espace ET s'√©tirent sur la hauteur de la grille */
            .teacher-action-buttons {
                display: flex !important;
                flex-direction: column !important;
                gap: 8px !important;
                flex: 0 0 calc(25% - 2.5px) !important;
                align-self: stretch !important; /* S'√©tirer pour matcher la hauteur */
            }
            
            /* SUR PC (>768px) : Afficher les 4 boutons en grille 2x2 */
            @media (min-width: 769px) {
                .teacher-action-buttons {
                    display: grid !important;
                    grid-template-columns: repeat(2, 1fr) !important;
                    grid-template-rows: repeat(2, 1fr) !important;
                    gap: 8px !important;
                }
                
                .teacher-action-buttons button {
                    flex: none !important; /* Annuler le flex pour la grille */
                    height: 100% !important;
                }
            }
            
            /* Chaque bouton prend 1/4 de la hauteur disponible avec gap */
            .teacher-action-buttons button {
                width: 100% !important;
                min-width: 0 !important;
                padding: 8px 4px !important;
                font-size: 11px !important;
                line-height: 1.2 !important;
                white-space: normal !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                gap: 4px !important;
                text-align: center !important;
                flex: 1 1 0 !important; /* R√©partition √©gale avec base 0 */
                min-height: 0 !important;
                border-radius: 6px !important; /* Garder les arrondis normaux */
            }
            
            /* ========== CORRECTIONS MODAL "G√âRER LES NIVEAUX" MOBILE ========== */
            
            /* 1. CROIX : la laisser d√©passer en dehors, en haut √† droite, d√©cal√©e de 20px vers la gauche */
            #level-manager-modal .modal-close,
            #auto-create-modal .modal-close {
                top: -14px !important;
                right: 6px !important; /* -14px + 20px = 6px */
                z-index: 10001 !important;
            }
            
            /* 2. ALIGNEMENT DES LABELS - Forcer m√™me hauteur pour tous */
            #level-manager-modal label,
            #auto-create-modal label {
                min-height: 2.8em !important; /* Hauteur pour 2 lignes de texte */
                display: flex !important;
                align-items: flex-end !important; /* Aligne le texte en bas */
                line-height: 1.4 !important;
            }
            
            /* 3. ENLEVER LES FL√àCHES DES INPUT NUMBER */
            input[type="number"]::-webkit-outer-spin-button,
            input[type="number"]::-webkit-inner-spin-button {
                -webkit-appearance: none !important;
                margin: 0 !important;
            }
            
            input[type="number"] {
                -moz-appearance: textfield !important;
                appearance: textfield !important;
            }
            
            /* 4. CHAMPS NE D√âBORDENT PAS */
            #level-manager-modal input,
            #auto-create-modal input {
                max-width: 100% !important;
                width: 100% !important;
                box-sizing: border-box !important;
            }
            
            /* 5. IC√îNES POUBELLE CONTENUES - Ne pas changer le layout */
            #level-manager-modal .btn-danger {
                min-width: 40px !important;
                max-width: 40px !important;
                padding: 6px !important;
                font-size: 16px !important;
                flex-shrink: 0 !important;
            }
            
            /* IMPORTANT : Ne PAS changer le layout des items de niveau */
            /* Ils sont d√©j√† en flex row dans le JS, c'est correct */
            
            /* Enlever le scroll horizontal en ajustant les gaps */
            #level-manager-modal .modal-content,
            #auto-create-modal .modal-content {
                max-width: 95vw !important;
                overflow-x: hidden !important;
            }
            
            #level-manager-modal .modal-content > div,
            #auto-create-modal .modal-content > div {
                max-width: 100% !important;
                overflow-x: hidden !important;
            }
            
            /* R√©duire les gaps sur mobile pour √©viter d√©bordement */
            #level-manager-modal div[style*="display: flex"][style*="gap"] {
                gap: 10px !important;
            }
            
            /* ========== RESPONSIVE : PASSER √Ä LA LIGNE SI N√âCESSAIRE ========== */
            
            /* Header modal : bouton "Cr√©ation automatis√©e" sur ligne s√©par√©e en mobile */
            @media (max-width: 768px) {
                .modal-header-with-button {
                    flex-direction: column !important;
                    align-items: stretch !important;
                    gap: 15px !important;
                }
                
                .modal-header-with-button h2 {
                    text-align: center !important;
                }
                
                .auto-create-btn {
                    width: 100% !important;
                    max-width: 100% !important;
                    padding: 12px 16px !important;
                    font-size: 14px !important;
                    display: block !important; /* Surcharger display: flex de .btn */
                    box-sizing: border-box !important;
                    text-align: center !important;
                }
            }
            
            /* Configuration des mondes : 3 colonnes -> colonne si trop √©troit */
            @media (max-width: 500px) {
                .worlds-config-inputs {
                    flex-direction: column !important;
                    gap: 15px !important;
                }
                
                .worlds-config-inputs > div {
                    width: 100% !important;
                }
                
                .worlds-config-inputs select,
                .worlds-config-inputs input {
                    width: 100% !important;
                    max-width: none !important;
                }
                
                /* Auto-create modal : Configuration g√©n√©rale */
                .auto-config-inputs {
                    flex-direction: column !important;
                    gap: 15px !important;
                }
                
                .auto-config-inputs > div {
                    width: 100% !important;
                }
                
                .auto-config-inputs select,
                .auto-config-inputs input {
                    width: 100% !important;
                    max-width: none !important;
                }
            }
            
            /* Auto-create modal : Configuration rapide - 4 colonnes -> 2 colonnes -> 1 colonne */
            @media (max-width: 768px) {
                .quick-config-grid {
                    grid-template-columns: repeat(2, 1fr) !important; /* 2 colonnes sur tablette */
                }
            }
            
            @media (max-width: 500px) {
                .quick-config-grid {
                    grid-template-columns: 1fr !important; /* 1 colonne sur mobile */
                }
            }
            
            /* Points requis pour d√©bloquer : wrap si trop √©troit */
            .world-config-item {
                flex-wrap: wrap !important;
                gap: 10px !important;
            }
            
            @media (max-width: 450px) {
                .world-config-item {
                    flex-direction: column !important;
                    align-items: flex-start !important;
                }
                
                .world-config-item > span:first-child {
                    min-width: 0 !important;
                    width: 100% !important;
                }
                
                .world-config-item > div {
                    width: 100% !important;
                }
            }
            
            /* Items de niveaux : optimiser l'espace avant wrap */
            .level-item {
                flex-wrap: wrap !important;
                gap: 8px !important; /* R√©duire le gap pour gagner de l'espace */
            }
            
            /* R√©duire l'espace du nombre de blocs sur mobile */
            @media (max-width: 768px) {
                .level-item > div:nth-child(3) {
                    min-width: 50px !important; /* Au lieu de 60px */
                    flex-shrink: 0 !important;
                }
            }
            
            /* Bouton poubelle : ne wrap que si vraiment n√©cessaire */
            .level-delete-btn {
                flex-shrink: 0 !important;
                min-width: 36px !important;
            }
            
            /* Sur tr√®s petits √©crans, assurer que le bouton poubelle ne d√©borde pas */
            @media (max-width: 350px) {
                .level-item button {
                    margin-left: 0 !important;
                    margin-top: 5px !important;
                    width: 100% !important;
                }
            }
        }
        
        /* Media Query pour tr√®s petits √©crans */
        @media (max-width: 480px) {
            .mobile-menu-btn,
            .mobile-mode-menu-btn {
                width: 45px;
                height: 45px;
                font-size: 20px;
            }
            
            .controls button,
            .btn {
                min-width: 70px !important;
                font-size: 12px !important;
            }
        }
    </style>
</head>
<body>
    <!-- √âl√©ments Mobile -->
    <!-- Menu BLEU √† gauche pour les blocs -->
    <button class="mobile-menu-btn" id="mobile-menu-btn" onclick="toggleMobileMenu()">‚ò∞</button>
    
    <!-- Menu ORANGE √† droite pour les modes -->
    <button class="mobile-mode-menu-btn" id="mobile-mode-menu-btn" onclick="toggleMobileMode()">‚ò∞</button>
    
    <div class="mobile-overlay" id="mobile-overlay" onclick="closeMobileMenus()"></div>
    
    <!-- Panneau des blocs (gauche) -->
    <div class="mobile-blocks-panel" id="mobile-blocks-panel">
        <div id="mobile-blocks-list"></div>
    </div>
    
    <!-- Panneau des modes (droite) -->
    <div class="mobile-mode-panel" id="mobile-mode-panel">
        <h3>‚öôÔ∏è Mode</h3>
        <button class="mode-btn active" id="mobile-student-mode-btn" onclick="switchModeAndClose('student')" style="background: #2196F3; color: white;">üë®‚Äçüéì Mode √âl√®ve</button>
        <button class="mode-btn" id="mobile-teacher-mode-btn" onclick="switchModeAndClose('teacher')" style="color: #2196F3;">üë®‚Äçüè´ Mode Professeur</button>
        
        <!-- Boutons √âL√àVE (sauvegarde/chargement avec code) -->
        <div id="mobile-student-buttons" style="display: none; margin-top: 15px;">
            <button class="mode-btn" id="mobile-student-save-btn" onclick="generateStudentCodeMobile()" style="background: #FF9800; color: white; width: 100%; margin-bottom: 8px;">üíæ Sauvegarder</button>
            <button class="mode-btn" id="mobile-student-load-btn" onclick="openLoadProgressModalMobile()" style="background: #9C27B0; color: white; width: 100%; margin-bottom: 8px;">üì• Charger</button>
        </div>
        
        <!-- Boutons professeur (visibles uniquement en mode professeur) -->
        <div id="mobile-teacher-buttons" style="display: none; margin-top: 15px;">
            <!-- Boutons en ligne (synchronis√©s avec PC) -->
            <button class="mode-btn" id="mobile-save-online-btn" onclick="saveLevelBeforeOnlineMobile()" style="display: none; background: #4CAF50; color: white; width: 100%; margin-bottom: 8px;">‚òÅÔ∏è Sauvegarder en ligne</button>
            <button class="mode-btn" id="mobile-load-levels-btn" onclick="openLoadOnlineModalMobile()" style="display: none; background: #2196F3; color: white; width: 100%; margin-bottom: 8px;">üì• Charger les niveaux</button>
            
            <!-- Boutons conditionnels (synchronis√©s avec PC) -->
            <button class="mode-btn" id="mobile-copy-student-link-btn" onclick="copyStudentLinkMobile()" style="display: none; background: #FF9800; color: white; width: 100%; margin-bottom: 8px;">üîó Copier lien √©l√®ve</button>
            <button class="mode-btn" id="mobile-delete-online-btn" onclick="openDeleteOnlineModalMobile()" style="display: none; background: #f44336; color: white; width: 100%;">üóëÔ∏è Supprimer ma sauvegarde</button>
        </div>
    </div>
    
    <div class="app-container">
        <div class="header" id="app-header">
            <div>
                <h1>üé® Programmation motifs - par Max</h1>
                <div class="header-subtitle" id="header-subtitle" style="display: none;">Mode √©diteur : cr√©ez des niveaux pour vos √©l√®ves</div>
            </div>
            <div class="score-display" id="header-score-display" style="background: rgba(255, 215, 0, 0.9); margin: 0 auto; padding: 8px 16px; font-size: 14px;">
                üéØ Score: <span id="score">0</span> points
            </div>
            <div class="mode-selector">
                <div id="student-save-buttons" style="display: none;">
                    <button class="mode-btn" onclick="generateStudentCode()" style="background: #FF9800; border-color: white; padding: 8px 12px; font-size: 13px;">üíæ Sauvegarder</button>
                    <button class="mode-btn" onclick="openLoadProgressModal()" style="background: #9C27B0; border-color: white; padding: 8px 12px; font-size: 13px;">üì• Charger</button>
                </div>
                <button class="mode-btn" id="copy-student-link-btn" onclick="copyStudentLink()" style="display: none; background: #FF9800; border-color: white; color: white;">üîó Copier lien √©l√®ve</button>
                <button class="mode-btn" id="delete-online-btn" onclick="openDeleteOnlineModal()" style="display: none; background: #f44336; border-color: white; color: white;">üóëÔ∏è Supprimer ma sauvegarde</button>
                <button class="mode-btn" id="save-online-btn" onclick="saveLevelBeforeOnline()" style="display: none; background: #4CAF50; border-color: white; color: white;">‚òÅÔ∏è Sauvegarder en ligne</button>
                <button class="mode-btn" id="load-levels-btn" onclick="openLoadOnlineModal()" style="display: none; background: #2196F3; border-color: white; color: white;">üì• Charger les niveaux</button>
                <button class="mode-btn active" onclick="switchMode('student')">Mode √âl√®ve</button>
                <button class="mode-btn" onclick="switchMode('teacher')">Mode Professeur</button>
            </div>
        </div>

        <div class="main-content">
            <!-- Colonne de GAUCHE - Grille et contr√¥les -->
            <div class="left-panel">
                <!-- Mode √âl√®ve -->
                <div id="student-left">
                    <div class="cursus-selector">
                        <label>Cursus:</label>
                        <select id="cursus-select" onchange="loadCursusLevels()">
                            <option value="5eme">5√®me</option>
                            <option value="4eme">4√®me</option>
                            <option value="3eme">3√®me</option>
                        </select>
                    </div>

                    <div class="level-selector">
                        <label>Niveau:</label>
                        <select id="level-select" onchange="loadLevel()">
                            <option value="0">Niveau 1</option>
                        </select>
                    </div>

                    <div style="margin-bottom: 5px; margin-top: 10px;">
                        <h4 style="text-align: center; font-size: 13px; color: #555; margin-bottom: 2px;">üìã Reproduis le motif ci-dessous</h4>
                        <div class="grid-container">
                            <div id="target-grid" class="grid"></div>
                        </div>
                    </div>

                    <div style="margin-bottom: 5px;">
                        <h4 style="text-align: center; font-size: 13px; color: #555; margin-bottom: 2px;">Ta grille</h4>
                        <div class="grid-container">
                            <div id="student-grid" class="grid"></div>
                        </div>
                    </div>

                    <div class="controls">
                        <button id="run-btn" class="btn btn-primary" onclick="executeProgram()">‚ñ∂Ô∏è<br>Tester</button>
                        <button class="btn btn-danger" onclick="clearGrid()">üóëÔ∏è<br>Effacer</button>
                        <button class="btn btn-success" onclick="validateLevel()">‚úÖ<br>Valider</button>
                    </div>

                    <div id="result-message"></div>
                </div>

                <!-- Mode Professeur -->
                <div id="teacher-left" style="display: none;">
                    <div class="cursus-selector">
                        <label>Cursus:</label>
                        <select id="teacher-cursus-select" onchange="loadTeacherLevels()">
                            <option value="5eme">5√®me</option>
                            <option value="4eme">4√®me</option>
                            <option value="3eme">3√®me</option>
                        </select>
                    </div>

                    <div class="level-selector">
                        <label>Niveau √† √©diter:</label>
                        <div style="display: flex; gap: 5px;">
                            <select id="teacher-level-select" onchange="saveCurrentAndLoadTeacherLevel()" style="flex: 1;">
                                <option value="new">+ Nouveau niveau</option>
                            </select>
                            <button class="btn" onclick="openLevelManagerModal()" style="padding: 8px 12px; background: #FF9800; color: white; font-size: 11px; white-space: nowrap;" title="G√©rer les niveaux et les mondes">
                                ‚öôÔ∏è G√©rer
                            </button>
                        </div>
                    </div>

                    <div class="paint-module">
                        <h4 style="font-size: 13px; color: #555; margin-bottom: 8px; font-weight: bold;">üé® Mode pinceau</h4>
                        <div class="color-picker" id="color-picker-section">
                            <div class="color-option" data-color="red" style="background-color: #FF0000;" onclick="selectPaintColor('red')" title="Rouge"></div>
                            <div class="color-option" data-color="yellow" style="background-color: #FFFF00;" onclick="selectPaintColor('yellow')" title="Jaune"></div>
                            <div class="color-option" data-color="green" style="background-color: #00FF00;" onclick="selectPaintColor('green')" title="Vert"></div>
                            <div class="color-option" data-color="blue" style="background-color: #0000FF;" onclick="selectPaintColor('blue')" title="Bleu"></div>
                            <div class="color-option" data-color="black" style="background-color: #000000;" onclick="selectPaintColor('black')" title="Noir"></div>
                            <div class="color-option eraser" data-color="white" style="background-color: #FFFFFF; border: 2px solid #999;" onclick="selectPaintColor('white')" title="Gomme">üßπ</div>
                        </div>
                        <div class="pattern-picker" id="pattern-picker-section" style="display: none;">
                            <div class="pattern-option" data-pattern="stairs" onclick="selectPattern('stairs')" title="Escalier">
                                <svg width="40" height="40" viewBox="0 0 40 40">
                                    <path d="M 0,40 L 0,30 L 10,30 L 10,20 L 20,20 L 20,10 L 30,10 L 30,0 L 40,0 L 40,40 Z" fill="#333"/>
                                </svg>
                            </div>
                            <div class="pattern-option" data-pattern="checkerboard" onclick="selectPattern('checkerboard')" title="Damier">
                                <svg width="40" height="40" viewBox="0 0 40 40">
                                    <rect x="0" y="0" width="10" height="10" fill="#333"/>
                                    <rect x="20" y="0" width="10" height="10" fill="#333"/>
                                    <rect x="10" y="10" width="10" height="10" fill="#333"/>
                                    <rect x="30" y="10" width="10" height="10" fill="#333"/>
                                    <rect x="0" y="20" width="10" height="10" fill="#333"/>
                                    <rect x="20" y="20" width="10" height="10" fill="#333"/>
                                    <rect x="10" y="30" width="10" height="10" fill="#333"/>
                                    <rect x="30" y="30" width="10" height="10" fill="#333"/>
                                </svg>
                            </div>
                            <div class="pattern-option" data-pattern="square" onclick="selectPattern('square')" title="Carr√©">
                                <svg width="40" height="40" viewBox="0 0 40 40">
                                    <rect x="8" y="8" width="24" height="24" fill="none" stroke="#333" stroke-width="3"/>
                                </svg>
                            </div>
                            <div class="pattern-option" data-pattern="zigzag" onclick="selectPattern('zigzag')" title="Zigzag">
                                <svg width="40" height="40" viewBox="0 0 40 40">
                                    <path d="M 0,30 L 10,10 L 20,30 L 30,10 L 40,30" stroke="#333" stroke-width="3" fill="none"/>
                                </svg>
                            </div>
                            <div class="pattern-option" data-pattern="cross" onclick="selectPattern('cross')" title="Croix">
                                <svg width="40" height="40" viewBox="0 0 40 40">
                                    <path d="M 8,8 L 32,32 M 32,8 L 8,32" stroke="#333" stroke-width="3"/>
                                </svg>
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px; margin-top: 10px; align-items: center;">
                            <select id="generation-difficulty" onchange="handleDifficultyChange()" style="flex: 1; padding: 8px; border: 2px solid #E0E0E0; border-radius: 4px; font-size: 12px; background: white;">
                                <option value="1">Difficult√© 1</option>
                                <option value="2">Difficult√© 2</option>
                                <option value="3">Difficult√© 3</option>
                            </select>
                            <button class="btn" onclick="generateProgramFromPaint()" style="flex: 2; background: #4CAF50; color: white; padding: 8px; font-size: 12px; font-weight: bold;">
                                ‚ö° G√©n√©rer
                            </button>
                        </div>
                        <button class="btn" onclick="generateRandomPattern()" style="width: 100%; margin-top: 8px; background: #FF9800; color: white; padding: 10px; font-size: 13px; font-weight: bold;">
                            üé≤ G√©n√©ration automatique
                        </button>
                    </div>

                    <!-- Container flex pour grille + boutons c√¥te √† c√¥te -->
                    <div class="teacher-grid-and-buttons-wrapper">
                        <div class="grid-container">
                            <div id="teacher-grid" class="grid"></div>
                        </div>

                        <div class="teacher-action-buttons">
                            <button class="btn btn-primary" onclick="executeProgram()">‚ñ∂Ô∏è Tester</button>
                            <button class="btn btn-danger" onclick="clearGridAndPaint()">üóëÔ∏è Effacer</button>
                            <button class="btn btn-success" onclick="addOrSaveLevel()">‚ûï Ajouter</button>
                            <button class="btn btn-warning" onclick="overwriteSelectedLevel()" id="overwrite-level-btn">üíæ √âcraser</button>
                        </div>
                    </div>

                    <div id="teacher-result-message"></div>
                </div>
            </div>

            <!-- Colonne du MILIEU - Palette de blocs -->
            <div class="middle-panel">
                <div class="blocks-palette">
                    <div class="blocks-category">
                        <div class="category-header expanded" onclick="toggleCategory(this)">
                            üé® Apparence
                        </div>
                        <div class="category-blocks">
                            <div class="block looks" draggable="true" ondragstart="drag(event)" data-type="color" data-value="red">couleur ROUGE</div>
                            <div class="block looks" draggable="true" ondragstart="drag(event)" data-type="color" data-value="yellow">couleur JAUNE</div>
                            <div class="block looks" draggable="true" ondragstart="drag(event)" data-type="color" data-value="green">couleur VERT</div>
                            <div class="block looks" draggable="true" ondragstart="drag(event)" data-type="color" data-value="blue">couleur BLEU</div>
                            <div class="block looks" draggable="true" ondragstart="drag(event)" data-type="color" data-value="black">couleur NOIR</div>
                        </div>
                    </div>

                    <div class="blocks-category">
                        <div class="category-header expanded" onclick="toggleCategory(this)">
                            ‚û°Ô∏è Mouvement
                        </div>
                        <div class="category-blocks">
                            <div class="block motion" draggable="true" ondragstart="drag(event)" data-type="forward">avancer</div>
                            <div class="block motion" draggable="true" ondragstart="drag(event)" data-type="back">reculer</div>
                            <div class="block motion" draggable="true" ondragstart="drag(event)" data-type="right">tourner ‚Üª droite</div>
                            <div class="block motion" draggable="true" ondragstart="drag(event)" data-type="left">tourner ‚Ü∫ gauche</div>
                        </div>
                    </div>

                    <div class="blocks-category">
                        <div class="category-header expanded" onclick="toggleCategory(this)">
                            üîÅ Contr√¥le
                        </div>
                        <div class="category-blocks">
                            <div class="block control" draggable="true" ondragstart="drag(event)" data-type="repeat">
                                r√©p√©ter 
                                <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)">
                                    <input type="number" value="10" min="1" max="100" onclick="event.stopPropagation()">
                                </span>
                                fois
                            </div>
                        </div>
                    </div>

                    <div class="blocks-category">
                        <div class="category-header expanded" onclick="toggleCategory(this)">
                            üìä Variables
                        </div>
                        <div class="category-blocks">
                            <button class="btn" onclick="createNewVariable()" style="width: 100%; margin-bottom: 5px; padding: 6px; font-size: 12px; background: #FF8C1A; color: white;">
                                + Cr√©er une variable
                            </button>
                            <div id="variable-blocks" style="display: none;">
                                <div class="block variables" draggable="true" ondragstart="drag(event)" data-type="var-value">
                                    <select onclick="event.stopPropagation()" class="var-select">
                                        <option value="">variable</option>
                                    </select>
                                </div>
                                <div class="block variables" draggable="true" ondragstart="drag(event)" data-type="variable">
                                    mettre <select onclick="event.stopPropagation()" class="var-select"><option value="">nom</option></select> √† 
                                    <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)">
                                        <input type="number" value="0" onclick="event.stopPropagation()">
                                    </span>
                                </div>
                                <div class="block variables" draggable="true" ondragstart="drag(event)" data-type="change-var">
                                    ajouter 
                                    <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)">
                                        <input type="number" value="1" onclick="event.stopPropagation()">
                                    </span>
                                    √† <select onclick="event.stopPropagation()" class="var-select"><option value="">nom</option></select>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="blocks-category">
                        <div class="category-header expanded" onclick="toggleCategory(this)">
                            üî¢ Op√©rateurs
                        </div>
                        <div class="category-blocks">
                            <div class="block operators" draggable="true" ondragstart="drag(event)" data-type="operator">
                                <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)">
                                    <input type="text" placeholder="a" onclick="event.stopPropagation()">
                                </span>
                                <select onclick="event.stopPropagation()">
                                    <option value="+">+</option>
                                    <option value="-">-</option>
                                    <option value="*">√ó</option>
                                    <option value="/">√∑</option>
                                </select>
                                <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)">
                                    <input type="text" placeholder="b" onclick="event.stopPropagation()">
                                </span>
                            </div>
                        </div>
                    </div>

                    <div class="blocks-category">
                        <div class="category-header expanded" onclick="toggleCategory(this)">
                            üîÄ Condition
                        </div>
                        <div class="category-blocks">
                            <div class="block sensing" draggable="true" ondragstart="drag(event)" data-type="if">
                                si 
                                <select class="var-select" onclick="event.stopPropagation()">
                                    <option value="">variable</option>
                                </select>
                                <select class="compare-op" onclick="event.stopPropagation()">
                                    <option value="<">&lt;</option>
                                    <option value=">">&gt;</option>
                                    <option value="=">=</option>
                                    <option value="<=">&le;</option>
                                    <option value=">=">&ge;</option>
                                </select>
                                <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)">
                                    <input type="text" placeholder="valeur" onclick="event.stopPropagation()">
                                </span>
                                alors
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Colonne de DROITE - Zone de programmation -->
            <div class="right-panel">
                <div class="program-area" ondrop="drop(event)" ondragover="allowDrop(event)" ondragleave="dragLeave(event)">
                    <h3>üìù Mon Programme <span id="block-count" style="color: #888; font-size: 14px; font-weight: normal;">(0 blocs)</span></h3>
                    <div id="program-blocks" class="program-blocks-container"></div>
                </div>

                <div id="variable-display" class="variable-display" style="display: none;">
                    <h4>üìä Variables</h4>
                    <div id="variables-list" class="variables-list"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal pour le mot de passe professeur -->
    <div id="password-modal" class="modal">
        <div style="position: relative; max-width: 400px; width: 90%;">
            <span class="modal-close" onclick="closePasswordModal()">&times;</span>
            <div class="modal-content" style="margin: 0; width: 100%;">
                <h2>üîí Acc√®s Professeur</h2>
                <p>Entrez le mot de passe pour acc√©der au mode √©diteur:</p>
                <input type="password" id="teacher-password" placeholder="Mot de passe" oninput="checkPasswordAuto()" onkeypress="if(event.key === 'Enter') checkPassword()">
            </div>
        </div>
    </div>

    <!-- Modal pour cr√©er une variable -->
    <div id="variable-modal" class="modal">
        <div class="modal-content">
            <h2>üìä Cr√©er une variable</h2>
            <p>Entrez le nom de la nouvelle variable:</p>
            <input type="text" id="variable-name" placeholder="Nom de la variable" onkeypress="if(event.key === 'Enter') confirmCreateVariable()">
            <div class="modal-buttons">
                <button class="btn btn-primary" onclick="confirmCreateVariable()">Cr√©er</button>
                <button class="btn btn-danger" onclick="closeVariableModal()">Annuler</button>
            </div>
        </div>
    </div>

    <!-- Modal pour g√©rer les niveaux et les mondes -->
    <div id="level-manager-modal" class="modal">
        <div class="modal-wrapper-large" style="position: relative; max-width: 800px; width: 95%; overflow: visible;">
            <span class="modal-close level-manager-close" onclick="closeLevelManagerModal()">&times;</span>
            <div class="modal-content" style="max-width: 800px; max-height: 85vh; padding: 40px 30px 30px 30px; margin: 0; width: 100%; overflow: visible;">
                <div style="max-height: calc(85vh - 80px); overflow-y: auto; overflow-x: visible; padding-right: 5px;">
                    <div class="modal-header-with-button">
                        <h2>‚öôÔ∏è Gestion des Niveaux et Mondes</h2>
                        <button class="btn auto-create-btn" onclick="openAutoCreateModal()">
                            ‚ú® Cr√©ation automatis√©e des niveaux
                        </button>
                    </div>
            
            <!-- Section Mondes -->
            <div style="background: #E3F2FD; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="color: #1976D2; margin-bottom: 10px; font-size: 16px;">üåç Configuration des Mondes</h3>
                <div class="worlds-config-inputs" style="display: flex; gap: 20px; margin-bottom: 15px;">
                    <div style="flex: 1; display: flex; flex-direction: column;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px; font-size: 13px;">Cursus:</label>
                        <select id="modal-cursus-select" onchange="switchModalCursus()" style="width: 80px; height: 34px; margin-top: 2px; padding: 6px; border: 2px solid #E0E0E0; border-radius: 4px; font-size: 13px; background: white; box-sizing: border-box; -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2712%27 height=%278%27 viewBox=%270 0 12 8%27%3e%3cpath fill=%27%23333%27 d=%27M0 0l6 8 6-8z%27/%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 6px center; padding-right: 24px;">
                            <option value="5eme">5√®me</option>
                            <option value="4eme">4√®me</option>
                            <option value="3eme">3√®me</option>
                        </select>
                    </div>
                    <div style="flex: 1; display: flex; flex-direction: column;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px; font-size: 13px;">Nombre de mondes:</label>
                        <input type="number" id="num-worlds" min="1" max="10" value="1" onchange="updateWorldsConfig()" style="width: 80px; height: 34px; margin-top: 2px; padding: 6px; border: 2px solid #E0E0E0; border-radius: 4px; font-size: 13px; box-sizing: border-box;">
                    </div>
                    <div style="flex: 1; display: flex; flex-direction: column;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px; font-size: 13px;">Niveaux par monde:</label>
                        <input type="number" id="levels-per-world" min="1" max="20" value="10" onchange="updateWorldsConfig()" style="width: 80px; height: 34px; margin-top: 2px; padding: 6px; border: 2px solid #E0E0E0; border-radius: 4px; font-size: 13px; box-sizing: border-box;">
                    </div>
                </div>
                <div id="worlds-config" style="margin-top: 15px;">
                    <!-- Configuration des points par monde sera g√©n√©r√©e ici -->
                </div>
            </div>
            
            <!-- Section Liste des Niveaux -->
            <div style="background: #FFF9C4; padding: 15px; border-radius: 8px;">
                <h3 style="color: #F57F17; margin-bottom: 10px; font-size: 16px;">üìã Liste des Niveaux</h3>
                <p style="font-size: 12px; color: #666; margin-bottom: 10px;">Glissez-d√©posez un niveau sur un autre pour √©changer leur contenu</p>
                <div id="levels-list">
                    <!-- Liste des niveaux sera g√©n√©r√©e ici -->
                </div>
            </div>
            </div>
        </div>
        </div>
    </div>

    <!-- Modal pour la cr√©ation automatis√©e -->
    <div id="auto-create-modal" class="modal">
        <div class="modal-wrapper-large" style="position: relative; max-width: 600px; width: 95%; overflow: visible;">
            <span class="modal-close auto-create-close" onclick="closeAutoCreateModal()">&times;</span>
            <div class="modal-content" style="max-width: 600px; max-height: 85vh; padding: 40px 30px 30px 30px; margin: 0; width: 100%; overflow: visible;">
                <div style="max-height: calc(85vh - 80px); overflow-y: auto; overflow-x: visible; padding-right: 5px;">
                    <h2>‚ú® Cr√©ation Automatis√©e des Niveaux</h2>
                    
                    <!-- Bouton de g√©n√©ration -->
                    <button id="generate-btn-top" class="btn btn-success" onclick="generateWorldsAutomatically()" style="width: 100%; padding: 15px; font-size: 16px; font-weight: bold; margin-bottom: 20px;">
                        üé≤ G√©n√©rer automatiquement les mondes
                    </button>
                
                <!-- Configuration g√©n√©rale -->
                <div style="background: #E3F2FD; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="color: #1976D2; margin-bottom: 10px; font-size: 16px;">Configuration g√©n√©rale</h3>
                <div class="auto-config-inputs" style="display: flex; gap: 20px; margin-bottom: 10px;">
                    <div style="flex: 1; display: flex; flex-direction: column;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px; font-size: 13px;">Cursus:</label>
                        <select id="auto-cursus-select" onchange="updateAutoLimits()" style="width: 80px; height: 34px; margin-top: 2px; padding: 6px; border: 2px solid #E0E0E0; border-radius: 4px; font-size: 13px; background: white; box-sizing: border-box; -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2712%27 height=%278%27 viewBox=%270 0 12 8%27%3e%3cpath fill=%27%23333%27 d=%27M0 0l6 8 6-8z%27/%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 6px center; padding-right: 24px;">
                            <option value="all">Tous</option>
                            <option value="5eme">5√®me</option>
                            <option value="4eme">4√®me</option>
                            <option value="3eme">3√®me</option>
                        </select>
                    </div>
                    <div style="flex: 1; display: flex; flex-direction: column;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px; font-size: 13px;">Nombre de mondes:</label>
                        <input type="number" id="auto-num-worlds" min="1" value="3" onchange="updateAutoWorldsConfig()" style="width: 80px; height: 34px; margin-top: 2px; padding: 6px; border: 2px solid #E0E0E0; border-radius: 4px; font-size: 13px; box-sizing: border-box;">
                    </div>
                    <div style="flex: 1; display: flex; flex-direction: column;">
                        <label style="display: block; font-weight: bold; margin-bottom: 5px; font-size: 13px;">Niveaux par monde:</label>
                        <input type="number" id="auto-levels-per-world" min="1" value="10" onchange="updateAutoWorldsConfig()" style="width: 80px; height: 34px; margin-top: 2px; padding: 6px; border: 2px solid #E0E0E0; border-radius: 4px; font-size: 13px; box-sizing: border-box;">
                    </div>
                </div>
            </div>
            
            <!-- Configuration rapide pour tous les mondes -->
            <div style="background: #E8F5E9; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #4CAF50;">
                <h3 style="color: #2E7D32; margin-bottom: 10px; font-size: 16px;">‚ö° Configuration rapide (tous les mondes)</h3>
                <p style="font-size: 12px; color: #666; margin-bottom: 15px;">Configurez tous les mondes en une seule fois</p>
                
                <div class="quick-config-grid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 10px;">
                    <div>
                        <label style="display: block; font-weight: bold; margin-bottom: 5px; font-size: 13px;">Niveaux de difficult√© 1:</label>
                        <input type="number" id="quick-diff1" min="0" value="3" oninput="validateQuickConfig()" style="width: 100%; padding: 6px; border: 2px solid #E0E0E0; border-radius: 4px; font-size: 13px;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: bold; margin-bottom: 5px; font-size: 13px;">Niveaux de difficult√© 2:</label>
                        <input type="number" id="quick-diff2" min="0" value="4" oninput="validateQuickConfig()" style="width: 100%; padding: 6px; border: 2px solid #E0E0E0; border-radius: 4px; font-size: 13px;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: bold; margin-bottom: 5px; font-size: 13px;">Niveaux de difficult√© 3:</label>
                        <input type="number" id="quick-diff3" min="0" value="3" oninput="validateQuickConfig()" style="width: 100%; padding: 6px; border: 2px solid #E0E0E0; border-radius: 4px; font-size: 13px;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: bold; margin-bottom: 5px; font-size: 13px;">Points requis (incr√©mental):</label>
                        <input type="number" id="quick-points" min="0" value="10" style="width: 100%; padding: 6px; border: 2px solid #E0E0E0; border-radius: 4px; font-size: 13px;">
                    </div>
                </div>
                
                <div id="quick-config-error" style="font-size: 12px; color: #f44336; margin-bottom: 10px; display: none;"></div>
                
                <button id="quick-apply-btn" class="btn" onclick="applyQuickConfig()" style="background: #4CAF50; color: white; width: 100%; padding: 10px; font-size: 14px; font-weight: bold;">
                    ‚úì Appliquer √† tous les mondes
                </button>
            </div>
            
            <!-- Configuration par monde -->
            <div style="background: #FFF9C4; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="color: #F57F17; margin-bottom: 10px; font-size: 16px;">Configuration par monde</h3>
                <div id="auto-worlds-config">
                    <!-- Configuration de chaque monde sera g√©n√©r√©e ici -->
                </div>
            </div>
            
            <!-- Bouton de g√©n√©ration en bas -->
            <button id="generate-btn-bottom" class="btn btn-success" onclick="generateWorldsAutomatically()" style="width: 100%; padding: 15px; font-size: 16px; font-weight: bold;">
                üé≤ G√©n√©rer automatiquement les mondes
            </button>
            </div>
        </div>
        </div>
    </div>

    <!-- Popup de confirmation personnalis√©e -->
    <div id="custom-confirm-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10002;"></div>
    <div id="custom-confirm-modal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.5); z-index: 10003; max-width: 500px; text-align: center;">
        <div id="custom-confirm-message" style="font-size: 15px; line-height: 1.6; margin-bottom: 25px; white-space: pre-line;"></div>
        <div style="display: flex; gap: 15px; justify-content: center;">
            <button id="custom-confirm-cancel" class="btn btn-secondary" style="padding: 10px 25px; font-size: 14px; background: #6c757d; color: white;">Annuler</button>
            <button id="custom-confirm-ok" class="btn btn-danger" style="padding: 10px 25px; font-size: 14px; background: #4CAF50; color: white;">Valider</button>
        </div>
    </div>

    <!-- Popup de f√©licitations -->
    <div class="success-popup-overlay" id="success-overlay"></div>
    <div class="success-popup" id="success-popup">
        <div class="emoji">üéâ</div>
        <h2 id="success-title">Bravo !</h2>
        <p id="success-message">Tu as r√©ussi ce niveau !</p>
        <div class="bonus-message" id="bonus-message" style="display: none;"></div>
        <div class="success-popup-buttons">
            <button class="btn-restart" onclick="restartLevel()"><span class="btn-icon">üîÑ</span><span class="btn-text">Recommencer</span></button>
            <button class="btn-next" id="btn-next-level" onclick="nextLevel()"><span class="btn-icon">‚û°Ô∏è</span><span class="btn-text">Niveau suivant</span></button>
        </div>
    </div>

    <!-- Modal pour supprimer un niveau -->
    <div id="delete-modal" class="modal">
        <div class="modal-content">
            <h2>‚ö†Ô∏è Confirmer la suppression</h2>
            <p id="delete-confirm-text">Voulez-vous vraiment supprimer ce niveau ?</p>
            <div class="modal-buttons">
                <button class="btn btn-danger" onclick="confirmDeleteLevel()">Oui, supprimer</button>
                <button class="btn btn-primary" onclick="closeDeleteModal()">Annuler</button>
            </div>
        </div>
    </div>

    <!-- Modal pour sauvegarder en ligne -->
    <div id="save-online-modal" class="online-modal">
        <div class="online-modal-content">
            <span class="modal-close" onclick="closeSaveOnlineModal()">&times;</span>
            <h2>‚òÅÔ∏è Sauvegarder en ligne</h2>
            <p style="color: #666; font-size: 14px; margin-bottom: 20px;">
                Cr√©ez un lien permanent pour partager vos niveaux avec vos √©l√®ves
            </p>
            
            <input type="text" id="save-prof-name" placeholder="Votre nom (ex: dupont)" maxlength="30">
            
            <div style="background: #E8F5E9; padding: 15px; border-radius: 6px; margin: 15px 0; border: 2px solid #4CAF50;">
                <strong style="color: #2E7D32;">üîë Votre code de s√©curit√© :</strong>
                <div style="display: flex; gap: 10px; align-items: center; margin-top: 10px;">
                    <input type="text" id="save-password" readonly style="font-family: monospace; font-size: 18px; font-weight: bold; text-align: center; letter-spacing: 2px; background: white; flex: 1;">
                    <button onclick="copyPassword()" style="padding: 10px 15px; background: #2196F3; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">üìã Copier</button>
                </div>
                <p style="color: #666; font-size: 12px; margin-top: 10px; margin-bottom: 0;">
                    ‚ö†Ô∏è <strong>IMPORTANT :</strong> Notez ce code ! Vous en aurez besoin pour modifier vos niveaux plus tard.
                </p>
            </div>
            
            <div class="captcha-box">
                <span class="captcha-question" id="captcha-question">? + ? =</span>
                <input type="number" id="captcha-answer" class="captcha-input" placeholder="?">
            </div>
            
            <div id="save-message"></div>
            <div id="success-url" class="success-url-box" style="display: none;"></div>
            
            <div class="online-modal-buttons" id="save-modal-buttons">
                <button class="btn-confirm" onclick="confirmSaveOnline()">üíæ Sauvegarder</button>
                <button class="btn-cancel" onclick="closeSaveOnlineModal()">Annuler</button>
            </div>
        </div>
    </div>

    <!-- Modal pour charger des niveaux existants -->
    <div id="load-online-modal" class="online-modal">
        <div class="online-modal-content">
            <span class="modal-close" onclick="closeLoadOnlineModal()">&times;</span>
            <h2>üì• Charger les niveaux</h2>
            <p style="color: #666; font-size: 14px; margin-bottom: 20px;">
                S√©lectionnez un professeur pour charger ses niveaux
            </p>
            
            <input type="text" id="search-prof-name" placeholder="üîç Rechercher un professeur..." oninput="filterProfessors()" style="margin-bottom: 15px;">
            
            <div style="max-height: 300px; overflow-y: auto; border: 2px solid #E0E0E0; border-radius: 6px; background: #FAFAFA; margin-bottom: 15px;">
                <div id="professors-list" style="padding: 10px;">
                    <div style="text-align: center; color: #999; padding: 20px;">
                        Chargement de la liste des professeurs...
                    </div>
                </div>
            </div>
            
            <div class="info-box">
                ‚ÑπÔ∏è Vous pourrez consulter et modifier les niveaux charg√©s. Pour sauvegarder vos modifications, utilisez "Sauvegarder en ligne" avec votre propre nom.
            </div>
            
            <div id="load-message"></div>
            
            <div class="online-modal-buttons">
                <button class="btn-cancel" onclick="closeLoadOnlineModal()">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Modal pour sauvegarder la progression √©l√®ve -->
    <div id="student-save-modal" class="online-modal">
        <div class="online-modal-content">
            <span class="modal-close" onclick="closeStudentSaveModal()">&times;</span>
            <h2>üíæ Votre code de progression</h2>
            <p style="color: #666; font-size: 14px; margin-bottom: 20px;">
                Notez ce code pour reprendre votre progression plus tard
            </p>
            
            <div style="background: #E3F2FD; padding: 15px; border-radius: 6px; margin: 15px 0; border: 2px solid #2196F3;">
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="student-code-display" readonly style="font-family: monospace; font-size: 16px; font-weight: bold; text-align: center; letter-spacing: 1px; background: white; flex: 1; padding: 12px;">
                    <button onclick="copyStudentCode()" style="padding: 10px 15px; background: #2196F3; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; white-space: nowrap;">üìã Copier</button>
                </div>
            </div>
            
            <div class="info-box">
                ‚ÑπÔ∏è Ce code contient votre score, vos niveaux termin√©s et votre progression actuelle.
            </div>
            
            <div class="online-modal-buttons">
                <button class="btn-confirm" onclick="closeStudentSaveModal()" style="width: 100%;">Fermer</button>
            </div>
        </div>
    </div>

    <!-- Modal pour charger la progression √©l√®ve -->
    <div id="student-load-modal" class="online-modal">
        <div class="online-modal-content">
            <span class="modal-close" onclick="closeLoadProgressModal()">&times;</span>
            <h2>üì• Charger ma progression</h2>
            <p style="color: #666; font-size: 14px; margin-bottom: 20px;">
                Entrez votre code de progression pour continuer o√π vous en √©tiez
            </p>
            
            <input type="text" id="student-code-input" placeholder="Collez votre code ici" style="font-family: monospace; text-align: center; letter-spacing: 1px;">
            
            <div id="student-load-message"></div>
            
            <div class="online-modal-buttons">
                <button class="btn-confirm" onclick="loadStudentProgress()">üì• Charger</button>
                <button class="btn-cancel" onclick="closeLoadProgressModal()">Annuler</button>
            </div>
        </div>
    </div>

    <!-- Modal pour supprimer sa sauvegarde en ligne -->
    <div id="delete-online-modal" class="online-modal">
        <div class="online-modal-content">
            <span class="modal-close" onclick="closeDeleteOnlineModal()">&times;</span>
            <h2>üóëÔ∏è Supprimer ma sauvegarde en ligne</h2>
            <p style="color: #666; font-size: 14px; margin-bottom: 20px;">
                ‚ö†Ô∏è <strong>Attention :</strong> Cette action est irr√©versible !
            </p>
            
            <div style="background: #FFE0E0; padding: 15px; border-radius: 6px; margin-bottom: 20px; border: 2px solid #f44336;">
                <p style="margin: 0; color: #d32f2f; font-weight: bold;">
                    Tous vos niveaux sauvegard√©s en ligne seront d√©finitivement supprim√©s.
                </p>
            </div>
            
            <p style="margin-bottom: 10px; font-weight: bold;">Pour confirmer, entrez votre code de s√©curit√© :</p>
            <input type="password" id="delete-password" placeholder="Code de s√©curit√©">
            
            <div id="delete-message"></div>
            
            <div class="online-modal-buttons">
                <button class="btn-confirm" onclick="confirmDeleteOnline()" style="background: #f44336;">üóëÔ∏è Supprimer d√©finitivement</button>
                <button class="btn-cancel" onclick="closeDeleteOnlineModal()">Annuler</button>
            </div>
        </div>
    </div>

    <!-- Import de la biblioth√®que de motifs -->
    <script src="patterns.js"></script>
    
    <!-- Import du filtre de profanit√© -->
    <script src="profanity-filter.js"></script>

    <script>
        // Liste des variables cr√©√©es
        let createdVariables = [];
        let levelToDelete = null; // Pour stocker le niveau √† supprimer
        
        // Module Pinceau
        let selectedPaintColor = 'red'; // Couleur par d√©faut
        let isPainting = false; // Pour savoir si on est en train de peindre
        let paintedCells = {}; // Stockage des cellules peintes : {row-col: 'color'}
        
        // Configuration
        const TEACHER_PASSWORD = 'prof123'; // Changez ce mot de passe
        const GRID_SIZE = 10;
        const MAX_TOTAL_LEVELS = 100; // Limite maximale de niveaux (tous cursus confondus) - MODIFIEZ CETTE VALEUR POUR CHANGER LA LIMITE
        const MAX_LEVELS_PER_INPUT_ALL = 33; // Limite pour cursus "Tous" (sera multipli√© par 3 = 99 max)
        const MAX_LEVELS_PER_INPUT_SINGLE = MAX_TOTAL_LEVELS; // Limite pour cursus individuel
        
        function createNewVariable() {
            document.getElementById('variable-modal').classList.add('active');
            document.getElementById('variable-name').value = '';
            setTimeout(() => document.getElementById('variable-name').focus(), 100);
        }
        
        function closeVariableModal() {
            document.getElementById('variable-modal').classList.remove('active');
        }
        
        function confirmCreateVariable() {
            const varName = document.getElementById('variable-name').value;
            if (varName && varName.trim() !== '') {
                const trimmedName = varName.trim();
                if (!createdVariables.includes(trimmedName)) {
                    createdVariables.push(trimmedName);
                    updateAllVariableSelectors();
                    updateVariableBlocksVisibility();
                    
                    // S√©lectionner automatiquement la nouvelle variable UNIQUEMENT dans les s√©lecteurs de la palette
                    const palette = document.querySelector('.middle-panel');
                    if (palette) {
                        const paletteSelects = palette.querySelectorAll('.var-select');
                        paletteSelects.forEach(select => {
                            select.value = trimmedName;
                        });
                    }
                    
                    // Recharger le menu mobile sur mobile
                    if (window.innerWidth <= 768) {
                        populateMobileBlocks();
                    }
                    
                    showResult(`‚úÖ Variable "${trimmedName}" cr√©√©e avec succ√®s !`, true);
                    closeVariableModal();
                } else {
                    alert('Cette variable existe d√©j√† !');
                }
            }
        }
        
        function closeDeleteModal() {
            document.getElementById('delete-modal').classList.remove('active');
            levelToDelete = null;
        }
        
        function confirmDeleteLevel() {
            if (levelToDelete) {
                const { cursus, index } = levelToDelete;
                cursusData[cursus].splice(index, 1);
                saveToStorage();
                loadTeacherLevels();
                clearProgram();
                clearGrid();
                document.getElementById('teacher-consigne').value = '';
                document.getElementById('teacher-level-select').value = 'new';
                showResult('‚úÖ Niveau supprim√© avec succ√®s !', true);
                closeDeleteModal();
            }
        }
        
        function updateAllVariableSelectors() {
            // Mettre √† jour UNIQUEMENT les s√©lecteurs de variables dans la palette
            const palette = document.querySelector('.middle-panel');
            if (!palette) return;
            
            const paletteSelects = palette.querySelectorAll('.var-select');
            const lastCreatedVar = createdVariables[createdVariables.length - 1];
            
            paletteSelects.forEach(select => {
                const currentValue = select.value;
                select.innerHTML = '<option value="">choisir...</option>';
                
                createdVariables.forEach(varName => {
                    const option = document.createElement('option');
                    option.value = varName;
                    option.textContent = varName;
                    // Garder la s√©lection actuelle si elle existe, sinon s√©lectionner la derni√®re cr√©√©e
                    if (varName === currentValue || (!currentValue && varName === lastCreatedVar)) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
            });
        }
        
        function updateVariableBlocksVisibility() {
            const variableBlocks = document.getElementById('variable-blocks');
            if (variableBlocks) {
                variableBlocks.style.display = createdVariables.length > 0 ? 'block' : 'none';
            }
        }
        
        function dropVariable(ev) {
            ev.preventDefault();
            ev.stopPropagation();
            
            const dataText = ev.dataTransfer.getData('text');
            if (!dataText) {
                return; // Pas de donn√©es, on sort
            }
            
            let data;
            try {
                data = JSON.parse(dataText);
            } catch (e) {
                console.error('Erreur de parsing JSON:', e);
                return;
            }
            
            // V√©rifier que c'est bien un bloc variable
            if (data.type !== 'var-value') {
                return;
            }
            
            const varSlot = ev.currentTarget;
            
            // Cr√©er le bloc variable dans le slot
            varSlot.innerHTML = data.html;
            varSlot.classList.add('filled');
            
            // Retirer les attributs draggable du bloc dans le slot
            const block = varSlot.querySelector('.block');
            if (block) {
                block.removeAttribute('draggable');
                block.removeAttribute('ondragstart');
                block.classList.add('inline-block');
                
                // Sauvegarder l'info sur l'input original avant de le remplacer
                const originalInput = varSlot.querySelector('input');
                let inputHTML = '<input type="number" value="0" onclick="event.stopPropagation()">';
                
                if (originalInput) {
                    const inputType = originalInput.type;
                    const inputValue = originalInput.value;
                    const placeholder = originalInput.placeholder;
                    
                    if (inputType === 'text') {
                        inputHTML = `<input type="text" placeholder="${placeholder || 'valeur'}" onclick="event.stopPropagation()">`;
                    } else {
                        inputHTML = `<input type="number" value="${inputValue || '0'}" onclick="event.stopPropagation()">`;
                    }
                }
                
                // Ajouter un bouton de suppression
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '√ó';
                removeBtn.onclick = function(e) {
                    e.stopPropagation();
                    // Vider le value-slot et restaurer l'input d'origine
                    varSlot.innerHTML = inputHTML;
                    varSlot.classList.remove('filled');
                };
                block.appendChild(removeBtn);
                
                // Mettre √† jour le select avec les variables cr√©√©es
                const select = block.querySelector('.var-select');
                if (select) {
                    // R√©cup√©rer la valeur s√©lectionn√©e dans la palette (si elle existe)
                    const selectedValue = data.selectValues && data.selectValues.length > 0 ? data.selectValues[0] : '';
                    
                    select.innerHTML = '<option value="">choisir...</option>';
                    createdVariables.forEach(varName => {
                        const option = document.createElement('option');
                        option.value = varName;
                        option.textContent = varName;
                        select.appendChild(option);
                    });
                    
                    // Restaurer la valeur qui √©tait s√©lectionn√©e dans la palette
                    if (selectedValue && createdVariables.includes(selectedValue)) {
                        select.value = selectedValue;
                    }
                }
            }
        }
        
        function dropValueOrOperator(ev) {
            ev.preventDefault();
            ev.stopPropagation();
            
            const dataText = ev.dataTransfer.getData('text');
            if (!dataText) {
                return; // Pas de donn√©es, on sort
            }
            
            let data;
            try {
                data = JSON.parse(dataText);
            } catch (e) {
                console.error('Erreur de parsing JSON:', e);
                return;
            }
            
            // Accepter les blocs variable ET op√©rateur
            if (data.type !== 'var-value' && data.type !== 'operator') {
                return;
            }
            
            const valueSlot = ev.currentTarget;
            
            // Cr√©er le bloc dans le slot
            valueSlot.innerHTML = data.html;
            valueSlot.classList.add('filled');
            
            // Retirer les attributs draggable du bloc dans le slot
            const block = valueSlot.querySelector('.block');
            if (block) {
                block.removeAttribute('draggable');
                block.removeAttribute('ondragstart');
                block.classList.add('inline-block');
                
                // Sauvegarder l'info sur le type d'input original avant de le remplacer
                const originalInput = valueSlot.querySelector('input');
                let inputHTML = '<input type="number" value="0" onclick="event.stopPropagation()">';
                
                if (originalInput) {
                    const inputType = originalInput.type;
                    const inputValue = originalInput.value;
                    const placeholder = originalInput.placeholder;
                    
                    if (inputType === 'text') {
                        inputHTML = `<input type="text" placeholder="${placeholder || 'valeur'}" onclick="event.stopPropagation()">`;
                    } else {
                        inputHTML = `<input type="number" value="${inputValue || '0'}" onclick="event.stopPropagation()">`;
                    }
                }
                
                // Ajouter un bouton de suppression
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '√ó';
                removeBtn.onclick = function(e) {
                    e.stopPropagation();
                    // Vider le value-slot et restaurer l'input d'origine
                    valueSlot.innerHTML = inputHTML;
                    valueSlot.classList.remove('filled');
                };
                block.appendChild(removeBtn);
                
                // Si c'est un bloc variable, mettre √† jour le select
                if (data.type === 'var-value') {
                    const select = block.querySelector('.var-select');
                    if (select) {
                        // R√©cup√©rer la valeur s√©lectionn√©e dans la palette (si elle existe)
                        const selectedValue = data.selectValues && data.selectValues.length > 0 ? data.selectValues[0] : '';
                        
                        select.innerHTML = '<option value="">choisir...</option>';
                        createdVariables.forEach(varName => {
                            const option = document.createElement('option');
                            option.value = varName;
                            option.textContent = varName;
                            select.appendChild(option);
                        });
                        
                        // Restaurer la valeur qui √©tait s√©lectionn√©e dans la palette
                        if (selectedValue && createdVariables.includes(selectedValue)) {
                            select.value = selectedValue;
                        }
                    }
                }
                
                // Si c'est un bloc op√©rateur, mettre √† jour les selects des value-slots internes
                if (data.type === 'operator') {
                    const innerValueSlots = block.querySelectorAll('.value-slot');
                    innerValueSlots.forEach(slot => {
                        // Restaurer les valeurs des selects si n√©cessaire
                        if (data.selectValues) {
                            const selects = slot.querySelectorAll('select');
                            selects.forEach((select, index) => {
                                if (data.selectValues[index]) {
                                    select.value = data.selectValues[index];
                                }
                            });
                        }
                    });
                }
                
                // IMPORTANT : Appliquer la validation sur le bloc ins√©r√©
                setupNumericInputValidation(block);
                
                // √âGALEMENT : R√©initialiser la validation sur le bloc parent
                const parentProgramBlock = valueSlot.closest('.program-block');
                if (parentProgramBlock) {
                    setupNumericInputValidation(parentProgramBlock);
                }
            }
        }
        
        // √âtat global
        let currentMode = 'student';
        let currentCursus = '5eme';
        let currentLevelIndex = 0;
        let score = 0;
        let grid = [];
        let turtle = { x: 5, y: 9, direction: 0, color: 'black', drawMode: false };
        let variables = {};
        let programBlocks = [];

        // Suivi des niveaux compl√©t√©s par l'√©l√®ve
        // Structure: { '5eme': { 0: {completed: true, optimal: true}, 1: {completed: true, optimal: false}, ... }, ... }
        let completedLevels = {
            '5eme': {},
            '4eme': {},
            '3eme': {}
        };

        // Structure des niveaux par cursus
        let cursusData = {
            '5eme': { worlds: 1, levelsPerWorld: 10, pointsPerWorld: [0], levels: {} },
            '4eme': { worlds: 1, levelsPerWorld: 10, pointsPerWorld: [0], levels: {} },
            '3eme': { worlds: 1, levelsPerWorld: 10, pointsPerWorld: [0], levels: {} }
        };

        // Initialisation
        // ===== SAUVEGARDE PROGRESSION √âL√àVE =====
        
        // Cl√© secr√®te pour l'encodage
        const SECRET_KEY = 42;
        
        // Caract√®res base40 : 0-9, A-Z, !, ?, +, =
        const BASE40_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ!?+=';
        
        // G√©n√©rer un code de progression pour l'√©l√®ve
        function generateStudentCode() {
            const urlParams = new URLSearchParams(window.location.search);
            const profName = urlParams.get('prof');
            
            if (!profName) {
                alert('‚ùå Impossible de g√©n√©rer un code : aucun professeur d√©tect√©');
                return;
            }
            
            // 1. Cursus (0=5eme, 1=4eme, 2=3eme)
            const cursusNum = currentCursus === '5eme' ? 0 : currentCursus === '4eme' ? 1 : 2;
            
            // 2. Collecter tous les niveaux compl√©t√©s avec leurs coches
            const levels = [];
            for (let key in completedLevels) {
                const parts = key.split('-');
                if (parts[0] === currentCursus) {
                    const levelNum = parseInt(parts[1]);
                    const points = completedLevels[key];
                    levels.push({ level: levelNum, points: points });
                }
            }
            
            // Trier par num√©ro de niveau
            levels.sort((a, b) => a.level - b.level);
            
            if (levels.length === 0) {
                alert('‚ùå Aucun niveau compl√©t√© √† sauvegarder');
                return;
            }
            
            // 3. Encoder format: cursus:niveau1*coches1|niveau2*coches2|...
            let dataStr = cursusNum + ':';
            levels.forEach((l, i) => {
                dataStr += l.level + '*' + l.points;
                if (i < levels.length - 1) dataStr += '|';
            });
            
            // Convertir en bytes et encoder avec XOR
            let bytes = [];
            for (let i = 0; i < dataStr.length; i++) {
                bytes.push(dataStr.charCodeAt(i) ^ SECRET_KEY);
            }
            
            // Convertir bytes en nombre (BigInt)
            let bigNum = 0n;
            for (let byte of bytes) {
                bigNum = bigNum * 256n + BigInt(byte);
            }
            
            // Convertir en base40
            let code = '';
            if (bigNum === 0n) {
                code = '0';
            } else {
                while (bigNum > 0n) {
                    code = BASE40_CHARS[Number(bigNum % 40n)] + code;
                    bigNum = bigNum / 40n;
                }
            }
            
            // Ajouter checksum
            let checksum = 0;
            for (let c of code) {
                checksum = (checksum + BASE40_CHARS.indexOf(c)) % 40;
            }
            code += BASE40_CHARS[checksum];
            
            // Afficher
            document.getElementById('student-code-display').value = code;
            document.getElementById('student-save-modal').classList.add('active');
        }
        
        function closeStudentSaveModal() {
            document.getElementById('student-save-modal').classList.remove('active');
        }
        
        function copyStudentCode() {
            const codeInput = document.getElementById('student-code-display');
            codeInput.select();
            document.execCommand('copy');
            
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = '‚úÖ Copi√© !';
            button.style.background = '#4CAF50';
            setTimeout(() => {
                button.textContent = originalText;
                button.style.background = '#2196F3';
            }, 2000);
        }
        
        function openLoadProgressModal() {
            document.getElementById('student-load-modal').classList.add('active');
            document.getElementById('student-code-input').value = '';
            document.getElementById('student-load-message').innerHTML = '';
        }
        
        function closeLoadProgressModal() {
            document.getElementById('student-load-modal').classList.remove('active');
        }
        
        function loadStudentProgress() {
            let code = document.getElementById('student-code-input').value.trim().toUpperCase();
            const messageDiv = document.getElementById('student-load-message');
            
            if (!code) {
                messageDiv.innerHTML = '<div class="error-message">‚ö†Ô∏è Veuillez entrer un code</div>';
                return;
            }
            
            // Filtrer pour garder uniquement les caract√®res base40
            code = code.replace(/[^0-9A-Z!?+=]/g, '');
            
            if (code.length < 2) {
                messageDiv.innerHTML = '<div class="error-message">‚ùå Code trop court</div>';
                return;
            }
            
            try {
                // S√©parer checksum
                const mainCode = code.slice(0, -1);
                const checksumProvided = BASE40_CHARS.indexOf(code.slice(-1));
                
                // V√©rifier checksum
                let checksumCalculated = 0;
                for (let c of mainCode) {
                    checksumCalculated = (checksumCalculated + BASE40_CHARS.indexOf(c)) % 40;
                }
                
                if (checksumCalculated !== checksumProvided) {
                    messageDiv.innerHTML = '<div class="error-message">‚ùå Code invalide (checksum incorrect)</div>';
                    return;
                }
                
                // D√©coder de base40
                let bigNum = 0n;
                for (let c of mainCode) {
                    const idx = BASE40_CHARS.indexOf(c);
                    if (idx === -1) throw new Error('Caract√®re invalide');
                    bigNum = bigNum * 40n + BigInt(idx);
                }
                
                // Convertir en bytes
                let bytes = [];
                while (bigNum > 0n) {
                    bytes.unshift(Number(bigNum % 256n));
                    bigNum = bigNum / 256n;
                }
                
                // D√©coder XOR et reconstituer string
                let dataStr = '';
                for (let byte of bytes) {
                    dataStr += String.fromCharCode(byte ^ SECRET_KEY);
                }
                
                // Parser : cursus:niveau1*coches1|niveau2*coches2|...
                const parts = dataStr.split(':');
                if (parts.length !== 2) throw new Error('Format invalide');
                
                const cursusNum = parseInt(parts[0]);
                const cursusMap = ['5eme', '4eme', '3eme'];
                const decodedCursus = cursusMap[cursusNum];
                
                if (!decodedCursus) throw new Error('Cursus invalide');
                
                // Parser les niveaux
                const levelParts = parts[1].split('|');
                const decodedCompleted = {};
                let totalScore = 0;
                
                for (let lp of levelParts) {
                    const [level, points] = lp.split('*').map(n => parseInt(n));
                    if (isNaN(level) || isNaN(points)) throw new Error('Donn√©es invalides');
                    
                    const key = `${decodedCursus}-${level}`;
                    decodedCompleted[key] = points;
                    totalScore += points;
                }
                
                // Charger
                score = totalScore;
                completedLevels = decodedCompleted;
                currentCursus = decodedCursus;
                
                saveToStorage();
                document.getElementById('cursus-select').value = currentCursus;
                document.getElementById('score').textContent = score;
                loadCursusLevels();
                
                messageDiv.innerHTML = '<div class="info-box" style="background: #E8F5E9; border-color: #4CAF50; color: #2E7D32;">‚úÖ Progression charg√©e avec succ√®s !</div>';
                
                setTimeout(() => closeLoadProgressModal(), 1500);
                
            } catch (error) {
                console.error('Erreur de d√©codage:', error);
                messageDiv.innerHTML = '<div class="error-message">‚ùå Code invalide. V√©rifiez le code complet.</div>';
            }
        }
        
        function init() {
            createGrid();
            loadFromStorage();
            
            // Migrer l'ancien format si n√©cessaire
            for (let cursus in cursusData) {
                if (Array.isArray(cursusData[cursus])) {
                    // Ancien format - convertir
                    const oldLevels = cursusData[cursus];
                    cursusData[cursus] = {
                        worlds: 1,
                        levelsPerWorld: 10,
                        pointsPerWorld: [0],
                        levels: {}
                    };
                    oldLevels.forEach((level, index) => {
                        cursusData[cursus].levels[(index + 1).toString()] = level;
                    });
                }
                // S'assurer que la structure est compl√®te
                if (!cursusData[cursus].worlds) cursusData[cursus].worlds = 1;
                if (!cursusData[cursus].levelsPerWorld) cursusData[cursus].levelsPerWorld = 10;
                if (!cursusData[cursus].pointsPerWorld) cursusData[cursus].pointsPerWorld = [0];
                if (!cursusData[cursus].levels) cursusData[cursus].levels = {};
            }
            saveToStorage();
            
            loadCursusLevels();
            resetTurtle();
            setupDeleteZone();
        }

        // Configuration de la zone de suppression (palette)
        function setupDeleteZone() {
            const palette = document.querySelector('.middle-panel');
            if (!palette) return;
            
            palette.addEventListener('dragover', function(e) {
                // V√©rifier si c'est un bloc du programme qui est d√©plac√©
                const dragging = document.querySelector('.dragging');
                if (dragging) {
                    e.preventDefault();
                    palette.classList.add('delete-zone');
                }
            });
            
            palette.addEventListener('dragleave', function(e) {
                // Ne retirer la classe que si on quitte vraiment la palette
                if (e.target === palette || !palette.contains(e.relatedTarget)) {
                    palette.classList.remove('delete-zone');
                }
            });
            
            palette.addEventListener('drop', function(e) {
                e.preventDefault();
                const dragging = document.querySelector('.dragging');
                if (dragging) {
                    // V√©rifier si le bloc est dans une zone imbriqu√©e
                    const parentNested = dragging.parentElement;
                    
                    // Supprimer le bloc
                    dragging.remove();
                    
                    // Si c'√©tait dans une zone imbriqu√©e, v√©rifier si elle est maintenant vide
                    if (parentNested && parentNested.classList.contains('nested-blocks')) {
                        if (parentNested.children.length === 0) {
                            parentNested.classList.add('empty');
                        }
                    }
                    
                    palette.classList.remove('delete-zone');
                }
            });
        }

        // Cr√©ation de la grille
        function createGrid() {
            // Cr√©er les trois grilles au d√©marrage
            createGridElement('student-grid');
            createGridElement('teacher-grid');
            createGridElement('target-grid');
        }
        
        function createGridElement(gridId) {
            const gridElement = document.getElementById(gridId);
            if (!gridElement) return;
            
            gridElement.innerHTML = '';
            
            // Sur mobile, utiliser 1fr pour que les cellules s'adaptent
            // Sur desktop, utiliser 25px fixe
            if (window.innerWidth <= 768) {
                gridElement.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
            } else {
                gridElement.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 25px)`;
            }
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.dataset.gridId = gridId;
                    gridElement.appendChild(cell);
                }
            }
            
            // Initialiser la grille globale seulement pour student-grid
            if (gridId === 'student-grid') {
                grid = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    grid[y] = [];
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const cells = gridElement.querySelectorAll('.grid-cell');
                        const cell = cells[y * GRID_SIZE + x];
                        grid[y][x] = { element: cell, color: 'white' };
                    }
                }
            }
        }
        
        function getActiveGrid() {
            const gridId = currentMode === 'student' ? 'student-grid' : 'teacher-grid';
            const gridElement = document.getElementById(gridId);
            
            // Reconstruire l'objet grid pour la grille active
            grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                grid[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cells = gridElement.querySelectorAll('.grid-cell');
                    const cell = cells[y * GRID_SIZE + x];
                    grid[y][x] = { 
                        element: cell, 
                        color: cell.style.background ? getColorNameFromRGB(cell.style.background) : 'white'
                    };
                }
            }
            return grid;
        }
        
        function getColorNameFromRGB(rgb) {
            const colorMap = {
                'rgb(220, 53, 69)': 'red',
                '#dc3545': 'red',
                'rgb(255, 193, 7)': 'yellow',
                '#ffc107': 'yellow',
                'rgb(40, 167, 69)': 'green',
                '#28a745': 'green',
                'rgb(0, 123, 255)': 'blue',
                '#007bff': 'blue',
                'rgb(52, 58, 64)': 'black',
                '#343a40': 'black',
                'white': 'white',
                'rgb(255, 255, 255)': 'white',
                '#ffffff': 'white',
                '': 'white'
            };
            return colorMap[rgb] || 'white';
        }

        // Gestion du mode
        function switchMode(mode) {
            // Ne rien faire si on est d√©j√† dans le mode s√©lectionn√©
            if (currentMode === mode) {
                return;
            }
            
            if (mode === 'teacher') {
                const modal = document.getElementById('password-modal');
                const passwordInput = document.getElementById('teacher-password');
                
                // Vider l'input au cas o√π il contiendrait quelque chose
                passwordInput.value = '';
                
                modal.classList.add('active');
                
                // Focus imm√©diat et apr√®s la transition pour plus de fiabilit√©
                passwordInput.focus();
                setTimeout(() => {
                    passwordInput.focus();
                }, 0);
                setTimeout(() => {
                    passwordInput.focus();
                }, 50);
            } else {
                currentMode = 'student';
                updateModeDisplay();
            }
        }

        function checkPassword() {
            const password = document.getElementById('teacher-password').value;
            if (password === TEACHER_PASSWORD) {
                currentMode = 'teacher';
                updateModeDisplay();
                closePasswordModal();
                
                // Remonter en haut de la page sur mobile
                if (window.innerWidth <= 768) {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
                
                loadTeacherLevels();
                // Nettoyer les vieux fichiers √† l'ouverture du mode professeur
                cleanupOldLevels();
            } else if (password.length > 0) {
                // Ne montrer l'erreur que si un mot de passe a √©t√© entr√©
                document.getElementById('teacher-password').style.borderColor = '#ff0000';
            }
        }
        
        function checkPasswordAuto() {
            const password = document.getElementById('teacher-password').value;
            if (password === TEACHER_PASSWORD) {
                currentMode = 'teacher';
                updateModeDisplay();
                closePasswordModal();
                
                // Remonter en haut de la page sur mobile
                if (window.innerWidth <= 768) {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
                
                loadTeacherLevels();
                // Nettoyer les vieux fichiers √† l'ouverture du mode professeur
                cleanupOldLevels();
            } else {
                // R√©initialiser la bordure rouge pendant la saisie
                document.getElementById('teacher-password').style.borderColor = '#E0E0E0';
            }
        }
        
        // Nettoyer les fichiers inactifs (> 1 an)
        async function cleanupOldLevels() {
            try {
                const response = await fetch('api.php?action=cleanup');
                const result = await response.json();
                if (result.success && result.cleaned > 0) {
                    console.log(`‚úì Nettoyage automatique : ${result.cleaned} fichier(s) inactif(s) supprim√©(s)`);
                }
            } catch (error) {
                console.error('Erreur lors du nettoyage automatique:', error);
            }
        }

        function closePasswordModal() {
            document.getElementById('password-modal').classList.remove('active');
            document.getElementById('teacher-password').value = '';
            document.getElementById('teacher-password').style.borderColor = '#E0E0E0';
        }
        
        // ===== GESTION DES NIVEAUX ET MONDES =====
        let tempWorldsConfig = null;
        let tempLevelsData = null; // Stocker les donn√©es de chaque niveau index√©es par position (1, 2, 3...)
        
        function openLevelManagerModal() {
            // IMPORTANT : Sauvegarder le niveau en cours avant d'ouvrir la modal
            if (lastLoadedLevel && lastLoadedLevel !== 'new') {
                const programBlocks = document.getElementById('program-blocks');
                const blocks = programBlocks.querySelectorAll(':scope > .program-block');
                
                if (blocks.length > 0) {
                    const cursus = document.getElementById('teacher-cursus-select').value;
                    
                    const savedBlocks = [];
                    blocks.forEach(block => {
                        const blockData = extractBlockData(block);
                        savedBlocks.push(blockData);
                    });
                    
                    const gridState = getGridState();
                    const paintedCellsData = getPaintedCellsData();
                    
                    const levelData = {
                        blocks: savedBlocks,
                        blockCount: countTotalBlocks(blocks),
                        gridState: gridState,
                        paintedCells: paintedCellsData
                    };
                    
                    if (createdVariables.length > 0) {
                        levelData.variables = {
                            createdVariables: [...createdVariables],
                            variableValues: { ...variables }
                        };
                    }
                    
                    cursusData[cursus].levels[lastLoadedLevel] = levelData;
                }
            }
            
            const modal = document.getElementById('level-manager-modal');
            const cursus = document.getElementById('teacher-cursus-select').value;
            
            // Synchroniser le select de cursus dans la modal
            document.getElementById('modal-cursus-select').value = cursus;
            
            // Charger la configuration actuelle
            if (!cursusData[cursus]) {
                cursusData[cursus] = { worlds: 1, levelsPerWorld: 10, pointsPerWorld: [0], levels: {} };
            }
            
            // Initialiser les variables temporaires
            tempWorldsConfig = {
                worlds: cursusData[cursus].worlds || 1,
                levelsPerWorld: cursusData[cursus].levelsPerWorld || 10,
                pointsPerWorld: [...(cursusData[cursus].pointsPerWorld || [0])]
            };
            
            // Copier les donn√©es des niveaux (index√©es par position)
            tempLevelsData = {};
            Object.keys(cursusData[cursus].levels || {}).forEach(levelNum => {
                tempLevelsData[levelNum] = { ...cursusData[cursus].levels[levelNum] };
            });
            
            // Afficher la configuration
            document.getElementById('num-worlds').value = tempWorldsConfig.worlds;
            document.getElementById('levels-per-world').value = tempWorldsConfig.levelsPerWorld;
            
            // G√©n√©rer l'interface (sans sauvegarder, on charge juste)
            updateWorldsConfig(false);
            updateLevelsList();
            
            modal.classList.add('active');
            
            // Ajouter la s√©lection automatique sur tous les inputs number de la modal
            setTimeout(() => {
                const numberInputs = modal.querySelectorAll('input[type="number"]');
                numberInputs.forEach(input => {
                    input.addEventListener('focus', function() {
                        this.select();
                    });
                });
            }, 100);
        }
        
        function switchModalCursus() {
            const newCursus = document.getElementById('modal-cursus-select').value;
            const oldCursus = document.getElementById('teacher-cursus-select').value;
            
            // Ne rien faire si on s√©lectionne le m√™me cursus
            if (oldCursus === newCursus) {
                return;
            }
            
            // Sauvegarder les changements du cursus actuel avant de changer
            console.log(`Changement de cursus: ${oldCursus} ‚Üí ${newCursus}`);
            
            // Sauvegarder l'ancien cursus
            cursusData[oldCursus].worlds = tempWorldsConfig.worlds;
            cursusData[oldCursus].levelsPerWorld = tempWorldsConfig.levelsPerWorld;
            cursusData[oldCursus].pointsPerWorld = [...tempWorldsConfig.pointsPerWorld];
            cursusData[oldCursus].levels = { ...tempLevelsData };
            saveToStorage();
            
            // Changer le cursus dans le select principal
            document.getElementById('teacher-cursus-select').value = newCursus;
            
            // Charger les donn√©es du nouveau cursus
            const cursus = newCursus;
            
            if (!cursusData[cursus]) {
                cursusData[cursus] = { worlds: 1, levelsPerWorld: 10, pointsPerWorld: [0], levels: {} };
            }
            
            // R√©initialiser les variables temporaires avec les donn√©es du nouveau cursus
            tempWorldsConfig = {
                worlds: cursusData[cursus].worlds || 1,
                levelsPerWorld: cursusData[cursus].levelsPerWorld || 10,
                pointsPerWorld: [...(cursusData[cursus].pointsPerWorld || [0])]
            };
            
            tempLevelsData = {};
            Object.keys(cursusData[cursus].levels || {}).forEach(levelNum => {
                tempLevelsData[levelNum] = { ...cursusData[cursus].levels[levelNum] };
            });
            
            console.log(`Nouveau cursus charg√©: ${cursus}`, {
                worlds: tempWorldsConfig.worlds,
                levelsPerWorld: tempWorldsConfig.levelsPerWorld,
                niveaux: Object.keys(tempLevelsData).length
            });
            
            // Afficher la configuration du nouveau cursus
            document.getElementById('num-worlds').value = tempWorldsConfig.worlds;
            document.getElementById('levels-per-world').value = tempWorldsConfig.levelsPerWorld;
            
            // R√©g√©n√©rer l'interface avec les donn√©es du nouveau cursus (sans sauvegarder, on charge juste)
            updateWorldsConfig(false);
            updateLevelsList();
            
            // Recharger aussi l'interface principale
            loadTeacherLevels();
        }
        
        function updateWorldsConfig(autoSave = true) {
            const numWorlds = parseInt(document.getElementById('num-worlds').value);
            const levelsPerWorld = parseInt(document.getElementById('levels-per-world').value);
            const levelsPerWorldInput = document.getElementById('levels-per-world');
            
            // Sauvegarder les anciennes valeurs AVANT toute modification
            const oldLevelsPerWorld = tempWorldsConfig.levelsPerWorld;
            const oldNumWorlds = tempWorldsConfig.worlds;
            
            // Obtenir les niveaux existants
            const existingLevels = Object.keys(tempLevelsData).map(n => parseInt(n)).sort((a, b) => a - b);
            const maxExistingLevel = existingLevels.length > 0 ? Math.max(...existingLevels) : 0;
            
            console.log('=== updateWorldsConfig ===');
            console.log('numWorlds:', numWorlds, 'oldNumWorlds:', oldNumWorlds);
            console.log('levelsPerWorld:', levelsPerWorld, 'oldLevelsPerWorld:', oldLevelsPerWorld);
            console.log('existingLevels:', existingLevels);
            console.log('maxExistingLevel:', maxExistingLevel);
            
            // V√âRIFICATION 1 : Si on r√©duit les niveaux par monde ou le nombre de mondes
            if (levelsPerWorld < oldLevelsPerWorld || numWorlds < oldNumWorlds) {
                const newTotalSlots = numWorlds * levelsPerWorld;
                
                console.log('R√©duction d√©tect√©e');
                console.log('newTotalSlots:', newTotalSlots);
                console.log('Nombre de niveaux existants:', existingLevels.length);
                
                // V√©rifier si on a assez de place pour tous les niveaux existants
                if (existingLevels.length > newTotalSlots) {
                    // Pas assez de place, bloquer
                    levelsPerWorldInput.style.border = '2px solid #FF0000';
                    levelsPerWorldInput.style.background = '#FFE0E0';
                    alert(`‚ùå Impossible de r√©duire : ${existingLevels.length} niveaux existants mais seulement ${newTotalSlots} emplacements disponibles.\n\nSupprimez d'abord ${existingLevels.length - newTotalSlots} niveau(x) avec la poubelle üóëÔ∏è`);
                    document.getElementById('levels-per-world').value = oldLevelsPerWorld;
                    document.getElementById('num-worlds').value = oldNumWorlds;
                    return;
                }
                
                // Assez de place : r√©organiser les niveaux pour combler les trous
                if (maxExistingLevel > newTotalSlots) {
                    console.log('R√©organisation des niveaux n√©cessaire');
                    
                    // Cr√©er un nouveau mapping : ancien num√©ro -> nouveau num√©ro
                    const newTempLevelsData = {};
                    existingLevels.forEach((oldNum, index) => {
                        const newNum = index + 1; // Num√©rotation cons√©cutive √† partir de 1
                        newTempLevelsData[newNum.toString()] = tempLevelsData[oldNum.toString()];
                        console.log(`Niveau ${oldNum} -> ${newNum}`);
                    });
                    
                    // Remplacer tempLevelsData
                    tempLevelsData = newTempLevelsData;
                    
                    alert(`‚ÑπÔ∏è Les niveaux ont √©t√© r√©organis√©s pour combler les emplacements vides.`);
                }
                
                // R√©initialiser le style
                levelsPerWorldInput.style.border = '2px solid #E0E0E0';
                levelsPerWorldInput.style.background = 'white';
            } else {
                // R√©initialiser le style
                levelsPerWorldInput.style.border = '2px solid #E0E0E0';
                levelsPerWorldInput.style.background = 'white';
            }
            
            // V√âRIFICATION 2 : Si on r√©duit le nombre de mondes, ajuster levelsPerWorld pour garder tous les niveaux
            if (numWorlds < oldNumWorlds && existingLevels.length > 0) {
                // Calculer le nombre minimum de niveaux par monde n√©cessaire
                const minLevelsPerWorld = Math.ceil(existingLevels.length / numWorlds);
                
                if (levelsPerWorld < minLevelsPerWorld) {
                    // Ajuster automatiquement levelsPerWorld
                    document.getElementById('levels-per-world').value = minLevelsPerWorld;
                    alert(`‚ÑπÔ∏è Le nombre de niveaux par monde a √©t√© ajust√© √† ${minLevelsPerWorld} pour conserver tous les niveaux existants.`);
                    // Rappeler la fonction avec les nouvelles valeurs
                    updateWorldsConfig(autoSave);
                    return;
                }
            }
            
            tempWorldsConfig.worlds = numWorlds;
            tempWorldsConfig.levelsPerWorld = levelsPerWorld;
            
            // Ajuster le tableau des points
            while (tempWorldsConfig.pointsPerWorld.length < numWorlds) {
                tempWorldsConfig.pointsPerWorld.push(0);
            }
            tempWorldsConfig.pointsPerWorld = tempWorldsConfig.pointsPerWorld.slice(0, numWorlds);
            
            // G√©n√©rer l'interface
            const worldsConfigDiv = document.getElementById('worlds-config');
            worldsConfigDiv.innerHTML = '';
            
            for (let i = 0; i < numWorlds; i++) {
                const worldDiv = document.createElement('div');
                worldDiv.className = 'world-config-item';
                worldDiv.style.cssText = 'margin-bottom: 8px; padding: 8px 12px; background: white; border-radius: 4px; display: flex; align-items: center; justify-content: space-between;';
                
                const startLevel = i * levelsPerWorld + 1;
                const endLevel = (i + 1) * levelsPerWorld;
                
                // Partie gauche : Nom du monde
                const worldLabel = document.createElement('span');
                worldLabel.style.cssText = 'font-weight: bold; font-size: 12px; min-width: 180px;';
                worldLabel.textContent = `Monde ${i + 1} (Niveaux ${startLevel}-${endLevel}):`;
                
                // Partie droite : Points requis
                const pointsDiv = document.createElement('div');
                pointsDiv.style.cssText = 'display: flex; align-items: center; gap: 10px;';
                
                const pointsLabel = document.createElement('span');
                pointsLabel.style.cssText = 'font-size: 12px;';
                pointsLabel.textContent = i === 0 ? 'Points requis:' : 'Points pour d√©bloquer:';
                
                const pointsInput = document.createElement('input');
                pointsInput.type = 'number';
                pointsInput.min = '0';
                pointsInput.max = '10000';
                pointsInput.value = tempWorldsConfig.pointsPerWorld[i] || 0;
                pointsInput.style.cssText = 'width: 80px; padding: 4px; border: 2px solid #E0E0E0; border-radius: 4px; font-size: 12px;';
                pointsInput.disabled = i === 0;
                
                // Ajouter la s√©lection automatique au focus
                pointsInput.addEventListener('focus', function() {
                    this.select();
                });
                
                pointsInput.onchange = () => {
                    const newPoints = parseInt(pointsInput.value) || 0;
                    
                    // V√©rifier que les points sont atteignables (seulement pour monde 2+)
                    if (i > 0) {
                        // Calculer le maximum de points disponibles dans les mondes pr√©c√©dents
                        const previousLevels = i * levelsPerWorld;
                        const maxPointsAvailable = previousLevels * 2; // 2 points max par niveau
                        
                        if (newPoints > maxPointsAvailable) {
                            pointsInput.style.border = '2px solid #FF0000';
                            pointsInput.style.background = '#FFE0E0';
                            alert(`‚ùå Impossible !\n\nPour d√©bloquer le Monde ${i + 1}, vous demandez ${newPoints} points.\n\nMais les ${previousLevels} niveaux des mondes pr√©c√©dents donnent au maximum ${maxPointsAvailable} points (${previousLevels} √ó 2).\n\nLe maximum atteignable est ${maxPointsAvailable} points.`);
                            pointsInput.value = tempWorldsConfig.pointsPerWorld[i];
                            return;
                        }
                        
                        // R√©initialiser le style si OK
                        pointsInput.style.border = '2px solid #E0E0E0';
                        pointsInput.style.background = 'white';
                    }
                    
                    tempWorldsConfig.pointsPerWorld[i] = newPoints;
                    // Sauvegarder automatiquement
                    autoSaveLevelManagerChanges();
                };
                
                pointsDiv.appendChild(pointsLabel);
                pointsDiv.appendChild(pointsInput);
                
                if (i === 0) {
                    const note = document.createElement('span');
                    note.style.cssText = 'font-size: 11px; color: #999;';
                    note.textContent = '(toujours accessible)';
                    pointsDiv.appendChild(note);
                }
                
                worldDiv.appendChild(worldLabel);
                worldDiv.appendChild(pointsDiv);
                worldsConfigDiv.appendChild(worldDiv);
            }
            
            // Mettre √† jour la liste des niveaux si elle existe
            updateLevelsList();
            
            // Sauvegarder automatiquement seulement si demand√©
            if (autoSave) {
                autoSaveLevelManagerChanges();
            }
        }
        
        function updateLevelsList() {
            const levelsListDiv = document.getElementById('levels-list');
            levelsListDiv.innerHTML = '';
            
            const numWorlds = tempWorldsConfig.worlds;
            const levelsPerWorld = tempWorldsConfig.levelsPerWorld;
            const totalLevels = numWorlds * levelsPerWorld;
            
            // Cr√©er les sections par monde
            for (let worldIdx = 0; worldIdx < numWorlds; worldIdx++) {
                const worldSection = document.createElement('div');
                worldSection.style.cssText = 'margin-bottom: 15px;';
                
                const worldHeader = document.createElement('div');
                worldHeader.style.cssText = 'background: #1976D2; color: white; padding: 8px 12px; border-radius: 4px; font-weight: bold; font-size: 14px; margin-bottom: 8px;';
                worldHeader.textContent = `üåç Monde ${worldIdx + 1}`;
                worldSection.appendChild(worldHeader);
                
                // Cr√©er les niveaux de ce monde
                for (let levelInWorld = 0; levelInWorld < levelsPerWorld; levelInWorld++) {
                    const levelNum = worldIdx * levelsPerWorld + levelInWorld + 1;
                    const levelData = tempLevelsData[levelNum.toString()];
                    
                    const levelDiv = document.createElement('div');
                    levelDiv.className = 'level-item';
                    levelDiv.draggable = levelData != null; // Seulement si le niveau existe
                    levelDiv.style.cssText = `
                        background: ${levelData ? 'white' : '#f5f5f5'}; 
                        padding: 10px; 
                        margin-bottom: 5px; 
                        border-radius: 4px; 
                        border: 2px solid #E0E0E0; 
                        display: flex; 
                        align-items: center; 
                        gap: 10px;
                        cursor: ${levelData ? 'move' : 'default'};
                        opacity: ${levelData ? '1' : '0.6'};
                    `;
                    levelDiv.dataset.levelNum = levelNum;
                    
                    // Num√©ro du niveau
                    const levelNumber = document.createElement('div');
                    levelNumber.style.cssText = 'font-weight: bold; font-size: 13px; min-width: 80px;';
                    levelNumber.textContent = `Niveau ${levelNum}`;
                    levelDiv.appendChild(levelNumber);
                    
                    if (levelData) {
                        // Aper√ßu du motif (miniature de la grille)
                        const preview = createLevelPreview(levelData);
                        levelDiv.appendChild(preview);
                        
                        // Nombre de blocs optimaux
                        const blocksInfo = document.createElement('div');
                        blocksInfo.style.cssText = 'font-size: 12px; color: #666; min-width: 60px; flex-shrink: 0;';
                        blocksInfo.textContent = `${levelData.blockCount} blocs`;
                        levelDiv.appendChild(blocksInfo);
                        
                        // Bouton supprimer
                        const deleteBtn = document.createElement('button');
                        deleteBtn.textContent = 'üóëÔ∏è';
                        deleteBtn.className = 'level-delete-btn';
                        deleteBtn.style.cssText = 'background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 14px; margin-left: auto; flex-shrink: 0;';
                        deleteBtn.onclick = (e) => {
                            e.stopPropagation();
                            deleteLevelFromList(levelNum);
                        };
                        levelDiv.appendChild(deleteBtn);
                        
                        // Drag & Drop handlers
                        levelDiv.ondragstart = (e) => {
                            e.dataTransfer.effectAllowed = 'move';
                            e.dataTransfer.setData('text/plain', levelNum.toString());
                            levelDiv.style.opacity = '0.5';
                        };
                        
                        levelDiv.ondragend = (e) => {
                            levelDiv.style.opacity = '1';
                        };
                    } else {
                        // Niveau vide
                        const emptyText = document.createElement('div');
                        emptyText.style.cssText = 'font-size: 12px; color: #999; font-style: italic;';
                        emptyText.textContent = 'Niveau vide';
                        levelDiv.appendChild(emptyText);
                    }
                    
                    // Handler de drop pour tous les niveaux
                    levelDiv.ondragover = (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        levelDiv.style.borderColor = '#4CAF50';
                        levelDiv.style.background = '#E8F5E9';
                    };
                    
                    levelDiv.ondragleave = (e) => {
                        levelDiv.style.borderColor = '#E0E0E0';
                        levelDiv.style.background = levelData ? 'white' : '#f5f5f5';
                    };
                    
                    levelDiv.ondrop = (e) => {
                        e.preventDefault();
                        levelDiv.style.borderColor = '#E0E0E0';
                        levelDiv.style.background = levelData ? 'white' : '#f5f5f5';
                        
                        const draggedLevelNum = e.dataTransfer.getData('text/plain');
                        const targetLevelNum = levelNum.toString();
                        
                        if (draggedLevelNum !== targetLevelNum) {
                            // √âchanger le contenu des deux niveaux
                            const temp = tempLevelsData[draggedLevelNum];
                            tempLevelsData[draggedLevelNum] = tempLevelsData[targetLevelNum];
                            tempLevelsData[targetLevelNum] = temp;
                            
                            updateLevelsList();
                            
                            // Sauvegarder automatiquement
                            autoSaveLevelManagerChanges();
                        }
                    };
                    
                    worldSection.appendChild(levelDiv);
                }
                
                levelsListDiv.appendChild(worldSection);
            }
        }
        
        function createLevelPreview(levelData) {
            const previewContainer = document.createElement('div');
            previewContainer.style.cssText = 'display: inline-block; border: 1px solid #ccc; background: white;';
            
            // Cr√©er une mini grille 10x10
            const gridSize = 10;
            const cellSize = 8; // pixels
            
            const canvas = document.createElement('canvas');
            canvas.width = gridSize * cellSize;
            canvas.height = gridSize * cellSize;
            canvas.style.cssText = 'display: block;';
            
            const ctx = canvas.getContext('2d');
            
            // Fond blanc
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner la grille
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(canvas.width, i * cellSize);
                ctx.stroke();
            }
            
            // Dessiner les cellules peintes
            const colorMap = {
                'red': '#dc3545',
                'yellow': '#ffc107',
                'green': '#28a745',
                'blue': '#007bff',
                'black': '#343a40'
            };
            
            let cellsToDraw = null;
            
            console.log('=== createLevelPreview ===');
            console.log('paintedCells:', levelData.paintedCells);
            console.log('variables:', levelData.variables);
            
            // Si le niveau a des paintedCells (difficult√© 1 et 2), les utiliser directement
            if (levelData.paintedCells && Object.keys(levelData.paintedCells).length > 0) {
                console.log('Utilisation de paintedCells (difficult√© 1 ou 2)');
                cellsToDraw = levelData.paintedCells;
            } 
            // Sinon, si le niveau a des variables (difficult√© 3), ex√©cuter le programme pour obtenir le motif
            else if (levelData.variables && levelData.variables.createdVariables && levelData.variables.createdVariables.length > 0) {
                console.log('D√©tect√© niveau difficult√© 3, ex√©cution du programme...');
                console.log('Variables du niveau:', levelData.variables);
                console.log('Nombre de blocs:', levelData.blocks ? levelData.blocks.length : 0);
                
                // Activer le mode aper√ßu pour d√©sactiver drawTurtle
                window.isPreviewMode = true;
                
                // Sauvegarder l'√©tat actuel de mani√®re compl√®te
                const savedGrid = grid ? grid.map(row => row ? [...row] : []) : [];
                const savedTurtle = turtle ? { ...turtle } : null;
                const savedVariables = variables ? { ...variables } : {};
                const savedCreatedVariables = createdVariables ? [...createdVariables] : [];
                
                try {
                    // Cr√©er une grille temporaire pour l'ex√©cution
                    grid = [];
                    for (let y = 0; y < gridSize; y++) {
                        grid[y] = [];
                        for (let x = 0; x < gridSize; x++) {
                            grid[y][x] = { color: 'white' };
                        }
                    }
                    
                    // Restaurer les variables du niveau
                    createdVariables = [...(levelData.variables.createdVariables || [])];
                    variables = { ...(levelData.variables.variableValues || {}) };
                    
                    console.log('Variables restaur√©es:', createdVariables, variables);
                    
                    // R√©initialiser la tortue
                    turtle = {
                        x: 5,
                        y: 9,
                        direction: 0,
                        color: 'red'
                    };
                    
                    // Ex√©cuter le programme
                    console.log('Ex√©cution du programme...');
                    executeSavedBlocks(levelData.blocks);
                    
                    // Capturer les cellules color√©es
                    cellsToDraw = {};
                    let cellCount = 0;
                    for (let y = 0; y < gridSize; y++) {
                        for (let x = 0; x < gridSize; x++) {
                            if (grid[y] && grid[y][x] && grid[y][x].color !== 'white') {
                                cellsToDraw[`${y}-${x}`] = grid[y][x].color;
                                cellCount++;
                            }
                        }
                    }
                    console.log('Cellules captur√©es:', cellCount);
                    console.log('Cellules:', cellsToDraw);
                } catch (error) {
                    console.error('ERREUR lors de l\'ex√©cution du programme pour l\'aper√ßu:', error);
                    console.error('Stack:', error.stack);
                    // En cas d'erreur, au moins afficher une grille vide
                    cellsToDraw = {};
                }
                
                // Restaurer l'√©tat
                grid = savedGrid;
                turtle = savedTurtle;
                variables = savedVariables;
                createdVariables = savedCreatedVariables;
                
                // D√©sactiver le mode aper√ßu
                window.isPreviewMode = false;
                
                console.log('√âtat restaur√©');
            } else {
                console.log('Pas de paintedCells ni de variables - grille vide');
            }
            
            // Dessiner les cellules
            if (cellsToDraw) {
                console.log('Dessin de', Object.keys(cellsToDraw).length, 'cellules');
                Object.entries(cellsToDraw).forEach(([cellKey, color]) => {
                    const [row, col] = cellKey.split('-').map(Number);
                    ctx.fillStyle = colorMap[color] || color;
                    ctx.fillRect(col * cellSize + 1, row * cellSize + 1, cellSize - 2, cellSize - 2);
                });
            }
            
            previewContainer.appendChild(canvas);
            return previewContainer;
        }
        
        function autoSaveLevelManagerChanges() {
            const cursus = document.getElementById('modal-cursus-select').value;
            
            // Sauvegarder la configuration des mondes
            cursusData[cursus].worlds = tempWorldsConfig.worlds;
            cursusData[cursus].levelsPerWorld = tempWorldsConfig.levelsPerWorld;
            cursusData[cursus].pointsPerWorld = [...tempWorldsConfig.pointsPerWorld];
            
            // Sauvegarder les niveaux (ils sont d√©j√† dans le bon ordre/position)
            cursusData[cursus].levels = { ...tempLevelsData };
            
            // Sauvegarder
            saveToStorage();
            markAsModified(); // Marquer qu'il y a eu des modifications
            
            // Recharger l'interface si c'est le cursus actuel
            if (cursus === document.getElementById('teacher-cursus-select').value) {
                // V√©rifier si le niveau actuellement charg√© existe encore
                const currentLevelStillExists = lastLoadedLevel && tempLevelsData[lastLoadedLevel];
                
                if (!currentLevelStillExists) {
                    // Le niveau charg√© a √©t√© supprim√© OU aucun niveau charg√©
                    // Il faut recharger compl√®tement
                    lastLoadedLevel = null;
                    loadTeacherLevels();
                } else {
                    // Le niveau actuel existe encore, juste mettre √† jour la liste sans recharger
                    const levelSelect = document.getElementById('teacher-level-select');
                    const currentValue = levelSelect.value; // Sauvegarder la s√©lection actuelle
                    
                    // D√©sactiver onchange temporairement
                    levelSelect.onchange = null;
                    
                    // Reconstruire la liste
                    levelSelect.innerHTML = '<option value="new">+ Nouveau niveau</option>';
                    const levels = cursusData[cursus].levels || {};
                    const levelKeys = Object.keys(levels).sort((a, b) => parseInt(a) - parseInt(b));
                    const levelsPerWorld = cursusData[cursus].levelsPerWorld || 10;
                    
                    levelKeys.forEach((levelNum) => {
                        const level = levels[levelNum];
                        const levelIndex = parseInt(levelNum) - 1;
                        const worldNum = Math.floor(levelIndex / levelsPerWorld) + 1;
                        const levelInWorld = (levelIndex % levelsPerWorld) + 1;
                        
                        const option = document.createElement('option');
                        option.value = levelNum;
                        option.textContent = `Monde ${worldNum} - Niveau ${levelInWorld} - Blocs optimaux : ${level.blockCount}`;
                        levelSelect.appendChild(option);
                    });
                    
                    // Restaurer la s√©lection
                    levelSelect.value = currentValue;
                    
                    // R√©activer onchange
                    levelSelect.onchange = saveCurrentAndLoadTeacherLevel;
                }
                
                // NE PAS recharger loadCursusLevels() car √ßa nettoie la grille du prof !
                // loadCursusLevels sera appel√© automatiquement quand l'utilisateur passera en mode √©l√®ve
            }
        }
        
        function deleteLevelFromList(levelNum) {
            console.log('deleteLevelFromList appel√©e avec levelNum:', levelNum);
            console.log('tempLevelsData avant suppression:', tempLevelsData);
            
            const levelKey = levelNum.toString();
            console.log('Suppression du niveau:', levelKey);
            delete tempLevelsData[levelKey];
            console.log('tempLevelsData apr√®s suppression:', tempLevelsData);
            updateLevelsList();
            // Sauvegarder automatiquement
            autoSaveLevelManagerChanges();
        }
        
        function saveLevelManagerChanges() {
            const cursus = document.getElementById('teacher-cursus-select').value;
            
            // Sauvegarder la configuration des mondes
            cursusData[cursus].worlds = tempWorldsConfig.worlds;
            cursusData[cursus].levelsPerWorld = tempWorldsConfig.levelsPerWorld;
            cursusData[cursus].pointsPerWorld = [...tempWorldsConfig.pointsPerWorld];
            
            // Sauvegarder les niveaux (ils sont d√©j√† dans le bon ordre/position)
            cursusData[cursus].levels = { ...tempLevelsData };
            
            // Sauvegarder
            saveToStorage();
            
            // Recharger l'interface
            loadTeacherLevels();
            
            closeLevelManagerModal();
            
            alert('‚úÖ Modifications enregistr√©es !');
        }
        
        function closeLevelManagerModal() {
            document.getElementById('level-manager-modal').classList.remove('active');
            tempWorldsConfig = null;
            tempLevelsData = null;
        }
        
        // ===== CR√âATION AUTOMATIS√âE =====
        let autoCreateConfig = null;
        
        // Fonction de confirmation personnalis√©e
        function customConfirm(message, isDangerous = false) {
            return new Promise((resolve) => {
                const overlay = document.getElementById('custom-confirm-overlay');
                const modal = document.getElementById('custom-confirm-modal');
                const messageDiv = document.getElementById('custom-confirm-message');
                const okBtn = document.getElementById('custom-confirm-ok');
                const cancelBtn = document.getElementById('custom-confirm-cancel');
                
                messageDiv.textContent = message;
                overlay.style.display = 'block';
                modal.style.display = 'block';
                
                // Changer la couleur du bouton selon le danger
                if (isDangerous) {
                    okBtn.style.background = '#dc3545'; // Rouge pour danger
                } else {
                    okBtn.style.background = '#4CAF50'; // Vert pour normal
                }
                
                const handleOk = () => {
                    overlay.style.display = 'none';
                    modal.style.display = 'none';
                    okBtn.removeEventListener('click', handleOk);
                    cancelBtn.removeEventListener('click', handleCancel);
                    resolve(true);
                };
                
                const handleCancel = () => {
                    overlay.style.display = 'none';
                    modal.style.display = 'none';
                    okBtn.removeEventListener('click', handleOk);
                    cancelBtn.removeEventListener('click', handleCancel);
                    resolve(false);
                };
                
                okBtn.addEventListener('click', handleOk);
                cancelBtn.addEventListener('click', handleCancel);
            });
        }
        
        function openAutoCreateModal() {
            const modal = document.getElementById('auto-create-modal');
            
            // Synchroniser le cursus avec le select principal (par d√©faut)
            const currentCursus = document.getElementById('teacher-cursus-select').value;
            document.getElementById('auto-cursus-select').value = currentCursus;
            
            // Initialiser la configuration
            autoCreateConfig = {
                numWorlds: 3,
                levelsPerWorld: 10,
                worlds: []
            };
            
            // Initialiser les mondes avec des valeurs par d√©faut
            for (let i = 0; i < 3; i++) {
                autoCreateConfig.worlds.push({
                    pointsRequired: i === 0 ? 0 : 10 * i,
                    difficulty1: Math.floor(autoCreateConfig.levelsPerWorld / 3),
                    difficulty2: Math.floor(autoCreateConfig.levelsPerWorld / 3),
                    difficulty3: autoCreateConfig.levelsPerWorld - 2 * Math.floor(autoCreateConfig.levelsPerWorld / 3)
                });
            }
            
            document.getElementById('auto-num-worlds').value = autoCreateConfig.numWorlds;
            document.getElementById('auto-levels-per-world').value = autoCreateConfig.levelsPerWorld;
            
            // Initialiser les limites selon le cursus
            updateAutoLimits();
            
            modal.classList.add('active');
            
            // Ajouter la s√©lection automatique sur tous les inputs number de la modal
            setTimeout(() => {
                const numberInputs = modal.querySelectorAll('input[type="number"]');
                numberInputs.forEach(input => {
                    input.addEventListener('focus', function() {
                        this.select();
                    });
                });
            }, 100);
        }
        
        // Mettre √† jour les limites des compteurs selon le cursus s√©lectionn√©
        function updateAutoLimits() {
            const cursusSelect = document.getElementById('auto-cursus-select');
            const numWorldsInput = document.getElementById('auto-num-worlds');
            const levelsPerWorldInput = document.getElementById('auto-levels-per-world');
            
            const isAll = cursusSelect.value === 'all';
            
            // Cursus "Tous" = max 100 par compteur (car √ó 3 cursus)
            // Cursus individuel = max MAX_TOTAL_LEVELS
            numWorldsInput.max = isAll ? MAX_LEVELS_PER_INPUT_ALL : MAX_LEVELS_PER_INPUT_SINGLE;
            levelsPerWorldInput.max = isAll ? MAX_LEVELS_PER_INPUT_ALL : MAX_LEVELS_PER_INPUT_SINGLE;
            
            // Ajuster les valeurs si elles d√©passent la nouvelle limite
            if (parseInt(numWorldsInput.value) > parseInt(numWorldsInput.max)) {
                numWorldsInput.value = numWorldsInput.max;
            }
            if (parseInt(levelsPerWorldInput.value) > parseInt(levelsPerWorldInput.max)) {
                levelsPerWorldInput.value = levelsPerWorldInput.max;
            }
            
            updateAutoWorldsConfig();
        }
        
        function updateAutoWorldsConfig(shouldUpdatePoints = true) {
            const cursusSelect = document.getElementById('auto-cursus-select');
            const numWorldsInput = document.getElementById('auto-num-worlds');
            const levelsPerWorldInput = document.getElementById('auto-levels-per-world');
            const numWorlds = parseInt(numWorldsInput.value);
            const levelsPerWorld = parseInt(levelsPerWorldInput.value);
            
            // Calculer le multiplicateur selon le cursus
            const isAll = cursusSelect.value === 'all';
            const multiplier = isAll ? 3 : 1; // "Tous" = 3 cursus
            
            // VALIDATION : V√©rifier que le total ne d√©passe pas MAX_TOTAL_LEVELS niveaux
            const totalLevels = numWorlds * levelsPerWorld * multiplier;
            if (totalLevels > MAX_TOTAL_LEVELS) {
                numWorldsInput.style.border = '2px solid #FF0000';
                numWorldsInput.style.background = '#FFE0E0';
                levelsPerWorldInput.style.border = '2px solid #FF0000';
                levelsPerWorldInput.style.background = '#FFE0E0';
                const cursusInfo = isAll ? ` √ó 3 cursus` : '';
                alert(`‚ùå Limite d√©pass√©e !\n\n${numWorlds} mondes √ó ${levelsPerWorld} niveaux/monde${cursusInfo} = ${totalLevels} niveaux\n\nLa limite maximale est de ${MAX_TOTAL_LEVELS} niveaux au total.\n\nLes valeurs ont √©t√© ajust√©es automatiquement.`);
                
                // Ajuster automatiquement les valeurs
                // Strat√©gie : r√©duire levelsPerWorld en priorit√©
                let adjustedLevelsPerWorld = Math.floor(MAX_TOTAL_LEVELS / (numWorlds * multiplier));
                if (adjustedLevelsPerWorld < 1) {
                    // Si m√™me avec 1 niveau par monde c'est trop, r√©duire le nombre de mondes
                    adjustedLevelsPerWorld = 1;
                    const adjustedNumWorlds = Math.floor(MAX_TOTAL_LEVELS / multiplier);
                    numWorldsInput.value = adjustedNumWorlds;
                }
                levelsPerWorldInput.value = adjustedLevelsPerWorld;
                
                // R√©initialiser les styles
                numWorldsInput.style.border = '2px solid #E0E0E0';
                numWorldsInput.style.background = 'white';
                levelsPerWorldInput.style.border = '2px solid #E0E0E0';
                levelsPerWorldInput.style.background = 'white';
                
                // Utiliser les valeurs ajust√©es pour la suite
                autoCreateConfig.numWorlds = parseInt(numWorldsInput.value);
                autoCreateConfig.levelsPerWorld = parseInt(levelsPerWorldInput.value);
            } else {
                // R√©initialiser les styles si OK
                numWorldsInput.style.border = '2px solid #E0E0E0';
                numWorldsInput.style.background = 'white';
                levelsPerWorldInput.style.border = '2px solid #E0E0E0';
                levelsPerWorldInput.style.background = 'white';
                
                autoCreateConfig.numWorlds = numWorlds;
                autoCreateConfig.levelsPerWorld = levelsPerWorld;
            }
            
            // Ajuster le tableau des mondes
            while (autoCreateConfig.worlds.length < numWorlds) {
                const worldIndex = autoCreateConfig.worlds.length;
                autoCreateConfig.worlds.push({
                    pointsRequired: worldIndex === 0 ? 0 : 10 * worldIndex,
                    difficulty1: Math.floor(levelsPerWorld / 3),
                    difficulty2: Math.floor(levelsPerWorld / 3),
                    difficulty3: levelsPerWorld - 2 * Math.floor(levelsPerWorld / 3)
                });
            }
            autoCreateConfig.worlds = autoCreateConfig.worlds.slice(0, numWorlds);
            
            // Mettre √† jour les valeurs pour correspondre au nouveau levelsPerWorld
            autoCreateConfig.worlds.forEach((world, i) => {
                const total = world.difficulty1 + world.difficulty2 + world.difficulty3;
                if (total !== levelsPerWorld) {
                    // R√©partir √©quitablement
                    world.difficulty1 = Math.floor(levelsPerWorld / 3);
                    world.difficulty2 = Math.floor(levelsPerWorld / 3);
                    world.difficulty3 = levelsPerWorld - 2 * Math.floor(levelsPerWorld / 3);
                }
                
                // AJUSTEMENT AUTOMATIQUE DES POINTS REQUIS
                if (shouldUpdatePoints && i > 0) {
                    const previousLevels = i * levelsPerWorld;
                    const maxPointsAvailable = previousLevels * 2;
                    
                    // Utiliser la formule incr√©mentale : (levelsPerWorld + 1) √ó index
                    // Monde 2 : (10 + 1) √ó 1 = 11
                    // Monde 3 : (10 + 1) √ó 2 = 22
                    const recommendedPoints = (levelsPerWorld + 1) * i;
                    
                    // Si les points actuels d√©passent le max OU si shouldUpdatePoints = true, ajuster
                    if (world.pointsRequired > maxPointsAvailable || shouldUpdatePoints) {
                        // Utiliser les points recommand√©s s'ils sont atteignables, sinon le max
                        world.pointsRequired = Math.min(recommendedPoints, maxPointsAvailable);
                    }
                }
            });
            
            // Mettre √† jour les champs de configuration rapide pour refl√©ter la nouvelle r√©partition
            if (autoCreateConfig.worlds.length > 0) {
                document.getElementById('quick-diff1').value = autoCreateConfig.worlds[0].difficulty1;
                document.getElementById('quick-diff2').value = autoCreateConfig.worlds[0].difficulty2;
                document.getElementById('quick-diff3').value = autoCreateConfig.worlds[0].difficulty3;
                
                // Ajuster les points requis SEULEMENT si shouldUpdatePoints = true
                if (shouldUpdatePoints) {
                    document.getElementById('quick-points').value = levelsPerWorld + 1;
                }
            }
            
            // G√©n√©rer l'interface
            const configDiv = document.getElementById('auto-worlds-config');
            configDiv.innerHTML = '';
            
            for (let i = 0; i < numWorlds; i++) {
                const worldDiv = document.createElement('div');
                worldDiv.style.cssText = 'margin-bottom: 15px; padding: 12px; background: white; border-radius: 4px; border: 2px solid #E0E0E0;';
                
                // Titre du monde
                const worldTitle = document.createElement('div');
                worldTitle.style.cssText = 'font-weight: bold; font-size: 14px; margin-bottom: 10px; color: #1976D2;';
                worldTitle.textContent = `üåç Monde ${i + 1}`;
                worldDiv.appendChild(worldTitle);
                
                // Points requis
                const pointsDiv = document.createElement('div');
                pointsDiv.style.cssText = 'display: flex; align-items: center; gap: 10px; margin-bottom: 10px;';
                
                const pointsLabel = document.createElement('label');
                pointsLabel.style.cssText = 'font-size: 12px; min-width: 120px;';
                pointsLabel.textContent = 'Points requis:';
                
                const pointsInput = document.createElement('input');
                pointsInput.type = 'number';
                pointsInput.min = '0';
                pointsInput.max = '10000';
                pointsInput.value = autoCreateConfig.worlds[i].pointsRequired;
                pointsInput.style.cssText = 'width: 80px; padding: 4px; border: 2px solid #E0E0E0; border-radius: 4px; font-size: 12px;';
                pointsInput.disabled = i === 0;
                
                // Ajouter la s√©lection automatique au focus
                pointsInput.addEventListener('focus', function() {
                    this.select();
                });
                
                pointsInput.onchange = () => {
                    const newPoints = parseInt(pointsInput.value) || 0;
                    
                    // V√©rifier que les points sont atteignables (seulement pour monde 2+)
                    if (i > 0) {
                        // Calculer le maximum de points disponibles dans les mondes pr√©c√©dents
                        const previousLevels = i * levelsPerWorld;
                        const maxPointsAvailable = previousLevels * 2; // 2 points max par niveau
                        
                        if (newPoints > maxPointsAvailable) {
                            pointsInput.style.border = '2px solid #FF0000';
                            pointsInput.style.background = '#FFE0E0';
                            alert(`‚ùå Impossible !\n\nPour d√©bloquer le Monde ${i + 1}, vous demandez ${newPoints} points.\n\nMais les ${previousLevels} niveaux des mondes pr√©c√©dents donnent au maximum ${maxPointsAvailable} points (${previousLevels} √ó 2).\n\nLe maximum atteignable est ${maxPointsAvailable} points.`);
                            pointsInput.value = autoCreateConfig.worlds[i].pointsRequired;
                            return;
                        }
                        
                        // R√©initialiser le style si OK
                        pointsInput.style.border = '2px solid #E0E0E0';
                        pointsInput.style.background = 'white';
                    }
                    
                    autoCreateConfig.worlds[i].pointsRequired = newPoints;
                };
                
                pointsDiv.appendChild(pointsLabel);
                pointsDiv.appendChild(pointsInput);
                
                if (i === 0) {
                    const note = document.createElement('span');
                    note.style.cssText = 'font-size: 11px; color: #999;';
                    note.textContent = '(toujours accessible)';
                    pointsDiv.appendChild(note);
                }
                
                worldDiv.appendChild(pointsDiv);
                
                // Difficult√©s
                const difficultiesDiv = document.createElement('div');
                difficultiesDiv.style.cssText = 'display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;';
                
                ['difficulty1', 'difficulty2', 'difficulty3'].forEach((key, idx) => {
                    const diffDiv = document.createElement('div');
                    diffDiv.style.cssText = 'display: flex; flex-direction: column; gap: 5px;';
                    
                    const diffLabel = document.createElement('label');
                    diffLabel.style.cssText = 'font-size: 11px; font-weight: bold;';
                    diffLabel.textContent = `Difficult√© ${idx + 1}:`;
                    
                    const diffInput = document.createElement('input');
                    diffInput.type = 'number';
                    diffInput.min = '0';
                    diffInput.max = levelsPerWorld.toString();
                    diffInput.value = autoCreateConfig.worlds[i][key];
                    diffInput.dataset.worldIndex = i;
                    diffInput.dataset.key = key;
                    diffInput.style.cssText = 'width: 100%; padding: 4px; border: 2px solid #E0E0E0; border-radius: 4px; font-size: 12px;';
                    
                    // Ajouter la s√©lection automatique au focus
                    diffInput.addEventListener('focus', function() {
                        this.select();
                    });
                    
                    diffInput.onchange = (e) => {
                        const newValue = parseInt(e.target.value) || 0;
                        
                        // Obtenir le multiplicateur selon le cursus
                        const cursusSelect = document.getElementById('auto-cursus-select');
                        const isAll = cursusSelect.value === 'all';
                        const multiplier = isAll ? 3 : 1;
                        
                        // Calculer le total si on applique ce changement
                        const tempWorld = {...autoCreateConfig.worlds[i]};
                        tempWorld[key] = newValue;
                        const worldTotal = tempWorld.difficulty1 + tempWorld.difficulty2 + tempWorld.difficulty3;
                        
                        // Calculer le total global
                        let globalTotal = 0;
                        autoCreateConfig.worlds.forEach((w, idx) => {
                            if (idx === i) {
                                globalTotal += worldTotal;
                            } else {
                                globalTotal += (w.difficulty1 + w.difficulty2 + w.difficulty3);
                            }
                        });
                        
                        // Appliquer le multiplicateur
                        globalTotal *= multiplier;
                        
                        // V√©rifier la limite de 300
                        if (globalTotal > MAX_TOTAL_LEVELS) {
                            e.target.style.border = '2px solid #FF0000';
                            e.target.style.background = '#FFE0E0';
                            const cursusInfo = isAll ? ' (√ó 3 cursus)' : '';
                            alert(`‚ùå Limite d√©pass√©e !\n\nCe changement porterait le total √† ${globalTotal} niveaux${cursusInfo}.\n\nLa limite maximale est de ${MAX_TOTAL_LEVELS} niveaux au total.\n\nVeuillez r√©duire les niveaux dans d'autres mondes ou ajuster la configuration g√©n√©rale.`);
                            e.target.value = autoCreateConfig.worlds[i][key];
                            // R√©initialiser les styles apr√®s restauration
                            e.target.style.border = '2px solid #E0E0E0';
                            e.target.style.background = 'white';
                            return;
                        }
                        
                        // Si OK, appliquer le changement
                        autoCreateConfig.worlds[i][key] = newValue;
                        validateDifficulties(i);
                    };
                    
                    diffDiv.appendChild(diffLabel);
                    diffDiv.appendChild(diffInput);
                    difficultiesDiv.appendChild(diffDiv);
                });
                
                worldDiv.appendChild(difficultiesDiv);
                
                // Message d'erreur
                const errorMsg = document.createElement('div');
                errorMsg.id = `world-${i}-error`;
                errorMsg.style.cssText = 'font-size: 11px; color: #f44336; margin-top: 5px; display: none;';
                worldDiv.appendChild(errorMsg);
                
                configDiv.appendChild(worldDiv);
            }
        }
        
        function validateQuickConfig() {
            const diff1 = parseInt(document.getElementById('quick-diff1').value) || 0;
            const diff2 = parseInt(document.getElementById('quick-diff2').value) || 0;
            const diff3 = parseInt(document.getElementById('quick-diff3').value) || 0;
            const levelsPerWorld = autoCreateConfig.levelsPerWorld;
            const total = diff1 + diff2 + diff3;
            
            const errorMsg = document.getElementById('quick-config-error');
            const applyBtn = document.getElementById('quick-apply-btn');
            const inputs = [
                document.getElementById('quick-diff1'),
                document.getElementById('quick-diff2'),
                document.getElementById('quick-diff3')
            ];
            
            if (total > levelsPerWorld) {
                errorMsg.textContent = `‚ö†Ô∏è Total: ${total} / ${levelsPerWorld} niveaux (trop de niveaux !)`;
                errorMsg.style.display = 'block';
                inputs.forEach(input => {
                    input.style.borderColor = '#f44336';
                    input.style.color = '#f44336';
                });
                // D√©sactiver le bouton
                applyBtn.disabled = true;
                applyBtn.style.opacity = '0.5';
                applyBtn.style.cursor = 'not-allowed';
                applyBtn.style.background = '#9E9E9E';
            } else {
                errorMsg.style.display = 'none';
                inputs.forEach(input => {
                    input.style.borderColor = '#E0E0E0';
                    input.style.color = '#000';
                });
                // R√©activer le bouton
                applyBtn.disabled = false;
                applyBtn.style.opacity = '1';
                applyBtn.style.cursor = 'pointer';
                applyBtn.style.background = '#4CAF50';
            }
        }
        
        function applyQuickConfig() {
            const cursusSelect = document.getElementById('auto-cursus-select');
            const isAll = cursusSelect.value === 'all';
            const multiplier = isAll ? 3 : 1;
            
            const pointsIncrement = parseInt(document.getElementById('quick-points').value) || 10;
            const diff1 = parseInt(document.getElementById('quick-diff1').value) || 0;
            const diff2 = parseInt(document.getElementById('quick-diff2').value) || 0;
            const diff3 = parseInt(document.getElementById('quick-diff3').value) || 0;
            const levelsPerWorld = autoCreateConfig.levelsPerWorld;
            
            console.log('=== applyQuickConfig ===');
            console.log('pointsIncrement:', pointsIncrement);
            console.log('levelsPerWorld:', levelsPerWorld);
            
            // V√©rifier que le total correspond au nombre de niveaux par monde
            const total = diff1 + diff2 + diff3;
            if (total !== levelsPerWorld) {
                alert(`‚ö†Ô∏è Le total des difficult√©s (${total}) doit √™tre √©gal au nombre de niveaux par monde (${levelsPerWorld})`);
                return;
            }
            
            // VALIDATION : V√©rifier que le total ne d√©passe pas 300 niveaux
            const totalLevels = autoCreateConfig.numWorlds * levelsPerWorld * multiplier;
            if (totalLevels > MAX_TOTAL_LEVELS) {
                const cursusInfo = isAll ? ` √ó 3 cursus` : '';
                alert(`‚ùå Configuration impossible !\n\n${autoCreateConfig.numWorlds} mondes √ó ${levelsPerWorld} niveaux/monde${cursusInfo} = ${totalLevels} niveaux\n\nLa limite maximale est de ${MAX_TOTAL_LEVELS} niveaux au total.\n\nVeuillez d'abord ajuster le nombre de mondes ou de niveaux par monde dans "Configuration g√©n√©rale".`);
                return;
            }
            
            // VALIDATION : V√©rifier que les points requis sont atteignables pour tous les mondes
            for (let i = 1; i < autoCreateConfig.numWorlds; i++) {
                const previousLevels = i * levelsPerWorld;
                const maxPointsAvailable = previousLevels * 2;
                const requiredPoints = pointsIncrement * i; // Incr√©ment cumulatif : monde 2 = 11, monde 3 = 22
                
                console.log(`Monde ${i + 1}: requiredPoints=${requiredPoints}, maxAvailable=${maxPointsAvailable}`);
                
                if (requiredPoints > maxPointsAvailable) {
                    alert(`‚ùå Impossible !\n\nLe Monde ${i + 1} n√©cessiterait ${requiredPoints} points avec cette configuration.\n\nMais les ${previousLevels} niveaux pr√©c√©dents donnent au maximum ${maxPointsAvailable} points (${previousLevels} √ó 2).\n\nVeuillez r√©duire les points requis √† maximum ${Math.floor(maxPointsAvailable / i)}.`);
                    return;
                }
            }
            
            console.log('Validation OK, application...');
            
            // Appliquer √† tous les mondes
            autoCreateConfig.worlds.forEach((world, index) => {
                if (index === 0) {
                    world.pointsRequired = 0;
                } else {
                    // Incr√©ment cumulatif : monde 2 = 11, monde 3 = 22, monde 4 = 33
                    world.pointsRequired = pointsIncrement * index;
                }
                
                world.difficulty1 = diff1;
                world.difficulty2 = diff2;
                world.difficulty3 = diff3;
            });
            
            console.log('Configuration appliqu√©e, reg√©n√©ration interface...');
            
            // R√©g√©n√©rer l'interface SANS mettre √† jour les points
            updateAutoWorldsConfig(false);
            
            console.log('Termin√©');
        }
        
        function validateDifficulties(worldIndex) {
            const world = autoCreateConfig.worlds[worldIndex];
            const total = world.difficulty1 + world.difficulty2 + world.difficulty3;
            const levelsPerWorld = autoCreateConfig.levelsPerWorld;
            const errorMsg = document.getElementById(`world-${worldIndex}-error`);
            
            // Trouver tous les inputs de ce monde
            const inputs = document.querySelectorAll(`input[data-world-index="${worldIndex}"]`);
            
            if (total > levelsPerWorld) {
                errorMsg.textContent = `‚ö†Ô∏è Total: ${total} / ${levelsPerWorld} niveaux (trop de niveaux !)`;
                errorMsg.style.display = 'block';
                inputs.forEach(input => {
                    input.style.borderColor = '#f44336';
                    input.style.color = '#f44336';
                });
            } else {
                errorMsg.style.display = 'none';
                inputs.forEach(input => {
                    input.style.borderColor = '#E0E0E0';
                    input.style.color = 'inherit';
                });
                if (total < levelsPerWorld) {
                    errorMsg.textContent = `‚ÑπÔ∏è Total: ${total} / ${levelsPerWorld} niveaux`;
                    errorMsg.style.display = 'block';
                    errorMsg.style.color = '#2196F3';
                }
            }
            
            // V√©rifier tous les mondes pour activer/d√©sactiver les boutons de g√©n√©ration
            checkAllWorlds();
        }
        
        function checkAllWorlds() {
            const levelsPerWorld = autoCreateConfig.levelsPerWorld;
            let hasError = false;
            
            // V√©rifier chaque monde
            autoCreateConfig.worlds.forEach((world) => {
                const total = world.difficulty1 + world.difficulty2 + world.difficulty3;
                if (total > levelsPerWorld) {
                    hasError = true;
                }
            });
            
            // Activer/d√©sactiver les boutons de g√©n√©ration
            const btnTop = document.getElementById('generate-btn-top');
            const btnBottom = document.getElementById('generate-btn-bottom');
            
            if (hasError) {
                // D√©sactiver les boutons
                btnTop.disabled = true;
                btnTop.style.opacity = '0.5';
                btnTop.style.cursor = 'not-allowed';
                btnTop.style.background = '#9E9E9E';
                
                btnBottom.disabled = true;
                btnBottom.style.opacity = '0.5';
                btnBottom.style.cursor = 'not-allowed';
                btnBottom.style.background = '#9E9E9E';
            } else {
                // R√©activer les boutons
                btnTop.disabled = false;
                btnTop.style.opacity = '1';
                btnTop.style.cursor = 'pointer';
                btnTop.style.background = '#4CAF50';
                
                btnBottom.disabled = false;
                btnBottom.style.opacity = '1';
                btnBottom.style.cursor = 'pointer';
                btnBottom.style.background = '#4CAF50';
            }
        }
        
        async function generateWorldsAutomatically() {
            console.log('=== D√âBUT G√âN√âRATION AUTOMATIQUE ===');
            
            // V√©rifier que la config existe
            if (!autoCreateConfig) {
                alert('‚ùå Erreur: Configuration non initialis√©e. Veuillez fermer et rouvrir la popup.');
                console.error('autoCreateConfig est null');
                return;
            }
            
            console.log('Configuration:', autoCreateConfig);
            
            const selectedCursus = document.getElementById('auto-cursus-select').value;
            const cursusList = selectedCursus === 'all' ? ['5eme', '4eme', '3eme'] : [selectedCursus];
            console.log('Cursus √† g√©n√©rer:', cursusList);
            
            // V√âRIFICATION PRIORITAIRE : Calculer le nombre total de niveaux qui seront cr√©√©s
            let totalLevelsToCreate = 0;
            for (const cursus of cursusList) {
                // Nombre de niveaux par monde * nombre de mondes = niveaux par cursus
                const levelsPerCursus = autoCreateConfig.numWorlds * autoCreateConfig.levelsPerWorld;
                totalLevelsToCreate += levelsPerCursus;
            }
            
            // Compter les niveaux existants dans les cursus NON affect√©s
            let existingLevelsInOtherCursus = 0;
            for (let cursusName in cursusData) {
                if (!cursusList.includes(cursusName)) {
                    existingLevelsInOtherCursus += Object.keys(cursusData[cursusName].levels).length;
                }
            }
            
            const totalFinalLevels = totalLevelsToCreate + existingLevelsInOtherCursus;
            
            if (totalFinalLevels > MAX_TOTAL_LEVELS) {
                alert(`‚ùå Limite d√©pass√©e !\n\nCette g√©n√©ration cr√©erait ${totalLevelsToCreate} niveau(x).\nAvec les ${existingLevelsInOtherCursus} niveau(x) existant(s) dans les autres cursus, cela ferait ${totalFinalLevels} niveaux au total.\n\nLa limite maximale est de ${MAX_TOTAL_LEVELS} niveaux (tous cursus confondus).\n\nVeuillez r√©duire le nombre de mondes ou de niveaux par monde.`);
                return;
            }
            
            // V√©rifier les configurations pour tous les cursus
            for (let i = 0; i < autoCreateConfig.worlds.length; i++) {
                const world = autoCreateConfig.worlds[i];
                const total = world.difficulty1 + world.difficulty2 + world.difficulty3;
                
                if (total > autoCreateConfig.levelsPerWorld) {
                    alert(`‚ùå Erreur: Le monde ${i + 1} a trop de niveaux (${total}/${autoCreateConfig.levelsPerWorld})`);
                    return;
                }
                
                // V√©rifier que les points requis sont atteignables (pour monde 2+)
                if (i > 0) {
                    const previousLevels = i * autoCreateConfig.levelsPerWorld;
                    const maxPointsAvailable = previousLevels * 2;
                    
                    if (world.pointsRequired > maxPointsAvailable) {
                        alert(`‚ùå Erreur: Le Monde ${i + 1} demande ${world.pointsRequired} points pour √™tre d√©bloqu√©.\n\nMais les ${previousLevels} niveaux des mondes pr√©c√©dents donnent au maximum ${maxPointsAvailable} points.\n\nVeuillez ajuster les points requis.`);
                        return;
                    }
                }
            }
            
            // Message de confirmation
            let confirmMessage = '';
            let totalExistingLevels = 0;
            
            for (const cursus of cursusList) {
                const existingLevels = Object.keys(cursusData[cursus].levels || {});
                totalExistingLevels += existingLevels.length;
            }
            
            if (totalExistingLevels > 0) {
                const cursusText = cursusList.length > 1 ? `les ${cursusList.length} cursus` : `le cursus ${cursusList[0]}`;
                confirmMessage = `‚ö†Ô∏è ATTENTION\n\nVous avez ${totalExistingLevels} niveau(x) existant(s) dans ${cursusText}.\nLa g√©n√©ration entra√Ænera leur suppression.\nCette action est irr√©versible.\n\nVoulez-vous continuer ?`;
            } else {
                const cursusText = cursusList.length > 1 ? `les ${cursusList.length} cursus` : `le cursus ${cursusList[0]}`;
                confirmMessage = `Voulez-vous g√©n√©rer ${autoCreateConfig.numWorlds} monde(s) avec ${autoCreateConfig.levelsPerWorld} niveaux par monde pour ${cursusText} ?\n\nCela va cr√©er les niveaux automatiquement selon la configuration choisie.`;
            }
            
            const userConfirmed = await customConfirm(confirmMessage, totalExistingLevels > 0);
            
            if (!userConfirmed) {
                console.log('G√©n√©ration annul√©e par l\'utilisateur');
                return;
            }
            
            console.log('Confirmation re√ßue, continuation...');
            console.log('Validation OK, d√©but de la g√©n√©ration...');
            
            // Afficher un message de progression
            const progressMsg = document.createElement('div');
            progressMsg.id = 'progress-message';
            progressMsg.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 10004; text-align: center;';
            progressMsg.innerHTML = '<h3>‚è≥ G√©n√©ration en cours...</h3><p style="margin-top: 10px;">Veuillez patienter</p>';
            document.body.appendChild(progressMsg);
            
            // Attendre un peu pour que le message s'affiche
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
                let totalLevelsCreated = 0;
                
                // Boucle sur tous les cursus √† g√©n√©rer
                for (const cursus of cursusList) {
                    console.log(`\n=== G√©n√©ration pour ${cursus} ===`);
                    console.log('Effacement des niveaux existants...');
                    
                    // Effacer tous les niveaux existants
                    cursusData[cursus].levels = {};
                    
                    console.log('Configuration des mondes...');
                    // Configurer les mondes
                    cursusData[cursus].worlds = autoCreateConfig.numWorlds;
                    cursusData[cursus].levelsPerWorld = autoCreateConfig.levelsPerWorld;
                    cursusData[cursus].pointsPerWorld = autoCreateConfig.worlds.map(w => w.pointsRequired);
                    
                    console.log(`Mondes configur√©s: ${autoCreateConfig.numWorlds} mondes, ${autoCreateConfig.levelsPerWorld} niveaux/monde`);
                    
                    // G√©n√©rer les niveaux pour chaque monde
                    let levelNumber = 1;
                    
                    for (let worldIdx = 0; worldIdx < autoCreateConfig.numWorlds; worldIdx++) {
                        const worldConfig = autoCreateConfig.worlds[worldIdx];
                        console.log(`\n=== G√©n√©ration Monde ${worldIdx + 1} ===`);
                        
                        // G√©n√©rer les niveaux de difficult√© 1
                        console.log(`G√©n√©ration de ${worldConfig.difficulty1} niveaux en difficult√© 1...`);
                        for (let i = 0; i < worldConfig.difficulty1; i++) {
                            console.log(`  Niveau ${levelNumber} (D1)...`);
                            await generateLevel(cursus, levelNumber, 1);
                            levelNumber++;
                            totalLevelsCreated++;
                        }
                        
                        // G√©n√©rer les niveaux de difficult√© 2
                        console.log(`G√©n√©ration de ${worldConfig.difficulty2} niveaux en difficult√© 2...`);
                        for (let i = 0; i < worldConfig.difficulty2; i++) {
                            console.log(`  Niveau ${levelNumber} (D2)...`);
                            await generateLevel(cursus, levelNumber, 2);
                            levelNumber++;
                            totalLevelsCreated++;
                        }
                        
                        // G√©n√©rer les niveaux de difficult√© 3
                        console.log(`G√©n√©ration de ${worldConfig.difficulty3} niveaux en difficult√© 3...`);
                        for (let i = 0; i < worldConfig.difficulty3; i++) {
                            console.log(`  Niveau ${levelNumber} (D3)...`);
                            await generateLevel(cursus, levelNumber, 3);
                            levelNumber++;
                            totalLevelsCreated++;
                        }
                    }
                }
                
                console.log('\nSauvegarde...');
                // Sauvegarder
                saveToStorage();
                markAsModified(); // Marquer qu'il y a eu des modifications
                
                console.log('Fermeture des popups et rechargement...');
                // Fermer les popups et recharger
                const progressElement = document.getElementById('progress-message');
                if (progressElement) {
                    document.body.removeChild(progressElement);
                }
                closeAutoCreateModal();
                closeLevelManagerModal();
                loadTeacherLevels();
                
                console.log('=== G√âN√âRATION TERMIN√âE ===');
                console.log(`${totalLevelsCreated} niveaux cr√©√©s`);
                
            } catch (error) {
                console.error('ERREUR lors de la g√©n√©ration:', error);
                const progressElement = document.getElementById('progress-message');
                if (progressElement) {
                    document.body.removeChild(progressElement);
                }
                alert('‚ùå Erreur lors de la g√©n√©ration: ' + error.message);
                console.error(error);
            }
        }
        
        async function generateLevel(cursus, levelNumber, difficulty) {
            // Simuler un petit d√©lai pour ne pas bloquer l'interface
            await new Promise(resolve => setTimeout(resolve, 10));
            
            console.log(`G√©n√©ration du niveau ${levelNumber} en difficult√© ${difficulty} pour ${cursus}`);
            
            // Sauvegarder l'√©tat actuel
            const savedPaintedCells = { ...paintedCells };
            const savedSelectedPattern = selectedPattern;
            const savedDifficulty = document.getElementById('generation-difficulty').value;
            const savedCreatedVariables = [...createdVariables];
            const savedVariables = { ...variables };
            
            try {
                // Nettoyer compl√®tement l'√©tat
                paintedCells = {};
                createdVariables = [];
                variables = {};
                clearProgram();
                
                // Ajouter de l'al√©atoire bas√© sur le cursus pour avoir des motifs diff√©rents
                // Chaque cursus aura une "seed" diff√©rente bas√©e sur son nom
                const cursusSeeds = { '5eme': 17, '4eme': 37, '3eme': 53 };
                const seed = cursusSeeds[cursus] || 1;
                
                // G√©n√©rer des appels al√©atoires pour d√©caler la s√©quence Math.random()
                // Cela fait que chaque cursus aura des motifs diff√©rents
                for (let i = 0; i < seed + levelNumber; i++) {
                    Math.random();
                }
                
                // Mettre la difficult√© dans le select pour que generateRandomPattern l'utilise
                document.getElementById('generation-difficulty').value = difficulty;
                
                // Appeler directement la fonction de g√©n√©ration automatique du mode pinceau
                generateRandomPattern();
                
                // Attendre plus longtemps pour la difficult√© 3 car elle a un setTimeout interne
                const waitTime = difficulty === 3 ? 250 : 100;
                await new Promise(resolve => setTimeout(resolve, waitTime));
                
                // R√©cup√©rer les blocs cr√©√©s
                const programBlocks = document.getElementById('program-blocks');
                const blocks = programBlocks.querySelectorAll(':scope > .program-block');
                
                if (blocks.length === 0) {
                    console.error('Aucun bloc g√©n√©r√©, nouvel essai...');
                    // Attendre encore un peu et r√©essayer
                    await new Promise(resolve => setTimeout(resolve, 200));
                    const blocksRetry = programBlocks.querySelectorAll(':scope > .program-block');
                    if (blocksRetry.length === 0) {
                        throw new Error('Aucun bloc g√©n√©r√© m√™me apr√®s 2 tentatives');
                    }
                }
                
                const finalBlocks = programBlocks.querySelectorAll(':scope > .program-block');
                const savedBlocks = [];
                finalBlocks.forEach(block => {
                    const blockData = extractBlockData(block);
                    savedBlocks.push(blockData);
                });
                
                console.log(`${savedBlocks.length} blocs extraits`);
                
                // Sauvegarder l'√©tat de la grille et les cellules peintes
                const gridState = getGridState();
                const paintedCellsData = getPaintedCellsData();
                
                // Sauvegarder aussi les variables cr√©√©es
                const savedVars = {
                    createdVariables: [...createdVariables],
                    variableValues: { ...variables }
                };
                
                // Cr√©er le niveau
                const newLevel = {
                    blocks: savedBlocks,
                    blockCount: countTotalBlocks(finalBlocks),
                    gridState: gridState,
                    paintedCells: paintedCellsData,
                    variables: savedVars
                };
                
                console.log(`Niveau cr√©√© avec ${newLevel.blockCount} blocs, variables:`, savedVars.createdVariables);
                
                cursusData[cursus].levels[levelNumber.toString()] = newLevel;
                
            } catch (error) {
                console.error(`Erreur lors de la g√©n√©ration du niveau ${levelNumber}:`, error);
                throw error;
            } finally {
                // Restaurer l'√©tat
                paintedCells = savedPaintedCells;
                selectedPattern = savedSelectedPattern;
                document.getElementById('generation-difficulty').value = savedDifficulty;
                createdVariables = savedCreatedVariables;
                variables = savedVariables;
            }
        }
        
        function closeAutoCreateModal() {
            document.getElementById('auto-create-modal').classList.remove('active');
            autoCreateConfig = null;
        }
        
        // ===== MODULE PINCEAU =====
        function selectPaintColor(color) {
            selectedPaintColor = color;
            
            // Mettre √† jour visuellement la s√©lection
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.querySelector(`.color-option[data-color="${color}"]`).classList.add('selected');
        }
        
        // G√©rer le changement de difficult√©
        function handleDifficultyChange() {
            const difficulty = parseInt(document.getElementById('generation-difficulty').value);
            const colorPickerSection = document.getElementById('color-picker-section');
            const patternPickerSection = document.getElementById('pattern-picker-section');
            const teacherGrid = document.getElementById('teacher-grid');
            
            if (difficulty === 3) {
                // Afficher les motifs g√©om√©triques, masquer les couleurs
                colorPickerSection.style.display = 'none';
                patternPickerSection.style.display = 'flex';
                
                // D√âSACTIVER le pinceau en difficult√© 3
                if (teacherGrid) {
                    teacherGrid.style.cursor = 'default';
                    // Retirer tous les √©v√©nements de peinture
                    teacherGrid.removeEventListener('mousedown', startPainting);
                    teacherGrid.removeEventListener('mouseup', stopPainting);
                    teacherGrid.removeEventListener('mouseleave', stopPainting);
                    teacherGrid.removeEventListener('touchstart', handleTouchStart);
                    teacherGrid.removeEventListener('touchend', handleTouchEnd);
                    teacherGrid.removeEventListener('touchmove', handleTouchMove);
                    
                    // Retirer les √©v√©nements sur les cellules individuelles
                    const cells = teacherGrid.querySelectorAll('.grid-cell');
                    cells.forEach(cell => {
                        // Retirer les √©v√©nements attach√©s avec on...
                        cell.onmousedown = null;
                        cell.onmouseenter = null;
                        cell.oncontextmenu = null;
                        // Retirer la classe paintable
                        cell.classList.remove('paintable');
                        // Remettre le curseur normal
                        cell.style.cursor = 'default';
                    });
                    
                    console.log('Pinceau d√©sactiv√© en difficult√© 3');
                }
            } else {
                // Afficher les couleurs, masquer les motifs
                colorPickerSection.style.display = 'flex';
                patternPickerSection.style.display = 'none';
                
                // R√âACTIVER le pinceau pour difficult√© 1 et 2
                if (teacherGrid) {
                    initPaintMode();
                }
            }
        }
        
        // Variable pour stocker le motif s√©lectionn√©
        let selectedPattern = null;
        
        // S√©lectionner un motif g√©om√©trique
        function selectPattern(pattern) {
            selectedPattern = pattern;
            
            // Mettre √† jour visuellement la s√©lection
            document.querySelectorAll('.pattern-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.querySelector(`.pattern-option[data-pattern="${pattern}"]`).classList.add('selected');
            
            console.log('Motif s√©lectionn√©:', pattern);
        }
        
        function initPaintMode() {
            const teacherGrid = document.getElementById('teacher-grid');
            if (!teacherGrid) {
                console.log("Grille teacher non trouv√©e");
                return;
            }
            
            // Ne pas activer le pinceau en difficult√© 3
            const difficultySelect = document.getElementById('generation-difficulty');
            if (difficultySelect && parseInt(difficultySelect.value) === 3) {
                console.log("Pinceau d√©sactiv√© en difficult√© 3");
                return;
            }
            
            // S√©lectionner la couleur rouge par d√©faut
            selectPaintColor('red');
            
            // Retirer les anciens √©v√©nements s'ils existent
            teacherGrid.removeEventListener('mousedown', startPainting);
            teacherGrid.removeEventListener('mouseup', stopPainting);
            teacherGrid.removeEventListener('mouseleave', stopPainting);
            
            // Ajouter les √©v√©nements de peinture √† la grille
            teacherGrid.addEventListener('mousedown', startPainting);
            teacherGrid.addEventListener('mouseup', stopPainting);
            teacherGrid.addEventListener('mouseleave', stopPainting);
            
            // === SUPPORT TACTILE GLOBAL ===
            teacherGrid.addEventListener('touchstart', function(e) {
                e.preventDefault();
                isPainting = true;
            }, { passive: false });
            
            teacherGrid.addEventListener('touchend', function(e) {
                e.preventDefault();
                isPainting = false;
            }, { passive: false });
            
            teacherGrid.addEventListener('touchcancel', function(e) {
                isPainting = false;
            }, { passive: false });
            
            // G√©rer le glissement du doigt pour peindre plusieurs cellules
            teacherGrid.addEventListener('touchmove', function(e) {
                e.preventDefault(); // CRUCIAL : Emp√™che le scroll
                if (isPainting) {
                    const touch = e.touches[0];
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (element && element.classList.contains('grid-cell')) {
                        const cells = Array.from(teacherGrid.querySelectorAll('.grid-cell'));
                        const index = cells.indexOf(element);
                        if (index !== -1) {
                            paintCellManually(element, index);
                        }
                    }
                }
            }, { passive: false });
            
            // Ajouter les classes et √©v√©nements aux cellules
            const cells = teacherGrid.querySelectorAll('.grid-cell');
            console.log(`Initialisation de ${cells.length} cellules pour le mode peinture`);
            
            cells.forEach((cell, index) => {
                cell.classList.add('paintable');
                
                // Utiliser une nouvelle approche avec des fonctions nomm√©es pour pouvoir les retirer
                cell.onmousedown = function(e) {
                    e.preventDefault();
                    // Ne d√©clencher la peinture que pour le clic gauche (button = 0)
                    if (e.button === 0) {
                        isPainting = true;
                        paintCellManually(cell, index);
                    }
                };
                
                // === SUPPORT TACTILE POUR LE MODE PAINT ===
                // On laisse touchstart peindre la cellule mais on ne stoppe PAS la propagation
                // pour que touchmove de la grille puisse fonctionner
                cell.addEventListener('touchstart', function(e) {
                    e.preventDefault(); // CRUCIAL : Emp√™che le scroll
                    // Ne PAS utiliser stopPropagation ici !
                    isPainting = true;
                    paintCellManually(cell, index);
                }, { passive: false }); // passive: false permet preventDefault
                
                // G√©rer le clic droit pour effacer
                cell.oncontextmenu = function(e) {
                    e.preventDefault(); // Emp√™cher le menu contextuel
                    const row = Math.floor(index / GRID_SIZE);
                    const col = index % GRID_SIZE;
                    const cellKey = `${row}-${col}`;
                    
                    // Effacer la cellule si elle est peinte
                    if (paintedCells[cellKey]) {
                        cell.style.backgroundColor = 'white';
                        delete paintedCells[cellKey];
                        console.log(`Cellule ${cellKey} effac√©e par clic droit`);
                    }
                    
                    return false;
                };
                
                cell.onmouseenter = function(e) {
                    // Effacer si clic droit maintenu (button = 2)
                    if (e.buttons === 2) {
                        const row = Math.floor(index / GRID_SIZE);
                        const col = index % GRID_SIZE;
                        const cellKey = `${row}-${col}`;
                        
                        if (paintedCells[cellKey]) {
                            cell.style.backgroundColor = 'white';
                            delete paintedCells[cellKey];
                            console.log(`Cellule ${cellKey} effac√©e par glissement clic droit`);
                        }
                    }
                    // Peindre si clic gauche maintenu (button = 1)
                    else if (isPainting && e.buttons === 1) {
                        paintCellManually(cell, index);
                    }
                };
            });
        }
        
        function startPainting(e) {
            isPainting = true;
        }
        
        function stopPainting() {
            isPainting = false;
        }
        
        function paintCellManually(cell, index) {
            // BLOQUER la peinture en difficult√© 3
            const difficultySelect = document.getElementById('generation-difficulty');
            if (difficultySelect && parseInt(difficultySelect.value) === 3) {
                console.log("Peinture bloqu√©e : difficult√© 3 active");
                return; // Ne rien faire
            }
            
            const row = Math.floor(index / GRID_SIZE);
            const col = index % GRID_SIZE;
            const cellKey = `${row}-${col}`;
            
            console.log(`Peinture cellule ${cellKey} avec couleur ${selectedPaintColor}`);
            
            if (selectedPaintColor === 'white') {
                // Effacer la cellule
                cell.style.backgroundColor = 'white';
                delete paintedCells[cellKey];
            } else {
                // Peindre la cellule - utiliser les m√™mes couleurs que dans le reste de l'app
                const colorMap = {
                    'red': '#dc3545',
                    'yellow': '#ffc107',
                    'green': '#28a745',
                    'blue': '#007bff',
                    'black': '#343a40'
                };
                cell.style.backgroundColor = colorMap[selectedPaintColor];
                paintedCells[cellKey] = selectedPaintColor;
            }
            
            console.log("Cellules peintes actuelles:", paintedCells);
        }
        
        // G√©n√©rer un motif al√©atoire automatiquement
        function generateRandomPattern() {
            console.log("=== G√©n√©ration automatique d'un motif al√©atoire ===");
            
            // R√©cup√©rer la difficult√© actuellement s√©lectionn√©e
            const difficulty = parseInt(document.getElementById('generation-difficulty').value);
            console.log("Difficult√© s√©lectionn√©e:", difficulty);
            
            if (difficulty === 3) {
                // DIFFICULT√â 3: G√©n√©rer un motif g√©om√©trique
                
                // Choisir un motif au hasard parmi tous les motifs disponibles
                const availablePatterns = ['square', 'spiral', 'zigzag', 'stairs', 'checkerboard', 'cross'];
                const randomPattern = availablePatterns[Math.floor(Math.random() * availablePatterns.length)];
                console.log('Motif al√©atoire s√©lectionn√©:', randomPattern);
                
                // S√©lectionner visuellement le motif
                selectedPattern = randomPattern;
                
                // Mettre √† jour l'interface pour montrer la s√©lection
                document.querySelectorAll('.pattern-option').forEach(option => {
                    option.classList.remove('selected');
                    if (option.getAttribute('data-pattern') === randomPattern) {
                        option.classList.add('selected');
                    }
                });
                
                // Nettoyer le programme existant
                clearProgram();
                
                // G√©n√©rer le motif choisi
                if (randomPattern === 'square') {
                    generateSquareProgram();
                } else if (randomPattern === 'spiral') {
                    generateSpiralProgram();
                } else if (randomPattern === 'zigzag') {
                    generateZigzagProgram();
                } else if (randomPattern === 'stairs') {
                    generateStairsProgram();
                } else if (randomPattern === 'checkerboard') {
                    generateCheckerboardProgram();
                } else if (randomPattern === 'cross') {
                    generateCrossProgram();
                }
                
                // Ex√©cuter automatiquement le programme pour afficher le motif
                setTimeout(() => executeProgram(), 100);
                
            } else {
                // DIFFICULT√âS 1 ET 2: G√©n√©rer un motif al√©atoire en peignant des cellules
                
                // Effacer toutes les cellules peintes existantes
                paintedCells = {};
                const teacherGrid = document.getElementById('teacher-grid');
                const cells = teacherGrid.querySelectorAll('.cell');
                cells.forEach(cell => {
                    cell.style.backgroundColor = 'white';
                });
                
                // Couleurs disponibles (limit√© √† 3 couleurs maximum)
                const allColors = ['red', 'yellow', 'green', 'blue', 'black'];
                const colorMap = {
                    'red': '#dc3545',
                    'yellow': '#ffc107',
                    'green': '#28a745',
                    'blue': '#007bff',
                    'black': '#343a40'
                };
                
                // Choisir 1 √† 3 couleurs al√©atoires
                const numColors = Math.floor(Math.random() * 3) + 1; // 1 √† 3
                const shuffledColors = [...allColors].sort(() => Math.random() - 0.5);
                const colors = shuffledColors.slice(0, numColors);
                console.log("Couleurs s√©lectionn√©es:", colors);
                
                const gridSize = 10; // Taille de la grille 10x10
                
                // Utiliser la biblioth√®que de motifs externe
                const shapeTypes = PATTERNS.difficulty1_2.ids;
                const shapeType = shapeTypes[Math.floor(Math.random() * shapeTypes.length)];
                console.log("Type de forme:", shapeType);
                
                // G√©n√©rer le motif en utilisant la biblioth√®que externe
                const paintedPositions = PATTERNS.difficulty1_2.generators[shapeType](gridSize);
                
                console.log("Nombre de cellules g√©n√©r√©es:", paintedPositions.length);
                
                // Colorier les cellules avec des couleurs (utiliser les couleurs de mani√®re r√©p√©titive)
                paintedPositions.forEach((pos, index) => {
                    const posKey = `${pos.row}-${pos.col}`;
                    // Si plusieurs couleurs, les alterner de mani√®re pr√©visible
                    const colorIndex = index % colors.length;
                    const color = colors[colorIndex];
                    paintedCells[posKey] = color;
                    
                    // Appliquer visuellement
                    const cellIndex = pos.row * gridSize + pos.col;
                    if (cellIndex < cells.length) {
                        const cell = cells[cellIndex];
                        if (cell) {
                            cell.style.backgroundColor = colorMap[color];
                        } else {
                            console.warn("Cellule non trouv√©e √† l'index:", cellIndex);
                        }
                    }
                });
                
                console.log("Motif al√©atoire peint:", Object.keys(paintedCells).length, "cellules");
                
                // G√©n√©rer automatiquement le programme
                generateProgramFromPaint();
            }
        }
        
        // G√©n√©rer un programme √† partir des cellules peintes
        function generateProgramFromPaint() {
            // R√©cup√©rer la difficult√© s√©lectionn√©e
            const difficulty = parseInt(document.getElementById('generation-difficulty').value);
            
            // Pour la difficult√© 3, pas besoin de cellules peintes
            if (difficulty === 3) {
                if (!selectedPattern) {
                    showResult('‚ùå Veuillez s√©lectionner un motif g√©om√©trique !', false);
                    return;
                }
                
                // Nettoyer le programme existant
                clearProgram();
                
                // G√©n√©rer le programme selon le motif s√©lectionn√©
                if (selectedPattern === 'square') {
                    generateSquareProgram();
                    // Ex√©cuter automatiquement le programme pour afficher le motif
                    setTimeout(() => executeProgram(), 100);
                } else if (selectedPattern === 'spiral') {
                    generateSpiralProgram();
                    // Ex√©cuter automatiquement le programme pour afficher le motif
                    setTimeout(() => executeProgram(), 100);
                } else if (selectedPattern === 'zigzag') {
                    generateZigzagProgram();
                    // Ex√©cuter automatiquement le programme pour afficher le motif
                    setTimeout(() => executeProgram(), 100);
                } else if (selectedPattern === 'stairs') {
                    generateStairsProgram();
                    // Ex√©cuter automatiquement le programme pour afficher le motif
                    setTimeout(() => executeProgram(), 100);
                } else if (selectedPattern === 'checkerboard') {
                    generateCheckerboardProgram();
                    // Ex√©cuter automatiquement le programme pour afficher le motif
                    setTimeout(() => executeProgram(), 100);
                } else if (selectedPattern === 'cross') {
                    generateCrossProgram();
                    // Ex√©cuter automatiquement le programme pour afficher le motif
                    setTimeout(() => executeProgram(), 100);
                } else {
                    console.log('G√©n√©ration du motif:', selectedPattern);
                    showResult(`üé® Motif "${selectedPattern}" - G√©n√©ration √† venir !`, true);
                }
                return;
            }
            
            // Pour difficult√©s 1 et 2, v√©rifier qu'il y a des cellules peintes
            if (Object.keys(paintedCells).length === 0) {
                showResult('‚ùå Aucune cellule peinte ! Utilisez le pinceau pour colorier la grille.', false);
                return;
            }
            
            // Nettoyer le programme existant
            clearProgram();
            
            // Convertir paintedCells en tableau
            const cellsArray = [];
            const usedColors = new Set();
            for (let [cellKey, color] of Object.entries(paintedCells)) {
                const [row, col] = cellKey.split('-').map(Number);
                cellsArray.push({ row, col, color });
                usedColors.add(color);
            }
            
            // Pas de limite sur le nombre de couleurs
            
            // V√©rifier le nombre de cellules (max 40)
            if (cellsArray.length > 40) {
                showResult(`‚ùå Trop de cellules ! Limite √† 40 blocs maximum (actuellement ${cellsArray.length} cellules).`, false);
                return;
            }
            
            // OPTIMISATION 1: Trier par proximit√© (algorithme du plus proche voisin)
            const optimizedPath = optimizePath(cellsArray);
            
            console.log("Chemin optimis√©:", optimizedPath);
            
            // G√©n√©rer le programme de base (difficult√© 1)
            const basicProgram = generateBasicProgram(optimizedPath);
            
            if (difficulty === 1) {
                // Difficult√© 1 : Programme basique
                addProgramBlocks(basicProgram);
                showResult(`‚úÖ Programme cr√©√© (Difficult√© 1) avec ${optimizedPath.length} bloc(s) de couleur !`, true);
                // Ex√©cuter automatiquement le programme pour afficher le motif
                setTimeout(() => executeProgram(), 100);
            } else if (difficulty === 2) {
                // Difficult√© 2 : Programme optimis√© avec boucles simples
                const optimizedProgram = optimizeWithLoops(basicProgram);
                addProgramBlocks(optimizedProgram);
                const loopCount = countLoops(optimizedProgram);
                showResult(`‚úÖ Programme optimis√© (Difficult√© 2) avec ${loopCount} boucle(s) !`, true);
                // Ex√©cuter automatiquement le programme pour afficher le motif
                setTimeout(() => executeProgram(), 100);
            }
        }
        
        // Fonction pour g√©n√©rer le d√©placement initial optimis√©
        function generateInitialMovement(deltaRow, deltaCol) {
            console.log("=== G√©n√©ration du d√©placement initial ===");
            console.log("Position de d√©part: (9, 5), orientation: HAUT");
            console.log("deltaRow:", deltaRow, "(n√©gatif=monter, positif=descendre)");
            console.log("deltaCol:", deltaCol, "(n√©gatif=gauche, positif=droite)");
            
            // La tortue commence orient√©e vers le HAUT (en haut de la grille)
            // Position de d√©part: ligne 9 (en bas), colonne 5 (au centre)
            
            // √âTAPE 1: D√©placement HORIZONTAL (gauche/droite)
            if (deltaCol !== 0) {
                const absCol = Math.abs(deltaCol);
                
                // Tourner dans la bonne direction
                if (deltaCol > 0) {
                    // Aller √† DROITE: tourner √† droite
                    const turnRightHTML = '<div class="block motion" data-type="right">tourner ‚Üª droite</div>';
                    addBlockToProgram({ type: 'right', html: turnRightHTML });
                    console.log("‚úì Tourner droite (pour aller √† droite)");
                } else {
                    // Aller √† GAUCHE: tourner √† gauche
                    const turnLeftHTML = '<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>';
                    addBlockToProgram({ type: 'left', html: turnLeftHTML });
                    console.log("‚úì Tourner gauche (pour aller √† gauche)");
                }
                
                // Avancer horizontalement
                if (absCol > 1) {
                    // Utiliser une boucle (plus de 1 case)
                    const loopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${absCol}" min="1" max="100" onclick="event.stopPropagation()"></span> fois</div>`;
                    addBlockToProgram({ 
                        type: 'repeat',
                        html: loopHTML
                    });
                    
                    // Ajouter "avancer" dans la boucle
                    const programBlocks = document.getElementById('program-blocks');
                    const loopBlock = programBlocks.lastElementChild;
                    const nestedArea = loopBlock.querySelector('.nested-blocks');
                    
                    const forwardWrapper = document.createElement('div');
                    forwardWrapper.className = 'program-block';
                    forwardWrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
                    const forwardBlock = forwardWrapper.querySelector('.block');
                    const forwardRemoveBtn = document.createElement('button');
                    forwardRemoveBtn.className = 'remove-btn';
                    forwardRemoveBtn.innerHTML = '√ó';
                    forwardRemoveBtn.onclick = function() { forwardWrapper.remove(); updateBlockCount(); };
                    forwardBlock.appendChild(forwardRemoveBtn);
                    nestedArea.appendChild(forwardWrapper);
                    nestedArea.classList.remove('empty');
                    
                    console.log(`‚úì Boucle r√©p√©ter ${absCol} fois avancer (horizontal)`);
                } else {
                    // 1 seule case: un seul bloc avancer
                    const forwardHTML = '<div class="block motion" data-type="forward">avancer</div>';
                    addBlockToProgram({ type: 'forward', html: forwardHTML });
                    console.log("‚úì 1 bloc avancer (horizontal)");
                }
            }
            
            // √âTAPE 2: Se r√©orienter vers le HAUT ou le BAS selon le besoin vertical
            if (deltaRow !== 0) {
                if (deltaCol !== 0) {
                    // On vient de se d√©placer horizontalement, il faut se r√©orienter
                    if (deltaRow < 0) {
                        // On doit MONTER: se tourner vers le haut
                        if (deltaCol > 0) {
                            // On √©tait orient√© √† droite, tourner √† gauche pour regarder vers le haut
                            const turnLeftHTML = '<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>';
                            addBlockToProgram({ type: 'left', html: turnLeftHTML });
                            console.log("‚úì Tourner gauche (r√©orientation vers le haut)");
                        } else {
                            // On √©tait orient√© √† gauche, tourner √† droite pour regarder vers le haut
                            const turnRightHTML = '<div class="block motion" data-type="right">tourner ‚Üª droite</div>';
                            addBlockToProgram({ type: 'right', html: turnRightHTML });
                            console.log("‚úì Tourner droite (r√©orientation vers le haut)");
                        }
                    } else {
                        // On doit DESCENDRE: se tourner vers le bas
                        if (deltaCol > 0) {
                            // On √©tait orient√© √† droite, tourner √† droite pour regarder vers le bas
                            const turnRightHTML = '<div class="block motion" data-type="right">tourner ‚Üª droite</div>';
                            addBlockToProgram({ type: 'right', html: turnRightHTML });
                            console.log("‚úì Tourner droite (r√©orientation vers le bas)");
                        } else {
                            // On √©tait orient√© √† gauche, tourner √† gauche pour regarder vers le bas
                            const turnLeftHTML = '<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>';
                            addBlockToProgram({ type: 'left', html: turnLeftHTML });
                            console.log("‚úì Tourner gauche (r√©orientation vers le bas)");
                        }
                    }
                } else {
                    // Pas de d√©placement horizontal, on est d√©j√† orient√© vers le haut
                    if (deltaRow > 0) {
                        // On doit descendre, faire demi-tour
                        const turnRightHTML1 = '<div class="block motion" data-type="right">tourner ‚Üª droite</div>';
                        addBlockToProgram({ type: 'right', html: turnRightHTML1 });
                        const turnRightHTML2 = '<div class="block motion" data-type="right">tourner ‚Üª droite</div>';
                        addBlockToProgram({ type: 'right', html: turnRightHTML2 });
                        console.log("‚úì Demi-tour (2√ó tourner droite pour descendre)");
                    }
                    // Sinon on monte, on est d√©j√† bien orient√©
                }
                
                // √âTAPE 3: D√©placement VERTICAL
                const absRow = Math.abs(deltaRow);
                
                if (absRow > 1) {
                    // Utiliser une boucle (plus de 1 case)
                    const loopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${absRow}" min="1" max="100" onclick="event.stopPropagation()"></span> fois</div>`;
                    addBlockToProgram({ 
                        type: 'repeat',
                        html: loopHTML
                    });
                    
                    // Ajouter "avancer" dans la boucle
                    const programBlocks = document.getElementById('program-blocks');
                    const loopBlock = programBlocks.lastElementChild;
                    const nestedArea = loopBlock.querySelector('.nested-blocks');
                    
                    const forwardWrapper = document.createElement('div');
                    forwardWrapper.className = 'program-block';
                    forwardWrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
                    const forwardBlock = forwardWrapper.querySelector('.block');
                    const forwardRemoveBtn = document.createElement('button');
                    forwardRemoveBtn.className = 'remove-btn';
                    forwardRemoveBtn.innerHTML = '√ó';
                    forwardRemoveBtn.onclick = function() { forwardWrapper.remove(); updateBlockCount(); };
                    forwardBlock.appendChild(forwardRemoveBtn);
                    nestedArea.appendChild(forwardWrapper);
                    nestedArea.classList.remove('empty');
                    
                    console.log(`‚úì Boucle r√©p√©ter ${absRow} fois avancer (vertical)`);
                } else {
                    // 1 seule case: un seul bloc avancer
                    const forwardHTML = '<div class="block motion" data-type="forward">avancer</div>';
                    addBlockToProgram({ type: 'forward', html: forwardHTML });
                    console.log("‚úì 1 bloc avancer (vertical)");
                }
            }
            
            console.log("=== D√©placement initial termin√© ===");
        }
        
        // Fonction sp√©ciale pour g√©n√©rer le d√©placement initial pour le damier (garantit orientation vers le haut)
        function generateInitialMovementForCheckerboard(deltaRow, deltaCol) {
            console.log("=== G√©n√©ration du d√©placement initial pour damier ===");
            console.log("Position de d√©part: (9, 5), orientation: HAUT");
            console.log("deltaRow:", deltaRow, "(n√©gatif=monter, positif=descendre)");
            console.log("deltaCol:", deltaCol, "(n√©gatif=gauche, positif=droite)");
            
            // La tortue commence orient√©e vers le HAUT
            // On va se d√©placer et finir toujours orient√© vers le HAUT
            
            // √âTAPE 1: D√©placement HORIZONTAL (gauche/droite)
            if (deltaCol !== 0) {
                const absCol = Math.abs(deltaCol);
                
                // Tourner dans la bonne direction
                if (deltaCol > 0) {
                    // Aller √† DROITE
                    const turnRightHTML = '<div class="block motion" data-type="right">tourner ‚Üª droite</div>';
                    addBlockToProgram({ type: 'right', html: turnRightHTML });
                    console.log("‚úì Tourner droite");
                } else {
                    // Aller √† GAUCHE
                    const turnLeftHTML = '<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>';
                    addBlockToProgram({ type: 'left', html: turnLeftHTML });
                    console.log("‚úì Tourner gauche");
                }
                
                // Avancer horizontalement
                if (absCol > 1) {
                    const loopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${absCol}" min="1" max="100" onclick="event.stopPropagation()"></span> fois</div>`;
                    addBlockToProgram({ 
                        type: 'repeat',
                        html: loopHTML
                    });
                    
                    const programBlocks = document.getElementById('program-blocks');
                    const loopBlock = programBlocks.lastElementChild;
                    const nestedArea = loopBlock.querySelector('.nested-blocks');
                    
                    const forwardWrapper = document.createElement('div');
                    forwardWrapper.className = 'program-block';
                    forwardWrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
                    const forwardBlock = forwardWrapper.querySelector('.block');
                    const forwardRemoveBtn = document.createElement('button');
                    forwardRemoveBtn.className = 'remove-btn';
                    forwardRemoveBtn.innerHTML = '√ó';
                    forwardRemoveBtn.onclick = function() { forwardWrapper.remove(); updateBlockCount(); };
                    forwardBlock.appendChild(forwardRemoveBtn);
                    nestedArea.appendChild(forwardWrapper);
                    nestedArea.classList.remove('empty');
                    
                    console.log(`‚úì Boucle r√©p√©ter ${absCol} fois avancer (horizontal)`);
                } else {
                    const forwardHTML = '<div class="block motion" data-type="forward">avancer</div>';
                    addBlockToProgram({ type: 'forward', html: forwardHTML });
                    console.log("‚úì 1 bloc avancer (horizontal)");
                }
                
                // IMPORTANT: Se r√©orienter vers le HAUT apr√®s le d√©placement horizontal
                if (deltaCol > 0) {
                    // On √©tait orient√© √† droite, tourner √† gauche pour regarder vers le haut
                    const turnLeftHTML = '<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>';
                    addBlockToProgram({ type: 'left', html: turnLeftHTML });
                    console.log("‚úì Tourner gauche (r√©orientation vers le haut)");
                } else {
                    // On √©tait orient√© √† gauche, tourner √† droite pour regarder vers le haut
                    const turnRightHTML = '<div class="block motion" data-type="right">tourner ‚Üª droite</div>';
                    addBlockToProgram({ type: 'right', html: turnRightHTML });
                    console.log("‚úì Tourner droite (r√©orientation vers le haut)");
                }
            }
            
            // √âTAPE 2: D√©placement VERTICAL (on est maintenant orient√© vers le haut)
            if (deltaRow !== 0) {
                if (deltaRow > 0) {
                    // On doit DESCENDRE: faire demi-tour
                    const turnRightHTML1 = '<div class="block motion" data-type="right">tourner ‚Üª droite</div>';
                    addBlockToProgram({ type: 'right', html: turnRightHTML1 });
                    const turnRightHTML2 = '<div class="block motion" data-type="right">tourner ‚Üª droite</div>';
                    addBlockToProgram({ type: 'right', html: turnRightHTML2 });
                    console.log("‚úì Demi-tour pour descendre");
                }
                // Sinon on monte, on est d√©j√† bien orient√© vers le haut
                
                const absRow = Math.abs(deltaRow);
                
                if (absRow > 1) {
                    const loopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${absRow}" min="1" max="100" onclick="event.stopPropagation()"></span> fois</div>`;
                    addBlockToProgram({ 
                        type: 'repeat',
                        html: loopHTML
                    });
                    
                    const programBlocks = document.getElementById('program-blocks');
                    const loopBlock = programBlocks.lastElementChild;
                    const nestedArea = loopBlock.querySelector('.nested-blocks');
                    
                    const forwardWrapper = document.createElement('div');
                    forwardWrapper.className = 'program-block';
                    forwardWrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
                    const forwardBlock = forwardWrapper.querySelector('.block');
                    const forwardRemoveBtn = document.createElement('button');
                    forwardRemoveBtn.className = 'remove-btn';
                    forwardRemoveBtn.innerHTML = '√ó';
                    forwardRemoveBtn.onclick = function() { forwardWrapper.remove(); updateBlockCount(); };
                    forwardBlock.appendChild(forwardRemoveBtn);
                    nestedArea.appendChild(forwardWrapper);
                    nestedArea.classList.remove('empty');
                    
                    console.log(`‚úì Boucle r√©p√©ter ${absRow} fois avancer (vertical)`);
                } else {
                    const forwardHTML = '<div class="block motion" data-type="forward">avancer</div>';
                    addBlockToProgram({ type: 'forward', html: forwardHTML });
                    console.log("‚úì 1 bloc avancer (vertical)");
                }
                
                // IMPORTANT: Si on a descendu, faire demi-tour pour revenir orient√© vers le haut
                if (deltaRow > 0) {
                    const turnRightHTML1 = '<div class="block motion" data-type="right">tourner ‚Üª droite</div>';
                    addBlockToProgram({ type: 'right', html: turnRightHTML1 });
                    const turnRightHTML2 = '<div class="block motion" data-type="right">tourner ‚Üª droite</div>';
                    addBlockToProgram({ type: 'right', html: turnRightHTML2 });
                    console.log("‚úì Demi-tour pour se r√©orienter vers le haut");
                }
            }
            
            console.log("=== D√©placement initial termin√© (orient√© vers le HAUT) ===");
        }
        
        // G√©n√©rer le programme pour la spirale
        function generateSpiralProgram() {
            console.log("=== G√©n√©ration de la spirale ===");
            
            // G√©n√©rer une valeur al√©atoire pour i entre 3 et 10
            const randomI = Math.floor(Math.random() * 8) + 3; // 3 √† 10 inclus
            console.log("Valeur al√©atoire de i:", randomI);
            
            // Choisir une couleur al√©atoire
            const colors = ['red', 'yellow', 'green', 'blue', 'black'];
            const colorNames = {
                'red': 'ROUGE',
                'yellow': 'JAUNE',
                'green': 'VERT',
                'blue': 'BLEU',
                'black': 'NOIR'
            };
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            const randomColorName = colorNames[randomColor];
            console.log("Couleur al√©atoire:", randomColor, "(" + randomColorName + ")");
            
            // Choisir al√©atoirement le sens de rotation de la spirale
            const clockwise = Math.random() < 0.5; // true = sens horaire (droite), false = sens antihoraire (gauche)
            const initialTurn = clockwise ? 'right' : 'left';
            const initialTurnName = clockwise ? 'droite' : 'gauche';
            const loopTurn = clockwise ? 'left' : 'right'; // Rotation oppos√©e dans la boucle
            const loopTurnName = clockwise ? 'gauche' : 'droite';
            console.log("Sens de rotation:", clockwise ? "Horaire (‚Üí)" : "Antihoraire (‚Üê)");
            
            // G√©n√©rer une position de d√©part al√©atoire sur la grille (10x10)
            // Position de d√©part actuelle : (9, 5) - on va aller ailleurs
            // Pour avoir de la marge pour la spirale, on √©vite les bords
            const targetRow = Math.floor(Math.random() * 6) + 2; // 2 √† 7
            const targetCol = Math.floor(Math.random() * 6) + 2; // 2 √† 7
            console.log("Position cible al√©atoire: ligne", targetRow, "colonne", targetCol);
            
            // Calculer le d√©placement depuis la position de d√©part (9, 5)
            const startRow = 9;
            const startCol = 5;
            const deltaRow = targetRow - startRow; // n√©gatif = monter, positif = descendre
            const deltaCol = targetCol - startCol; // n√©gatif = gauche, positif = droite
            console.log("D√©placement: deltaRow =", deltaRow, ", deltaCol =", deltaCol);
            
            // Ajouter la variable 'i' si elle n'existe pas d√©j√†
            if (!createdVariables.includes('i')) {
                createdVariables.push('i');
                variables['i'] = randomI;
                updateVariableDisplay();
                console.log("Variable 'i' cr√©√©e");
            } else {
                variables['i'] = randomI;
                updateVariableDisplay();
            }
            
            // G√©n√©rer les blocs de d√©placement initial (optimis√©s avec boucles si n√©cessaire)
            generateInitialMovement(deltaRow, deltaCol);
            
            // 1. Cr√©er le bloc "mettre i √† [valeur al√©atoire]"
            const varHTML = `<div class="block variables" data-type="variable">mettre <select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select> √† <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${randomI}" onclick="event.stopPropagation()"></span></div>`;
            addBlockToProgram({ 
                type: 'variable',
                html: varHTML,
                selectValues: ['i']
            });
            console.log("‚úì Bloc variable cr√©√© avec valeur", randomI);
            
            // 2. Cr√©er le bloc "couleur [COULEUR AL√âATOIRE]" pour colorier la premi√®re case
            const firstColorHTML = `<div class="block looks" data-type="color" data-value="${randomColor}">couleur ${randomColorName}</div>`;
            addBlockToProgram({ 
                type: 'color',
                html: firstColorHTML,
                value: randomColor
            });
            console.log("‚úì Bloc couleur initiale cr√©√©:", randomColorName);
            
            // 3. Cr√©er le bloc "tourner [direction al√©atoire]"
            const initialTurnHTML = `<div class="block motion" data-type="${initialTurn}">tourner ${clockwise ? '‚Üª' : '‚Ü∫'} ${initialTurnName}</div>`;
            addBlockToProgram({ 
                type: initialTurn,
                html: initialTurnHTML 
            });
            console.log("‚úì Bloc tourner", initialTurnName, "cr√©√© (rotation initiale)");
            
            // 4. Cr√©er la boucle principale "r√©p√©ter i fois"
            const mainLoopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span> fois</div>`;
            addBlockToProgram({ 
                type: 'repeat',
                html: mainLoopHTML
            });
            console.log("‚úì Boucle principale cr√©√©e");
            
            // R√©cup√©rer la zone imbriqu√©e de la boucle principale et son value-slot
            const programBlocks = document.getElementById('program-blocks');
            const mainLoopBlock = programBlocks.lastElementChild;
            const mainLoopValueSlot = mainLoopBlock.querySelector('.value-slot');
            const mainNestedArea = mainLoopBlock.querySelector('.nested-blocks');
            
            // Cr√©er et ins√©rer le bloc var-value "i" dans le value-slot de la boucle principale
            const mainVarBlock = document.createElement('div');
            mainVarBlock.className = 'block variables';
            mainVarBlock.setAttribute('data-type', 'var-value');
            mainVarBlock.innerHTML = `<select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select>`;
            mainLoopValueSlot.appendChild(mainVarBlock);
            console.log("‚úì Bloc variable i ajout√© √† la boucle principale");
            
            console.log("Zone imbriqu√©e principale:", mainNestedArea);
            
            // 4. Cr√©er la boucle imbriqu√©e "r√©p√©ter i fois"
            const innerLoopWrapper = document.createElement('div');
            innerLoopWrapper.className = 'program-block block-capsule';
            const innerLoopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span> fois</div>`;
            innerLoopWrapper.innerHTML = innerLoopHTML;
            
            // Cr√©er et ins√©rer le bloc var-value "i" dans le value-slot de la boucle imbriqu√©e
            const innerLoopValueSlot = innerLoopWrapper.querySelector('.value-slot');
            const innerVarBlock = document.createElement('div');
            innerVarBlock.className = 'block variables';
            innerVarBlock.setAttribute('data-type', 'var-value');
            innerVarBlock.innerHTML = `<select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select>`;
            innerLoopValueSlot.appendChild(innerVarBlock);
            console.log("‚úì Bloc variable i ajout√© √† la boucle imbriqu√©e");
            
            // Ajouter bouton de suppression √† la boucle imbriqu√©e
            const innerBlock = innerLoopWrapper.querySelector('.block');
            const innerRemoveBtn = document.createElement('button');
            innerRemoveBtn.className = 'remove-btn';
            innerRemoveBtn.innerHTML = '√ó';
            innerRemoveBtn.onclick = function() { innerLoopWrapper.remove(); updateBlockCount(); };
            innerBlock.appendChild(innerRemoveBtn);
            
            // Cr√©er zone imbriqu√©e pour la boucle int√©rieure
            const innerNestedArea = document.createElement('div');
            innerNestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(innerNestedArea);
            innerLoopWrapper.appendChild(innerNestedArea);
            
            // Ajouter le bas de la capsule
            const innerCapsuleBottom = document.createElement('div');
            innerCapsuleBottom.className = 'block-capsule-bottom';
            innerCapsuleBottom.style.background = getComputedStyle(innerBlock).background;
            innerLoopWrapper.appendChild(innerCapsuleBottom);
            
            mainNestedArea.appendChild(innerLoopWrapper);
            mainNestedArea.classList.remove('empty');
            console.log("‚úì Boucle imbriqu√©e cr√©√©e");
            
            // 5. Ajouter "avancer" dans la boucle int√©rieure
            const forwardWrapper = document.createElement('div');
            forwardWrapper.className = 'program-block';
            forwardWrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
            const forwardBlock = forwardWrapper.querySelector('.block');
            const forwardRemoveBtn = document.createElement('button');
            forwardRemoveBtn.className = 'remove-btn';
            forwardRemoveBtn.innerHTML = '√ó';
            forwardRemoveBtn.onclick = function() { forwardWrapper.remove(); updateBlockCount(); };
            forwardBlock.appendChild(forwardRemoveBtn);
            innerNestedArea.appendChild(forwardWrapper);
            console.log("‚úì Bloc avancer cr√©√©");
            
            // 6. Ajouter "couleur [COULEUR AL√âATOIRE]" dans la boucle int√©rieure
            const colorWrapper = document.createElement('div');
            colorWrapper.className = 'program-block';
            colorWrapper.innerHTML = `<div class="block looks" data-type="color" data-value="${randomColor}">couleur ${randomColorName}</div>`;
            const colorBlock = colorWrapper.querySelector('.block');
            const colorRemoveBtn = document.createElement('button');
            colorRemoveBtn.className = 'remove-btn';
            colorRemoveBtn.innerHTML = '√ó';
            colorRemoveBtn.onclick = function() { colorWrapper.remove(); updateBlockCount(); };
            colorBlock.appendChild(colorRemoveBtn);
            innerNestedArea.appendChild(colorWrapper);
            innerNestedArea.classList.remove('empty');
            console.log("‚úì Bloc couleur", randomColorName, "cr√©√©");
            
            // 7. Ajouter "ajouter -1 √† i" dans la boucle principale
            const changeVarWrapper = document.createElement('div');
            changeVarWrapper.className = 'program-block';
            changeVarWrapper.innerHTML = `<div class="block variables" data-type="change-var">ajouter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="-1" onclick="event.stopPropagation()"></span> √† <select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select></div>`;
            const changeVarBlock = changeVarWrapper.querySelector('.block');
            const changeVarRemoveBtn = document.createElement('button');
            changeVarRemoveBtn.className = 'remove-btn';
            changeVarRemoveBtn.innerHTML = '√ó';
            changeVarRemoveBtn.onclick = function() { changeVarWrapper.remove(); updateBlockCount(); };
            changeVarBlock.appendChild(changeVarRemoveBtn);
            mainNestedArea.appendChild(changeVarWrapper);
            console.log("‚úì Bloc ajouter -1 √† i cr√©√©");
            
            // 8. Ajouter "tourner [direction oppos√©e]" dans la boucle principale
            const loopTurnWrapper = document.createElement('div');
            loopTurnWrapper.className = 'program-block';
            loopTurnWrapper.innerHTML = `<div class="block motion" data-type="${loopTurn}">tourner ${clockwise ? '‚Ü∫' : '‚Üª'} ${loopTurnName}</div>`;
            const loopTurnBlock = loopTurnWrapper.querySelector('.block');
            const loopTurnRemoveBtn = document.createElement('button');
            loopTurnRemoveBtn.className = 'remove-btn';
            loopTurnRemoveBtn.innerHTML = '√ó';
            loopTurnRemoveBtn.onclick = function() { loopTurnWrapper.remove(); updateBlockCount(); };
            loopTurnBlock.appendChild(loopTurnRemoveBtn);
            mainNestedArea.appendChild(loopTurnWrapper);
            console.log("‚úì Bloc tourner", loopTurnName, "cr√©√© (rotation dans boucle)");
            
            // Mettre √† jour l'affichage des variables dans toute l'interface
            updateAllVariableSelectors();
            updateVariableBlocksVisibility();
            updateBlockCount();
            
            console.log("=== Programme spirale g√©n√©r√© avec succ√®s ! ===");
            showResult('‚úÖ Programme Spirale g√©n√©r√© avec succ√®s !', true);
        }
        
        // G√©n√©rer le programme pour le zigzag
        function generateZigzagProgram() {
            console.log("=== G√©n√©ration du zigzag ===");
            
            // La valeur initiale de i doit toujours √™tre 1
            const randomI = 1;
            console.log("Valeur de i:", randomI);
            
            // Choisir une couleur al√©atoire
            const colors = ['red', 'yellow', 'green', 'blue', 'black'];
            const colorNames = {
                'red': 'ROUGE',
                'yellow': 'JAUNE',
                'green': 'VERT',
                'blue': 'BLEU',
                'black': 'NOIR'
            };
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            const randomColorName = colorNames[randomColor];
            console.log("Couleur al√©atoire:", randomColor, "(" + randomColorName + ")");
            
            // D√©cider al√©atoirement de l'orientation du zigzag
            // true = horizontal (va vers la droite)
            // false = vertical (va vers la gauche/vers le haut)
            const addInitialTurn = Math.random() < 0.5; // 50% de chances
            console.log("Orientation - Tourner droite au d√©but:", addInitialTurn);
            
            // G√©n√©rer une position adapt√©e selon l'orientation
            let targetRow, targetCol;
            
            if (addInitialTurn) {
                // Zigzag HORIZONTAL (va vers la droite)
                // La fl√®che doit √™tre dans la partie DROITE de la grille
                // Pour avoir de l'espace √† droite, on place la fl√®che √† gauche/centre
                // Colonnes : 1 √† 5 (partie gauche/centre pour avoir de l'espace √† droite)
                // Lignes : 1 √† 8 (√©viter les bords)
                targetCol = Math.floor(Math.random() * 5) + 1; // 1 √† 5
                targetRow = Math.floor(Math.random() * 8) + 1; // 1 √† 8
                console.log("Mode HORIZONTAL: fl√®che plac√©e √† gauche/centre pour aller vers la droite");
            } else {
                // Zigzag VERTICAL (va vers la gauche)
                // La fl√®che ne doit PAS √™tre dans la partie sup√©rieure
                // Lignes : 4 √† 8 (partie basse/milieu, √©viter le haut)
                // Colonnes : 1 √† 8 (√©viter les bords, besoin d'espace √† gauche)
                targetRow = Math.floor(Math.random() * 5) + 4; // 4 √† 8
                targetCol = Math.floor(Math.random() * 8) + 1; // 1 √† 8
                console.log("Mode VERTICAL: fl√®che plac√©e en bas/milieu pour aller vers la gauche");
            }
            
            console.log("Position cible adapt√©e: ligne", targetRow, "colonne", targetCol);
            
            // Calculer les contraintes pour la taille du zigzag
            // Le zigzag se d√©place horizontalement (largeur = loop1 √ó loop2)
            // Sens du zigzag d√©pend de addInitialTurn:
            // - Sans tourner droite: va vers la gauche
            // - Avec tourner droite: va vers la droite
            
            let maxWidth;
            if (addInitialTurn) {
                // Va vers la droite: maxWidth = colonnes disponibles √† droite
                maxWidth = 9 - targetCol;
            } else {
                // Va vers la gauche: maxWidth = colonnes disponibles √† gauche
                maxWidth = targetCol;
            }
            
            console.log("Max width disponible:", maxWidth);
            
            // G√©n√©rer la boucle interne (entre 1 et 3)
            const innerLoop = Math.floor(Math.random() * 3) + 1; // 1 √† 3
            
            // D√©finir la plage pour la boucle externe selon la boucle interne
            let minOuterLoop, maxOuterLoop;
            
            if (innerLoop === 3) {
                // Si innerLoop = 3, outerLoop doit √™tre 3
                minOuterLoop = 3;
                maxOuterLoop = 3;
            } else if (innerLoop === 2) {
                // Si innerLoop = 2, outerLoop entre 3 et 5
                minOuterLoop = 3;
                maxOuterLoop = 5;
            } else { // innerLoop === 1
                // Si innerLoop = 1, outerLoop entre 4 et 10
                minOuterLoop = 4;
                maxOuterLoop = 10;
            }
            
            // V√©rifier que le zigzag ne d√©passe pas le bord
            // largeur_totale = outerLoop √ó innerLoop <= maxWidth
            const absoluteMaxOuterLoop = Math.floor(maxWidth / innerLoop);
            
            // Ajuster maxOuterLoop si n√©cessaire
            if (absoluteMaxOuterLoop < maxOuterLoop) {
                maxOuterLoop = absoluteMaxOuterLoop;
            }
            
            // Si l'espace disponible est insuffisant, r√©duire aussi minOuterLoop
            if (absoluteMaxOuterLoop < minOuterLoop) {
                minOuterLoop = Math.max(2, absoluteMaxOuterLoop); // Au minimum 2 pour avoir un zigzag
            }
            
            // G√©n√©rer outerLoop dans la plage autoris√©e
            let outerLoop;
            if (maxOuterLoop >= minOuterLoop) {
                outerLoop = Math.floor(Math.random() * (maxOuterLoop - minOuterLoop + 1)) + minOuterLoop;
            } else {
                // Pas assez d'espace, utiliser le maximum possible
                outerLoop = Math.max(2, absoluteMaxOuterLoop);
            }
            
            console.log("Boucle interne:", innerLoop, "fois");
            console.log("Boucle externe:", outerLoop, "fois (plage:", minOuterLoop, "-", maxOuterLoop + ")");
            console.log("Largeur totale du zigzag:", outerLoop * innerLoop, "cases (max:", maxWidth + ")");
            
            // Calculer le d√©placement depuis la position de d√©part (9, 5)
            const startRow = 9;
            const startCol = 5;
            const deltaRow = targetRow - startRow;
            const deltaCol = targetCol - startCol;
            console.log("D√©placement: deltaRow =", deltaRow, ", deltaCol =", deltaCol);
            
            // Ajouter la variable 'i' si elle n'existe pas d√©j√†
            if (!createdVariables.includes('i')) {
                createdVariables.push('i');
                variables['i'] = randomI;
                updateVariableDisplay();
                console.log("Variable 'i' cr√©√©e");
            } else {
                variables['i'] = randomI;
                updateVariableDisplay();
            }
            
            // G√©n√©rer les blocs de d√©placement initial avec garantie d'orientation vers le haut
            generateInitialMovementForCheckerboard(deltaRow, deltaCol);
            
            // 1. Cr√©er le bloc "mettre i √† 1"
            const varHTML = `<div class="block variables" data-type="variable">mettre <select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select> √† <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${randomI}" onclick="event.stopPropagation()"></span></div>`;
            addBlockToProgram({ 
                type: 'variable',
                html: varHTML,
                selectValues: ['i']
            });
            console.log("‚úì Bloc variable cr√©√© avec valeur", randomI);
            
            // 2. Optionnellement ajouter "tourner droite" au d√©but
            if (addInitialTurn) {
                const initialTurnHTML = `<div class="block motion" data-type="right">tourner ‚Üª droite</div>`;
                addBlockToProgram({ 
                    type: 'right',
                    html: initialTurnHTML 
                });
                console.log("‚úì Bloc tourner droite ajout√© au d√©but");
            }
            
            // 3. Cr√©er la premi√®re boucle "r√©p√©ter [outerLoop] fois"
            const outerLoopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${outerLoop}" onclick="event.stopPropagation()"></span> fois</div>`;
            addBlockToProgram({ 
                type: 'repeat',
                html: outerLoopHTML
            });
            console.log("‚úì Boucle externe cr√©√©e (" + outerLoop + " fois)");
            
            const programBlocks = document.getElementById('program-blocks');
            const outerLoopBlock = programBlocks.lastElementChild;
            const outerNestedArea = outerLoopBlock.querySelector('.nested-blocks');
            
            // 4. Cr√©er la deuxi√®me boucle "r√©p√©ter [innerLoop] fois" dans la premi√®re
            const innerLoopWrapper = document.createElement('div');
            innerLoopWrapper.className = 'program-block block-capsule';
            const innerLoopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${innerLoop}" onclick="event.stopPropagation()"></span> fois</div>`;
            innerLoopWrapper.innerHTML = innerLoopHTML;
            
            const innerLoopBlock = innerLoopWrapper.querySelector('.block');
            const innerLoopRemoveBtn = document.createElement('button');
            innerLoopRemoveBtn.className = 'remove-btn';
            innerLoopRemoveBtn.innerHTML = '√ó';
            innerLoopRemoveBtn.onclick = function() { innerLoopWrapper.remove(); updateBlockCount(); };
            innerLoopBlock.appendChild(innerLoopRemoveBtn);
            
            const innerNestedArea = document.createElement('div');
            innerNestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(innerNestedArea);
            innerLoopWrapper.appendChild(innerNestedArea);
            
            const innerCapsuleBottom = document.createElement('div');
            innerCapsuleBottom.className = 'block-capsule-bottom';
            innerCapsuleBottom.style.background = getComputedStyle(innerLoopBlock).background;
            innerLoopWrapper.appendChild(innerCapsuleBottom);
            
            outerNestedArea.appendChild(innerLoopWrapper);
            outerNestedArea.classList.remove('empty');
            console.log("‚úì Boucle interne cr√©√©e (" + innerLoop + " fois)");
            
            // 5. Ajouter "couleur" dans la boucle interne
            const colorWrapper = document.createElement('div');
            colorWrapper.className = 'program-block';
            colorWrapper.innerHTML = `<div class="block looks" data-type="color" data-value="${randomColor}">couleur ${randomColorName}</div>`;
            const colorBlock = colorWrapper.querySelector('.block');
            const colorRemoveBtn = document.createElement('button');
            colorRemoveBtn.className = 'remove-btn';
            colorRemoveBtn.innerHTML = '√ó';
            colorRemoveBtn.onclick = function() { colorWrapper.remove(); updateBlockCount(); };
            colorBlock.appendChild(colorRemoveBtn);
            innerNestedArea.appendChild(colorWrapper);
            innerNestedArea.classList.remove('empty');
            console.log("‚úì Bloc couleur", randomColorName, "cr√©√©");
            
            // 6. Ajouter "avancer" dans la boucle interne
            const forwardWrapper = document.createElement('div');
            forwardWrapper.className = 'program-block';
            forwardWrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
            const forwardBlock = forwardWrapper.querySelector('.block');
            const forwardRemoveBtn = document.createElement('button');
            forwardRemoveBtn.className = 'remove-btn';
            forwardRemoveBtn.innerHTML = '√ó';
            forwardRemoveBtn.onclick = function() { forwardWrapper.remove(); updateBlockCount(); };
            forwardBlock.appendChild(forwardRemoveBtn);
            innerNestedArea.appendChild(forwardWrapper);
            console.log("‚úì Bloc avancer cr√©√©");
            
            // 7. Premi√®re condition "si i = 1 alors"
            const if1Wrapper = document.createElement('div');
            if1Wrapper.className = 'program-block block-capsule';
            if1Wrapper.innerHTML = `<div class="block sensing" data-type="if">si <select class="var-select" onclick="event.stopPropagation()"><option value="i" selected>i</option></select> <select class="compare-op" onclick="event.stopPropagation()"><option value="=">=</option></select> <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="text" value="1" onclick="event.stopPropagation()"></span> alors</div>`;
            
            const if1Block = if1Wrapper.querySelector('.block');
            const if1RemoveBtn = document.createElement('button');
            if1RemoveBtn.className = 'remove-btn';
            if1RemoveBtn.innerHTML = '√ó';
            if1RemoveBtn.onclick = function() { if1Wrapper.remove(); updateBlockCount(); };
            if1Block.appendChild(if1RemoveBtn);
            
            const if1NestedArea = document.createElement('div');
            if1NestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(if1NestedArea);
            if1Wrapper.appendChild(if1NestedArea);
            
            const if1CapsuleBottom = document.createElement('div');
            if1CapsuleBottom.className = 'block-capsule-bottom';
            if1CapsuleBottom.style.background = getComputedStyle(if1Block).background;
            if1Wrapper.appendChild(if1CapsuleBottom);
            
            innerNestedArea.appendChild(if1Wrapper);
            
            // Ajouter les blocs dans if1: tourner gauche, avancer, tourner droite
            const left1Wrapper = document.createElement('div');
            left1Wrapper.className = 'program-block';
            left1Wrapper.innerHTML = `<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>`;
            const left1Block = left1Wrapper.querySelector('.block');
            const left1RemoveBtn = document.createElement('button');
            left1RemoveBtn.className = 'remove-btn';
            left1RemoveBtn.innerHTML = '√ó';
            left1RemoveBtn.onclick = function() { left1Wrapper.remove(); updateBlockCount(); };
            left1Block.appendChild(left1RemoveBtn);
            if1NestedArea.appendChild(left1Wrapper);
            
            const forward1Wrapper = document.createElement('div');
            forward1Wrapper.className = 'program-block';
            forward1Wrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
            const forward1Block = forward1Wrapper.querySelector('.block');
            const forward1RemoveBtn = document.createElement('button');
            forward1RemoveBtn.className = 'remove-btn';
            forward1RemoveBtn.innerHTML = '√ó';
            forward1RemoveBtn.onclick = function() { forward1Wrapper.remove(); updateBlockCount(); };
            forward1Block.appendChild(forward1RemoveBtn);
            if1NestedArea.appendChild(forward1Wrapper);
            
            const right1Wrapper = document.createElement('div');
            right1Wrapper.className = 'program-block';
            right1Wrapper.innerHTML = `<div class="block motion" data-type="right">tourner ‚Üª droite</div>`;
            const right1Block = right1Wrapper.querySelector('.block');
            const right1RemoveBtn = document.createElement('button');
            right1RemoveBtn.className = 'remove-btn';
            right1RemoveBtn.innerHTML = '√ó';
            right1RemoveBtn.onclick = function() { right1Wrapper.remove(); updateBlockCount(); };
            right1Block.appendChild(right1RemoveBtn);
            if1NestedArea.appendChild(right1Wrapper);
            if1NestedArea.classList.remove('empty');
            console.log("‚úì Condition 'si i = 1' cr√©√©e");
            
            // 8. Deuxi√®me condition "si i = -1 alors"
            const if2Wrapper = document.createElement('div');
            if2Wrapper.className = 'program-block block-capsule';
            if2Wrapper.innerHTML = `<div class="block sensing" data-type="if">si <select class="var-select" onclick="event.stopPropagation()"><option value="i" selected>i</option></select> <select class="compare-op" onclick="event.stopPropagation()"><option value="=">=</option></select> <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="text" value="-1" onclick="event.stopPropagation()"></span> alors</div>`;
            
            const if2Block = if2Wrapper.querySelector('.block');
            const if2RemoveBtn = document.createElement('button');
            if2RemoveBtn.className = 'remove-btn';
            if2RemoveBtn.innerHTML = '√ó';
            if2RemoveBtn.onclick = function() { if2Wrapper.remove(); updateBlockCount(); };
            if2Block.appendChild(if2RemoveBtn);
            
            const if2NestedArea = document.createElement('div');
            if2NestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(if2NestedArea);
            if2Wrapper.appendChild(if2NestedArea);
            
            const if2CapsuleBottom = document.createElement('div');
            if2CapsuleBottom.className = 'block-capsule-bottom';
            if2CapsuleBottom.style.background = getComputedStyle(if2Block).background;
            if2Wrapper.appendChild(if2CapsuleBottom);
            
            innerNestedArea.appendChild(if2Wrapper);
            
            // Ajouter les blocs dans if2: tourner droite, avancer, tourner gauche
            const right2Wrapper = document.createElement('div');
            right2Wrapper.className = 'program-block';
            right2Wrapper.innerHTML = `<div class="block motion" data-type="right">tourner ‚Üª droite</div>`;
            const right2Block = right2Wrapper.querySelector('.block');
            const right2RemoveBtn = document.createElement('button');
            right2RemoveBtn.className = 'remove-btn';
            right2RemoveBtn.innerHTML = '√ó';
            right2RemoveBtn.onclick = function() { right2Wrapper.remove(); updateBlockCount(); };
            right2Block.appendChild(right2RemoveBtn);
            if2NestedArea.appendChild(right2Wrapper);
            
            const forward2Wrapper = document.createElement('div');
            forward2Wrapper.className = 'program-block';
            forward2Wrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
            const forward2Block = forward2Wrapper.querySelector('.block');
            const forward2RemoveBtn = document.createElement('button');
            forward2RemoveBtn.className = 'remove-btn';
            forward2RemoveBtn.innerHTML = '√ó';
            forward2RemoveBtn.onclick = function() { forward2Wrapper.remove(); updateBlockCount(); };
            forward2Block.appendChild(forward2RemoveBtn);
            if2NestedArea.appendChild(forward2Wrapper);
            
            const left2Wrapper = document.createElement('div');
            left2Wrapper.className = 'program-block';
            left2Wrapper.innerHTML = `<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>`;
            const left2Block = left2Wrapper.querySelector('.block');
            const left2RemoveBtn = document.createElement('button');
            left2RemoveBtn.className = 'remove-btn';
            left2RemoveBtn.innerHTML = '√ó';
            left2RemoveBtn.onclick = function() { left2Wrapper.remove(); updateBlockCount(); };
            left2Block.appendChild(left2RemoveBtn);
            if2NestedArea.appendChild(left2Wrapper);
            if2NestedArea.classList.remove('empty');
            console.log("‚úì Condition 'si i = -1' cr√©√©e");
            
            // 9. Ajouter "mettre i √† (i √ó -1)" dans la boucle externe (apr√®s la boucle interne)
            function createOperatorInValueSlot(varBlock, var1Name, operator, var2Name) {
                const valueSlot = varBlock.querySelector('.value-slot');
                
                const operatorBlock = document.createElement('div');
                operatorBlock.className = 'block operators';
                operatorBlock.setAttribute('data-type', 'operator');
                
                const firstSlotHTML = `<span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span>`;
                const operatorHTML = `<select onclick="event.stopPropagation()"><option value="${operator}">${operator === '*' ? '√ó' : operator === '/' ? '√∑' : operator}</option></select>`;
                const secondSlotHTML = `<span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span>`;
                
                operatorBlock.innerHTML = firstSlotHTML + operatorHTML + secondSlotHTML;
                
                const var1Block = document.createElement('div');
                var1Block.className = 'block variables';
                var1Block.setAttribute('data-type', 'var-value');
                var1Block.innerHTML = `<select onclick="event.stopPropagation()" class="var-select"><option value="${var1Name}" selected>${var1Name}</option></select>`;
                
                const firstSlot = operatorBlock.querySelectorAll('.value-slot')[0];
                firstSlot.appendChild(var1Block);
                
                const secondSlot = operatorBlock.querySelectorAll('.value-slot')[1];
                if (var2Name === '-1' || var2Name === '1') {
                    secondSlot.innerHTML = `<input type="text" value="${var2Name}" onclick="event.stopPropagation()">`;
                } else {
                    const var2Block = document.createElement('div');
                    var2Block.className = 'block variables';
                    var2Block.setAttribute('data-type', 'var-value');
                    var2Block.innerHTML = `<select onclick="event.stopPropagation()" class="var-select"><option value="${var2Name}" selected>${var2Name}</option></select>`;
                    secondSlot.appendChild(var2Block);
                }
                
                valueSlot.appendChild(operatorBlock);
            }
            
            const setIWrapper = document.createElement('div');
            setIWrapper.className = 'program-block';
            const setIBlock = document.createElement('div');
            setIBlock.className = 'block variables';
            setIBlock.setAttribute('data-type', 'variable');
            setIBlock.innerHTML = `mettre <select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select> √† <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span>`;
            createOperatorInValueSlot(setIBlock, 'i', '*', '-1');
            const setIRemoveBtn = document.createElement('button');
            setIRemoveBtn.className = 'remove-btn';
            setIRemoveBtn.innerHTML = '√ó';
            setIRemoveBtn.onclick = function() { setIWrapper.remove(); updateBlockCount(); };
            setIBlock.appendChild(setIRemoveBtn);
            setIWrapper.appendChild(setIBlock);
            outerNestedArea.appendChild(setIWrapper);
            console.log("‚úì Bloc 'mettre i √† (i √ó -1)' cr√©√©");
            
            // Mettre √† jour l'affichage
            updateAllVariableSelectors();
            updateVariableBlocksVisibility();
            updateBlockCount();
            
            console.log("=== Programme zigzag g√©n√©r√© avec succ√®s ! ===");
            showResult('‚úÖ Programme Zigzag g√©n√©r√© avec succ√®s !', true);
        }
        
        // G√©n√©rer le programme pour l'escalier
        function generateStairsProgram() {
            console.log("=== G√©n√©ration de l'escalier ===");
            
            // La valeur initiale de i doit toujours √™tre 1
            const randomI = 1;
            console.log("Valeur de i:", randomI);
            
            // G√©n√©rer une position de d√©part al√©atoire sur la grille (10x10)
            // Pour garantir un escalier minimum 2√ó2, on √©vite la derni√®re ligne et la derni√®re colonne
            // Pour Y : entre 1 et 8 (pas 0 ni 9) pour avoir au moins 2 lignes
            // Pour X : entre 0 et 8 (pas 9, qui est la 10√®me case) pour avoir au moins 2 colonnes
            const targetRow = Math.floor(Math.random() * 8) + 1; // 1 √† 8
            const targetCol = Math.floor(Math.random() * 9); // 0 √† 8
            console.log("Position cible al√©atoire: ligne", targetRow, "colonne", targetCol);
            
            // Calculer le nombre maximum de r√©p√©titions en fonction de la position X
            // Si targetCol = 0 (1√®re case), max = 10 r√©p√©titions
            // Si targetCol = 8 (9√®me case), max = 2 r√©p√©titions
            const maxRepeatX = 10 - targetCol;
            
            // Calculer le nombre maximum de r√©p√©titions en fonction de la position Y
            // L'escalier monte d'une case √† chaque it√©ration
            // Si targetRow = 1 (2√®me ligne), max = 2 r√©p√©titions (min garanti)
            // Si targetRow = 8 (9√®me ligne), max = 9 r√©p√©titions
            const maxRepeatY = targetRow + 1;
            
            // Prendre le minimum des deux contraintes
            const maxRepeat = Math.min(maxRepeatX, maxRepeatY);
            
            // G√©n√©rer un nombre al√©atoire de r√©p√©titions entre 2 et maxRepeat
            const minRepeat = 2;
            const randomRepeat = maxRepeat >= minRepeat ? 
                Math.floor(Math.random() * (maxRepeat - minRepeat + 1)) + minRepeat : 
                maxRepeat;
            console.log("Position X:", targetCol, "max X:", maxRepeatX);
            console.log("Position Y:", targetRow, "max Y:", maxRepeatY);
            console.log("=> Nombre de r√©p√©titions:", randomRepeat, "(min: 2, max:", maxRepeat + ")");
            
            // Choisir une couleur al√©atoire
            const colors = ['red', 'yellow', 'green', 'blue', 'black'];
            const colorNames = {
                'red': 'ROUGE',
                'yellow': 'JAUNE',
                'green': 'VERT',
                'blue': 'BLEU',
                'black': 'NOIR'
            };
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            const randomColorName = colorNames[randomColor];
            console.log("Couleur al√©atoire:", randomColor, "(" + randomColorName + ")");
            
            // Calculer le d√©placement depuis la position de d√©part (9, 5)
            const startRow = 9;
            const startCol = 5;
            const deltaRow = targetRow - startRow;
            const deltaCol = targetCol - startCol;
            console.log("D√©placement: deltaRow =", deltaRow, ", deltaCol =", deltaCol);
            
            // Ajouter la variable 'i' si elle n'existe pas d√©j√†
            if (!createdVariables.includes('i')) {
                createdVariables.push('i');
                variables['i'] = randomI;
                updateVariableDisplay();
                console.log("Variable 'i' cr√©√©e");
            } else {
                variables['i'] = randomI;
                updateVariableDisplay();
            }
            
            // G√©n√©rer les blocs de d√©placement initial avec garantie d'orientation vers le haut
            generateInitialMovementForCheckerboard(deltaRow, deltaCol);
            
            // 1. Cr√©er le bloc "mettre i √† 1"
            const varHTML = `<div class="block variables" data-type="variable">mettre <select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select> √† <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${randomI}" onclick="event.stopPropagation()"></span></div>`;
            addBlockToProgram({ 
                type: 'variable',
                html: varHTML,
                selectValues: ['i']
            });
            console.log("‚úì Bloc variable cr√©√© avec valeur", randomI);
            
            // 2. Cr√©er la boucle principale "r√©p√©ter [randomRepeat] fois"
            const mainLoopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${randomRepeat}" onclick="event.stopPropagation()"></span> fois</div>`;
            addBlockToProgram({ 
                type: 'repeat',
                html: mainLoopHTML
            });
            console.log("‚úì Boucle principale cr√©√©e (" + randomRepeat + " fois)");
            
            // R√©cup√©rer la zone imbriqu√©e de la boucle principale
            const programBlocks = document.getElementById('program-blocks');
            const mainLoopBlock = programBlocks.lastElementChild;
            const mainNestedArea = mainLoopBlock.querySelector('.nested-blocks');
            console.log("Zone imbriqu√©e principale:", mainNestedArea);
            
            // 3. Cr√©er la premi√®re boucle imbriqu√©e "r√©p√©ter i fois"
            const firstInnerLoopWrapper = document.createElement('div');
            firstInnerLoopWrapper.className = 'program-block block-capsule';
            const firstInnerLoopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span> fois</div>`;
            firstInnerLoopWrapper.innerHTML = firstInnerLoopHTML;
            
            // Cr√©er et ins√©rer le bloc var-value "i" dans le value-slot de la premi√®re boucle imbriqu√©e
            const firstInnerLoopValueSlot = firstInnerLoopWrapper.querySelector('.value-slot');
            const firstInnerVarBlock = document.createElement('div');
            firstInnerVarBlock.className = 'block variables';
            firstInnerVarBlock.setAttribute('data-type', 'var-value');
            firstInnerVarBlock.innerHTML = `<select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select>`;
            firstInnerLoopValueSlot.appendChild(firstInnerVarBlock);
            console.log("‚úì Bloc variable i ajout√© √† la premi√®re boucle imbriqu√©e");
            
            // Ajouter bouton de suppression √† la premi√®re boucle imbriqu√©e
            const firstInnerBlock = firstInnerLoopWrapper.querySelector('.block');
            const firstInnerRemoveBtn = document.createElement('button');
            firstInnerRemoveBtn.className = 'remove-btn';
            firstInnerRemoveBtn.innerHTML = '√ó';
            firstInnerRemoveBtn.onclick = function() { firstInnerLoopWrapper.remove(); updateBlockCount(); };
            firstInnerBlock.appendChild(firstInnerRemoveBtn);
            
            // Cr√©er zone imbriqu√©e pour la premi√®re boucle int√©rieure
            const firstInnerNestedArea = document.createElement('div');
            firstInnerNestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(firstInnerNestedArea);
            firstInnerLoopWrapper.appendChild(firstInnerNestedArea);
            
            // Ajouter le bas de la capsule
            const firstInnerCapsuleBottom = document.createElement('div');
            firstInnerCapsuleBottom.className = 'block-capsule-bottom';
            firstInnerCapsuleBottom.style.background = getComputedStyle(firstInnerBlock).background;
            firstInnerLoopWrapper.appendChild(firstInnerCapsuleBottom);
            
            mainNestedArea.appendChild(firstInnerLoopWrapper);
            mainNestedArea.classList.remove('empty');
            console.log("‚úì Premi√®re boucle imbriqu√©e cr√©√©e (r√©p√©ter i fois)");
            
            // 4. Ajouter "couleur [COULEUR AL√âATOIRE]" dans la premi√®re boucle imbriqu√©e
            const colorWrapper = document.createElement('div');
            colorWrapper.className = 'program-block';
            colorWrapper.innerHTML = `<div class="block looks" data-type="color" data-value="${randomColor}">couleur ${randomColorName}</div>`;
            const colorBlock = colorWrapper.querySelector('.block');
            const colorRemoveBtn = document.createElement('button');
            colorRemoveBtn.className = 'remove-btn';
            colorRemoveBtn.innerHTML = '√ó';
            colorRemoveBtn.onclick = function() { colorWrapper.remove(); updateBlockCount(); };
            colorBlock.appendChild(colorRemoveBtn);
            firstInnerNestedArea.appendChild(colorWrapper);
            firstInnerNestedArea.classList.remove('empty');
            console.log("‚úì Bloc couleur", randomColorName, "cr√©√©");
            
            // 5. Ajouter "avancer" dans la premi√®re boucle imbriqu√©e
            const forwardWrapper = document.createElement('div');
            forwardWrapper.className = 'program-block';
            forwardWrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
            const forwardBlock = forwardWrapper.querySelector('.block');
            const forwardRemoveBtn = document.createElement('button');
            forwardRemoveBtn.className = 'remove-btn';
            forwardRemoveBtn.innerHTML = '√ó';
            forwardRemoveBtn.onclick = function() { forwardWrapper.remove(); updateBlockCount(); };
            forwardBlock.appendChild(forwardRemoveBtn);
            firstInnerNestedArea.appendChild(forwardWrapper);
            console.log("‚úì Bloc avancer cr√©√©");
            
            // 6. Cr√©er la deuxi√®me boucle imbriqu√©e "r√©p√©ter i fois"
            const secondInnerLoopWrapper = document.createElement('div');
            secondInnerLoopWrapper.className = 'program-block block-capsule';
            const secondInnerLoopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span> fois</div>`;
            secondInnerLoopWrapper.innerHTML = secondInnerLoopHTML;
            
            // Cr√©er et ins√©rer le bloc var-value "i" dans le value-slot de la deuxi√®me boucle imbriqu√©e
            const secondInnerLoopValueSlot = secondInnerLoopWrapper.querySelector('.value-slot');
            const secondInnerVarBlock = document.createElement('div');
            secondInnerVarBlock.className = 'block variables';
            secondInnerVarBlock.setAttribute('data-type', 'var-value');
            secondInnerVarBlock.innerHTML = `<select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select>`;
            secondInnerLoopValueSlot.appendChild(secondInnerVarBlock);
            console.log("‚úì Bloc variable i ajout√© √† la deuxi√®me boucle imbriqu√©e");
            
            // Ajouter bouton de suppression √† la deuxi√®me boucle imbriqu√©e
            const secondInnerBlock = secondInnerLoopWrapper.querySelector('.block');
            const secondInnerRemoveBtn = document.createElement('button');
            secondInnerRemoveBtn.className = 'remove-btn';
            secondInnerRemoveBtn.innerHTML = '√ó';
            secondInnerRemoveBtn.onclick = function() { secondInnerLoopWrapper.remove(); updateBlockCount(); };
            secondInnerBlock.appendChild(secondInnerRemoveBtn);
            
            // Cr√©er zone imbriqu√©e pour la deuxi√®me boucle int√©rieure
            const secondInnerNestedArea = document.createElement('div');
            secondInnerNestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(secondInnerNestedArea);
            secondInnerLoopWrapper.appendChild(secondInnerNestedArea);
            
            // Ajouter le bas de la capsule
            const secondInnerCapsuleBottom = document.createElement('div');
            secondInnerCapsuleBottom.className = 'block-capsule-bottom';
            secondInnerCapsuleBottom.style.background = getComputedStyle(secondInnerBlock).background;
            secondInnerLoopWrapper.appendChild(secondInnerCapsuleBottom);
            
            mainNestedArea.appendChild(secondInnerLoopWrapper);
            console.log("‚úì Deuxi√®me boucle imbriqu√©e cr√©√©e (r√©p√©ter i fois)");
            
            // 7. Ajouter "reculer" dans la deuxi√®me boucle imbriqu√©e
            const backWrapper = document.createElement('div');
            backWrapper.className = 'program-block';
            backWrapper.innerHTML = '<div class="block motion" data-type="back">reculer</div>';
            const backBlock = backWrapper.querySelector('.block');
            const backRemoveBtn = document.createElement('button');
            backRemoveBtn.className = 'remove-btn';
            backRemoveBtn.innerHTML = '√ó';
            backRemoveBtn.onclick = function() { backWrapper.remove(); updateBlockCount(); };
            backBlock.appendChild(backRemoveBtn);
            secondInnerNestedArea.appendChild(backWrapper);
            secondInnerNestedArea.classList.remove('empty');
            console.log("‚úì Bloc reculer cr√©√©");
            
            // 8. Ajouter "tourner droite" dans la boucle principale
            const rightTurnWrapper = document.createElement('div');
            rightTurnWrapper.className = 'program-block';
            rightTurnWrapper.innerHTML = `<div class="block motion" data-type="right">tourner ‚Üª droite</div>`;
            const rightTurnBlock = rightTurnWrapper.querySelector('.block');
            const rightTurnRemoveBtn = document.createElement('button');
            rightTurnRemoveBtn.className = 'remove-btn';
            rightTurnRemoveBtn.innerHTML = '√ó';
            rightTurnRemoveBtn.onclick = function() { rightTurnWrapper.remove(); updateBlockCount(); };
            rightTurnBlock.appendChild(rightTurnRemoveBtn);
            mainNestedArea.appendChild(rightTurnWrapper);
            console.log("‚úì Bloc tourner droite cr√©√©");
            
            // 9. Ajouter "avancer" dans la boucle principale
            const forward2Wrapper = document.createElement('div');
            forward2Wrapper.className = 'program-block';
            forward2Wrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
            const forward2Block = forward2Wrapper.querySelector('.block');
            const forward2RemoveBtn = document.createElement('button');
            forward2RemoveBtn.className = 'remove-btn';
            forward2RemoveBtn.innerHTML = '√ó';
            forward2RemoveBtn.onclick = function() { forward2Wrapper.remove(); updateBlockCount(); };
            forward2Block.appendChild(forward2RemoveBtn);
            mainNestedArea.appendChild(forward2Wrapper);
            console.log("‚úì Bloc avancer cr√©√© (boucle principale)");
            
            // 10. Ajouter "tourner gauche" dans la boucle principale
            const leftTurnWrapper = document.createElement('div');
            leftTurnWrapper.className = 'program-block';
            leftTurnWrapper.innerHTML = `<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>`;
            const leftTurnBlock = leftTurnWrapper.querySelector('.block');
            const leftTurnRemoveBtn = document.createElement('button');
            leftTurnRemoveBtn.className = 'remove-btn';
            leftTurnRemoveBtn.innerHTML = '√ó';
            leftTurnRemoveBtn.onclick = function() { leftTurnWrapper.remove(); updateBlockCount(); };
            leftTurnBlock.appendChild(leftTurnRemoveBtn);
            mainNestedArea.appendChild(leftTurnWrapper);
            console.log("‚úì Bloc tourner gauche cr√©√©");
            
            // 11. Ajouter "ajouter 1 √† i" dans la boucle principale
            const changeVarWrapper = document.createElement('div');
            changeVarWrapper.className = 'program-block';
            changeVarWrapper.innerHTML = `<div class="block variables" data-type="change-var">ajouter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="1" onclick="event.stopPropagation()"></span> √† <select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select></div>`;
            const changeVarBlock = changeVarWrapper.querySelector('.block');
            const changeVarRemoveBtn = document.createElement('button');
            changeVarRemoveBtn.className = 'remove-btn';
            changeVarRemoveBtn.innerHTML = '√ó';
            changeVarRemoveBtn.onclick = function() { changeVarWrapper.remove(); updateBlockCount(); };
            changeVarBlock.appendChild(changeVarRemoveBtn);
            mainNestedArea.appendChild(changeVarWrapper);
            console.log("‚úì Bloc ajouter 1 √† i cr√©√©");
            
            // Mettre √† jour l'affichage des variables dans toute l'interface
            updateAllVariableSelectors();
            updateVariableBlocksVisibility();
            updateBlockCount();
            
            console.log("=== Programme escalier g√©n√©r√© avec succ√®s ! ===");
            showResult('‚úÖ Programme Escalier g√©n√©r√© avec succ√®s !', true);
        }
        
        // G√©n√©rer le programme pour le damier
        function generateCheckerboardProgram() {
            console.log("=== G√©n√©ration du damier ===");
            
            // Choisir une couleur al√©atoire
            const colors = ['red', 'yellow', 'green', 'blue', 'black'];
            const colorNames = {
                'red': 'ROUGE',
                'yellow': 'JAUNE',
                'green': 'VERT',
                'blue': 'BLEU',
                'black': 'NOIR'
            };
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            const randomColorName = colorNames[randomColor];
            console.log("Couleur al√©atoire:", randomColor, "(" + randomColorName + ")");
            
            // G√©n√©rer une position de d√©part al√©atoire sur la grille (10x10)
            // Pour garantir un damier minimum 2√ó2, on √©vite la derni√®re ligne et la derni√®re colonne
            // targetRow : 0 √† 8 (pas 9, qui est la derni√®re ligne)
            // targetCol : 0 √† 8 (pas 9, qui est la derni√®re colonne)
            const targetRow = Math.floor(Math.random() * 9); // 0 √† 8
            const targetCol = Math.floor(Math.random() * 9); // 0 √† 8
            console.log("Position cible al√©atoire: ligne", targetRow, "colonne", targetCol);
            
            // Calculer le nombre maximum de colonnes et de lignes
            // Colonnes : on va vers la droite (minimum 2 colonnes garanties)
            const maxCols = 10 - targetCol;
            // Lignes : r√©p√©ter s fois fait s+1 lignes (minimum 2 lignes garanties car targetRow <= 8)
            const maxRows = targetRow;
            
            // G√©n√©rer des valeurs al√©atoires entre 2 et le max
            const minValue = 2;
            const randomCols = maxCols >= minValue ? 
                Math.floor(Math.random() * (maxCols - minValue + 1)) + minValue : 
                maxCols;
            const randomRows = maxRows >= minValue ? 
                Math.floor(Math.random() * (maxRows - minValue + 1)) + minValue : 
                maxRows;
            
            console.log("Position X:", targetCol, "=> max colonnes:", maxCols, "=> colonnes:", randomCols, "(min 2)");
            console.log("Position Y:", targetRow, "=> max lignes:", maxRows + 1, "=> lignes:", randomRows + 1, "(min 2)");
            
            // Calculer le d√©placement depuis la position de d√©part (9, 5)
            const startRow = 9;
            const startCol = 5;
            const deltaRow = targetRow - startRow;
            const deltaCol = targetCol - startCol;
            console.log("D√©placement: deltaRow =", deltaRow, ", deltaCol =", deltaCol);
            
            // Cr√©er les variables i et p seulement (pas a)
            const varNames = ['i', 'p'];
            const varValues = {'i': 1, 'p': 1};
            
            varNames.forEach(varName => {
                if (!createdVariables.includes(varName)) {
                    createdVariables.push(varName);
                }
                variables[varName] = varValues[varName];
            });
            updateVariableDisplay();
            console.log("Variables cr√©√©es: i=1, p=1");
            
            // G√©n√©rer les blocs de d√©placement initial avec garantie d'orientation vers le haut
            generateInitialMovementForCheckerboard(deltaRow, deltaCol);
            
            // Fonction auxiliaire pour cr√©er des blocs avec op√©rateurs
            function createOperatorInValueSlot(varBlock, var1Name, operator, var2Name) {
                const valueSlot = varBlock.querySelector('.value-slot');
                
                const operatorBlock = document.createElement('div');
                operatorBlock.className = 'block operators';
                operatorBlock.setAttribute('data-type', 'operator');
                
                // Cr√©er le premier value-slot avec variable
                const firstSlotHTML = `<span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span>`;
                const operatorHTML = `<select onclick="event.stopPropagation()"><option value="${operator}">${operator === '*' ? '√ó' : operator === '/' ? '√∑' : operator}</option></select>`;
                const secondSlotHTML = `<span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span>`;
                
                operatorBlock.innerHTML = firstSlotHTML + operatorHTML + secondSlotHTML;
                
                // Cr√©er le premier bloc variable
                const var1Block = document.createElement('div');
                var1Block.className = 'block variables';
                var1Block.setAttribute('data-type', 'var-value');
                var1Block.innerHTML = `<select onclick="event.stopPropagation()" class="var-select"><option value="${var1Name}" selected>${var1Name}</option></select>`;
                
                // Ins√©rer dans le premier slot
                const firstSlot = operatorBlock.querySelectorAll('.value-slot')[0];
                firstSlot.appendChild(var1Block);
                
                // G√©rer le deuxi√®me slot (peut √™tre une variable ou un nombre)
                const secondSlot = operatorBlock.querySelectorAll('.value-slot')[1];
                if (var2Name === '-1' || var2Name === '1') {
                    // C'est un nombre
                    secondSlot.innerHTML = `<input type="text" value="${var2Name}" onclick="event.stopPropagation()">`;
                } else {
                    // C'est une variable
                    const var2Block = document.createElement('div');
                    var2Block.className = 'block variables';
                    var2Block.setAttribute('data-type', 'var-value');
                    var2Block.innerHTML = `<select onclick="event.stopPropagation()" class="var-select"><option value="${var2Name}" selected>${var2Name}</option></select>`;
                    secondSlot.appendChild(var2Block);
                }
                
                valueSlot.appendChild(operatorBlock);
            }
            
            // 1. Cr√©er "mettre i √† 1"
            const varIHTML = `<div class="block variables" data-type="variable">mettre <select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select> √† <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="1" onclick="event.stopPropagation()"></span></div>`;
            addBlockToProgram({ 
                type: 'variable',
                html: varIHTML,
                selectValues: ['i']
            });
            
            // 2. Cr√©er "mettre p √† 1"
            const varPHTML = `<div class="block variables" data-type="variable">mettre <select onclick="event.stopPropagation()" class="var-select"><option value="p" selected>p</option></select> √† <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="1" onclick="event.stopPropagation()"></span></div>`;
            addBlockToProgram({ 
                type: 'variable',
                html: varPHTML,
                selectValues: ['p']
            });
            console.log("‚úì Variables i, p cr√©√©es");
            
            // 3. Cr√©er la boucle principale "r√©p√©ter [randomCols] fois" (colonnes)
            const mainLoopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${randomCols}" onclick="event.stopPropagation()"></span> fois</div>`;
            addBlockToProgram({ 
                type: 'repeat',
                html: mainLoopHTML
            });
            console.log("‚úì Boucle principale cr√©√©e (colonnes:", randomCols + ")");
            
            const programBlocks = document.getElementById('program-blocks');
            const mainLoopBlock = programBlocks.lastElementChild;
            const mainNestedArea = mainLoopBlock.querySelector('.nested-blocks');
            
            // 4. Cr√©er la boucle imbriqu√©e "r√©p√©ter [randomRows] fois" (lignes)
            const innerLoopWrapper = document.createElement('div');
            innerLoopWrapper.className = 'program-block block-capsule';
            const innerLoopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${randomRows}" onclick="event.stopPropagation()"></span> fois</div>`;
            innerLoopWrapper.innerHTML = innerLoopHTML;
            
            const innerBlock = innerLoopWrapper.querySelector('.block');
            const innerRemoveBtn = document.createElement('button');
            innerRemoveBtn.className = 'remove-btn';
            innerRemoveBtn.innerHTML = '√ó';
            innerRemoveBtn.onclick = function() { innerLoopWrapper.remove(); updateBlockCount(); };
            innerBlock.appendChild(innerRemoveBtn);
            
            const innerNestedArea = document.createElement('div');
            innerNestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(innerNestedArea);
            innerLoopWrapper.appendChild(innerNestedArea);
            
            const innerCapsuleBottom = document.createElement('div');
            innerCapsuleBottom.className = 'block-capsule-bottom';
            innerCapsuleBottom.style.background = getComputedStyle(innerBlock).background;
            innerLoopWrapper.appendChild(innerCapsuleBottom);
            
            mainNestedArea.appendChild(innerLoopWrapper);
            mainNestedArea.classList.remove('empty');
            console.log("‚úì Boucle imbriqu√©e cr√©√©e (lignes:", randomRows + 1 + ")");
            
            // 5. Premi√®re condition "si i = 1 alors"
            const if1Wrapper = document.createElement('div');
            if1Wrapper.className = 'program-block block-capsule';
            if1Wrapper.innerHTML = `<div class="block sensing" data-type="if">si <select class="var-select" onclick="event.stopPropagation()"><option value="i" selected>i</option></select> <select class="compare-op" onclick="event.stopPropagation()"><option value="=">=</option></select> <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="text" value="1" onclick="event.stopPropagation()"></span> alors</div>`;
            
            const if1Block = if1Wrapper.querySelector('.block');
            const if1RemoveBtn = document.createElement('button');
            if1RemoveBtn.className = 'remove-btn';
            if1RemoveBtn.innerHTML = '√ó';
            if1RemoveBtn.onclick = function() { if1Wrapper.remove(); updateBlockCount(); };
            if1Block.appendChild(if1RemoveBtn);
            
            const if1NestedArea = document.createElement('div');
            if1NestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(if1NestedArea);
            if1Wrapper.appendChild(if1NestedArea);
            
            const if1CapsuleBottom = document.createElement('div');
            if1CapsuleBottom.className = 'block-capsule-bottom';
            if1CapsuleBottom.style.background = getComputedStyle(if1Block).background;
            if1Wrapper.appendChild(if1CapsuleBottom);
            
            innerNestedArea.appendChild(if1Wrapper);
            innerNestedArea.classList.remove('empty');
            
            // Ajouter "couleur" dans if1
            const color1Wrapper = document.createElement('div');
            color1Wrapper.className = 'program-block';
            color1Wrapper.innerHTML = `<div class="block looks" data-type="color" data-value="${randomColor}">couleur ${randomColorName}</div>`;
            const color1Block = color1Wrapper.querySelector('.block');
            const color1RemoveBtn = document.createElement('button');
            color1RemoveBtn.className = 'remove-btn';
            color1RemoveBtn.innerHTML = '√ó';
            color1RemoveBtn.onclick = function() { color1Wrapper.remove(); updateBlockCount(); };
            color1Block.appendChild(color1RemoveBtn);
            if1NestedArea.appendChild(color1Wrapper);
            if1NestedArea.classList.remove('empty');
            console.log("‚úì Condition 'si i = 1' avec couleur cr√©√©e");
            
            // 6. Deuxi√®me condition "si p = 1 alors"
            const if2Wrapper = document.createElement('div');
            if2Wrapper.className = 'program-block block-capsule';
            if2Wrapper.innerHTML = `<div class="block sensing" data-type="if">si <select class="var-select" onclick="event.stopPropagation()"><option value="p" selected>p</option></select> <select class="compare-op" onclick="event.stopPropagation()"><option value="=">=</option></select> <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="text" value="1" onclick="event.stopPropagation()"></span> alors</div>`;
            
            const if2Block = if2Wrapper.querySelector('.block');
            const if2RemoveBtn = document.createElement('button');
            if2RemoveBtn.className = 'remove-btn';
            if2RemoveBtn.innerHTML = '√ó';
            if2RemoveBtn.onclick = function() { if2Wrapper.remove(); updateBlockCount(); };
            if2Block.appendChild(if2RemoveBtn);
            
            const if2NestedArea = document.createElement('div');
            if2NestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(if2NestedArea);
            if2Wrapper.appendChild(if2NestedArea);
            
            const if2CapsuleBottom = document.createElement('div');
            if2CapsuleBottom.className = 'block-capsule-bottom';
            if2CapsuleBottom.style.background = getComputedStyle(if2Block).background;
            if2Wrapper.appendChild(if2CapsuleBottom);
            
            innerNestedArea.appendChild(if2Wrapper);
            
            // Ajouter "avancer" dans if2
            const forward1Wrapper = document.createElement('div');
            forward1Wrapper.className = 'program-block';
            forward1Wrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
            const forward1Block = forward1Wrapper.querySelector('.block');
            const forward1RemoveBtn = document.createElement('button');
            forward1RemoveBtn.className = 'remove-btn';
            forward1RemoveBtn.innerHTML = '√ó';
            forward1RemoveBtn.onclick = function() { forward1Wrapper.remove(); updateBlockCount(); };
            forward1Block.appendChild(forward1RemoveBtn);
            if2NestedArea.appendChild(forward1Wrapper);
            if2NestedArea.classList.remove('empty');
            console.log("‚úì Condition 'si p = 1' avec avancer cr√©√©e");
            
            // 7. Troisi√®me condition "si p = -1 alors"
            const if3Wrapper = document.createElement('div');
            if3Wrapper.className = 'program-block block-capsule';
            if3Wrapper.innerHTML = `<div class="block sensing" data-type="if">si <select class="var-select" onclick="event.stopPropagation()"><option value="p" selected>p</option></select> <select class="compare-op" onclick="event.stopPropagation()"><option value="=">=</option></select> <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="text" value="-1" onclick="event.stopPropagation()"></span> alors</div>`;
            
            const if3Block = if3Wrapper.querySelector('.block');
            const if3RemoveBtn = document.createElement('button');
            if3RemoveBtn.className = 'remove-btn';
            if3RemoveBtn.innerHTML = '√ó';
            if3RemoveBtn.onclick = function() { if3Wrapper.remove(); updateBlockCount(); };
            if3Block.appendChild(if3RemoveBtn);
            
            const if3NestedArea = document.createElement('div');
            if3NestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(if3NestedArea);
            if3Wrapper.appendChild(if3NestedArea);
            
            const if3CapsuleBottom = document.createElement('div');
            if3CapsuleBottom.className = 'block-capsule-bottom';
            if3CapsuleBottom.style.background = getComputedStyle(if3Block).background;
            if3Wrapper.appendChild(if3CapsuleBottom);
            
            innerNestedArea.appendChild(if3Wrapper);
            
            // Ajouter "reculer" dans if3
            const backWrapper = document.createElement('div');
            backWrapper.className = 'program-block';
            backWrapper.innerHTML = '<div class="block motion" data-type="back">reculer</div>';
            const backBlock = backWrapper.querySelector('.block');
            const backRemoveBtn = document.createElement('button');
            backRemoveBtn.className = 'remove-btn';
            backRemoveBtn.innerHTML = '√ó';
            backRemoveBtn.onclick = function() { backWrapper.remove(); updateBlockCount(); };
            backBlock.appendChild(backRemoveBtn);
            if3NestedArea.appendChild(backWrapper);
            if3NestedArea.classList.remove('empty');
            console.log("‚úì Condition 'si p = -1' avec reculer cr√©√©e");
            
            // 8. "mettre i √† (i √ó -1)"
            const setI1Wrapper = document.createElement('div');
            setI1Wrapper.className = 'program-block';
            const setI1Block = document.createElement('div');
            setI1Block.className = 'block variables';
            setI1Block.setAttribute('data-type', 'variable');
            setI1Block.innerHTML = `mettre <select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select> √† <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span>`;
            createOperatorInValueSlot(setI1Block, 'i', '*', '-1');
            const setI1RemoveBtn = document.createElement('button');
            setI1RemoveBtn.className = 'remove-btn';
            setI1RemoveBtn.innerHTML = '√ó';
            setI1RemoveBtn.onclick = function() { setI1Wrapper.remove(); updateBlockCount(); };
            setI1Block.appendChild(setI1RemoveBtn);
            setI1Wrapper.appendChild(setI1Block);
            innerNestedArea.appendChild(setI1Wrapper);
            console.log("‚úì Bloc 'mettre i √† (i √ó -1)' cr√©√©");
            
            // 9. Dans la boucle principale : "si i = 1 alors"
            const if4Wrapper = document.createElement('div');
            if4Wrapper.className = 'program-block block-capsule';
            if4Wrapper.innerHTML = `<div class="block sensing" data-type="if">si <select class="var-select" onclick="event.stopPropagation()"><option value="i" selected>i</option></select> <select class="compare-op" onclick="event.stopPropagation()"><option value="=">=</option></select> <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="text" value="1" onclick="event.stopPropagation()"></span> alors</div>`;
            
            const if4Block = if4Wrapper.querySelector('.block');
            const if4RemoveBtn = document.createElement('button');
            if4RemoveBtn.className = 'remove-btn';
            if4RemoveBtn.innerHTML = '√ó';
            if4RemoveBtn.onclick = function() { if4Wrapper.remove(); updateBlockCount(); };
            if4Block.appendChild(if4RemoveBtn);
            
            const if4NestedArea = document.createElement('div');
            if4NestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(if4NestedArea);
            if4Wrapper.appendChild(if4NestedArea);
            
            const if4CapsuleBottom = document.createElement('div');
            if4CapsuleBottom.className = 'block-capsule-bottom';
            if4CapsuleBottom.style.background = getComputedStyle(if4Block).background;
            if4Wrapper.appendChild(if4CapsuleBottom);
            
            mainNestedArea.appendChild(if4Wrapper);
            
            // Ajouter "couleur" dans if4
            const color2Wrapper = document.createElement('div');
            color2Wrapper.className = 'program-block';
            color2Wrapper.innerHTML = `<div class="block looks" data-type="color" data-value="${randomColor}">couleur ${randomColorName}</div>`;
            const color2Block = color2Wrapper.querySelector('.block');
            const color2RemoveBtn = document.createElement('button');
            color2RemoveBtn.className = 'remove-btn';
            color2RemoveBtn.innerHTML = '√ó';
            color2RemoveBtn.onclick = function() { color2Wrapper.remove(); updateBlockCount(); };
            color2Block.appendChild(color2RemoveBtn);
            if4NestedArea.appendChild(color2Wrapper);
            if4NestedArea.classList.remove('empty');
            console.log("‚úì Condition 'si i = 1' avec couleur cr√©√©e");
            
            // 10. "tourner droite"
            const rightWrapper = document.createElement('div');
            rightWrapper.className = 'program-block';
            rightWrapper.innerHTML = `<div class="block motion" data-type="right">tourner ‚Üª droite</div>`;
            const rightBlock = rightWrapper.querySelector('.block');
            const rightRemoveBtn = document.createElement('button');
            rightRemoveBtn.className = 'remove-btn';
            rightRemoveBtn.innerHTML = '√ó';
            rightRemoveBtn.onclick = function() { rightWrapper.remove(); updateBlockCount(); };
            rightBlock.appendChild(rightRemoveBtn);
            mainNestedArea.appendChild(rightWrapper);
            
            // 11. "avancer"
            const forward2Wrapper = document.createElement('div');
            forward2Wrapper.className = 'program-block';
            forward2Wrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
            const forward2Block = forward2Wrapper.querySelector('.block');
            const forward2RemoveBtn = document.createElement('button');
            forward2RemoveBtn.className = 'remove-btn';
            forward2RemoveBtn.innerHTML = '√ó';
            forward2RemoveBtn.onclick = function() { forward2Wrapper.remove(); updateBlockCount(); };
            forward2Block.appendChild(forward2RemoveBtn);
            mainNestedArea.appendChild(forward2Wrapper);
            
            // 12. "tourner gauche"
            const leftWrapper = document.createElement('div');
            leftWrapper.className = 'program-block';
            leftWrapper.innerHTML = `<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>`;
            const leftBlock = leftWrapper.querySelector('.block');
            const leftRemoveBtn = document.createElement('button');
            leftRemoveBtn.className = 'remove-btn';
            leftRemoveBtn.innerHTML = '√ó';
            leftRemoveBtn.onclick = function() { leftWrapper.remove(); updateBlockCount(); };
            leftBlock.appendChild(leftRemoveBtn);
            mainNestedArea.appendChild(leftWrapper);
            console.log("‚úì Blocs tourner droite, avancer, tourner gauche cr√©√©s");
            
            // 13. "mettre i √† (i √ó -1)"
            const setI2Wrapper = document.createElement('div');
            setI2Wrapper.className = 'program-block';
            const setI2Block = document.createElement('div');
            setI2Block.className = 'block variables';
            setI2Block.setAttribute('data-type', 'variable');
            setI2Block.innerHTML = `mettre <select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select> √† <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span>`;
            createOperatorInValueSlot(setI2Block, 'i', '*', '-1');
            const setI2RemoveBtn = document.createElement('button');
            setI2RemoveBtn.className = 'remove-btn';
            setI2RemoveBtn.innerHTML = '√ó';
            setI2RemoveBtn.onclick = function() { setI2Wrapper.remove(); updateBlockCount(); };
            setI2Block.appendChild(setI2RemoveBtn);
            setI2Wrapper.appendChild(setI2Block);
            mainNestedArea.appendChild(setI2Wrapper);
            
            // 14. "mettre p √† (p √ó -1)"
            const setPWrapper = document.createElement('div');
            setPWrapper.className = 'program-block';
            const setPBlock = document.createElement('div');
            setPBlock.className = 'block variables';
            setPBlock.setAttribute('data-type', 'variable');
            setPBlock.innerHTML = `mettre <select onclick="event.stopPropagation()" class="var-select"><option value="p" selected>p</option></select> √† <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span>`;
            createOperatorInValueSlot(setPBlock, 'p', '*', '-1');
            const setPRemoveBtn = document.createElement('button');
            setPRemoveBtn.className = 'remove-btn';
            setPRemoveBtn.innerHTML = '√ó';
            setPRemoveBtn.onclick = function() { setPWrapper.remove(); updateBlockCount(); };
            setPBlock.appendChild(setPRemoveBtn);
            setPWrapper.appendChild(setPBlock);
            mainNestedArea.appendChild(setPWrapper);
            console.log("‚úì Blocs mettre i, a, p cr√©√©s");
            
            // Mettre √† jour l'affichage
            updateAllVariableSelectors();
            updateVariableBlocksVisibility();
            updateBlockCount();
            
            console.log("=== Programme damier g√©n√©r√© avec succ√®s ! ===");
            showResult('‚úÖ Programme Damier g√©n√©r√© avec succ√®s !', true);
        }
        
        // G√©n√©rer le programme pour la croix
        function generateCrossProgram() {
            console.log("=== G√©n√©ration de la croix ===");
            
            // Choisir une couleur al√©atoire
            const colors = ['red', 'yellow', 'green', 'blue', 'black'];
            const colorNames = {
                'red': 'ROUGE',
                'yellow': 'JAUNE',
                'green': 'VERT',
                'blue': 'BLEU',
                'black': 'NOIR'
            };
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            const randomColorName = colorNames[randomColor];
            console.log("Couleur al√©atoire:", randomColor, "(" + randomColorName + ")");
            
            // G√©n√©rer une position de d√©part al√©atoire
            // La croix fait i+1 de large (si i=2, croix 3√ó3)
            // Pour garantir minimum 3√ó3 : i minimum = 2
            // Position doit √™tre √† au moins 3 cases du bord droit et du bord haut
            // targetCol : 0 √† 6 maximum (pour avoir 3 cases de marge √† droite avec i=2)
            // targetRow : 3 √† 9 (pour avoir 3 cases vers le haut)
            
            const targetCol = Math.floor(Math.random() * 7); // 0 √† 6
            const targetRow = Math.floor(Math.random() * 7) + 3; // 3 √† 9
            console.log("Position cible al√©atoire: ligne", targetRow, "colonne", targetCol);
            
            // Calculer la valeur maximale de i en fonction de la position
            // √Ä droite : il faut i cases + position ne doit pas d√©passer 9
            // maxI selon X : 9 - targetCol (si col=0, max 9; si col=6, max 3)
            const maxIX = 9 - targetCol;
            
            // En haut : il faut i cases vers le haut
            // maxI selon Y : targetRow (si row=3, max 3; si row=9, max 9)
            const maxIY = targetRow;
            
            const maxI = Math.min(maxIX, maxIY, 9); // Limit√© √† 9 maximum
            
            // G√©n√©rer une valeur al√©atoire pour i entre 2 et maxI
            const minI = 2;
            const randomI = maxI >= minI ? 
                Math.floor(Math.random() * (maxI - minI + 1)) + minI : 
                maxI;
            
            console.log("Position X:", targetCol, "max I (X):", maxIX);
            console.log("Position Y:", targetRow, "max I (Y):", maxIY);
            console.log("=> Valeur de i:", randomI, "(croix", (randomI + 1) + "√ó" + (randomI + 1) + ")");
            
            // Calculer le d√©placement depuis la position de d√©part (9, 5)
            const startRow = 9;
            const startCol = 5;
            const deltaRow = targetRow - startRow;
            const deltaCol = targetCol - startCol;
            console.log("D√©placement: deltaRow =", deltaRow, ", deltaCol =", deltaCol);
            
            // Cr√©er les variables i et p
            const varNames = ['i', 'p'];
            const varValues = {'i': randomI, 'p': 1};
            
            varNames.forEach(varName => {
                if (!createdVariables.includes(varName)) {
                    createdVariables.push(varName);
                }
                variables[varName] = varValues[varName];
            });
            updateVariableDisplay();
            console.log("Variables cr√©√©es: i=" + randomI + ", p=1");
            
            // G√©n√©rer les blocs de d√©placement initial avec garantie d'orientation vers le haut
            generateInitialMovementForCheckerboard(deltaRow, deltaCol);
            
            // Fonction auxiliaire pour cr√©er des blocs avec op√©rateurs
            function createOperatorInValueSlot(varBlock, var1Name, operator, var2Name) {
                const valueSlot = varBlock.querySelector('.value-slot');
                
                const operatorBlock = document.createElement('div');
                operatorBlock.className = 'block operators';
                operatorBlock.setAttribute('data-type', 'operator');
                
                const firstSlotHTML = `<span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span>`;
                const operatorHTML = `<select onclick="event.stopPropagation()"><option value="${operator}">${operator === '*' ? '√ó' : operator === '/' ? '√∑' : operator}</option></select>`;
                const secondSlotHTML = `<span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span>`;
                
                operatorBlock.innerHTML = firstSlotHTML + operatorHTML + secondSlotHTML;
                
                const var1Block = document.createElement('div');
                var1Block.className = 'block variables';
                var1Block.setAttribute('data-type', 'var-value');
                var1Block.innerHTML = `<select onclick="event.stopPropagation()" class="var-select"><option value="${var1Name}" selected>${var1Name}</option></select>`;
                
                const firstSlot = operatorBlock.querySelectorAll('.value-slot')[0];
                firstSlot.appendChild(var1Block);
                
                const secondSlot = operatorBlock.querySelectorAll('.value-slot')[1];
                if (var2Name === '-1' || var2Name === '1') {
                    secondSlot.innerHTML = `<input type="text" value="${var2Name}" onclick="event.stopPropagation()">`;
                } else {
                    const var2Block = document.createElement('div');
                    var2Block.className = 'block variables';
                    var2Block.setAttribute('data-type', 'var-value');
                    var2Block.innerHTML = `<select onclick="event.stopPropagation()" class="var-select"><option value="${var2Name}" selected>${var2Name}</option></select>`;
                    secondSlot.appendChild(var2Block);
                }
                
                valueSlot.appendChild(operatorBlock);
            }
            
            // 1. Cr√©er "mettre i √† [randomI]"
            const varIHTML = `<div class="block variables" data-type="variable">mettre <select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select> √† <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${randomI}" onclick="event.stopPropagation()"></span></div>`;
            addBlockToProgram({ 
                type: 'variable',
                html: varIHTML,
                selectValues: ['i']
            });
            
            // 2. Cr√©er "mettre p √† 1"
            const varPHTML = `<div class="block variables" data-type="variable">mettre <select onclick="event.stopPropagation()" class="var-select"><option value="p" selected>p</option></select> √† <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="1" onclick="event.stopPropagation()"></span></div>`;
            addBlockToProgram({ 
                type: 'variable',
                html: varPHTML,
                selectValues: ['p']
            });
            console.log("‚úì Variables i, p cr√©√©es");
            
            // 3. Cr√©er la boucle principale "r√©p√©ter 2 fois"
            const mainLoopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="2" onclick="event.stopPropagation()"></span> fois</div>`;
            addBlockToProgram({ 
                type: 'repeat',
                html: mainLoopHTML
            });
            console.log("‚úì Boucle principale cr√©√©e (2 fois)");
            
            const programBlocks = document.getElementById('program-blocks');
            const mainLoopBlock = programBlocks.lastElementChild;
            const mainNestedArea = mainLoopBlock.querySelector('.nested-blocks');
            
            // 4. Ajouter "couleur" dans la boucle principale
            const color1Wrapper = document.createElement('div');
            color1Wrapper.className = 'program-block';
            color1Wrapper.innerHTML = `<div class="block looks" data-type="color" data-value="${randomColor}">couleur ${randomColorName}</div>`;
            const color1Block = color1Wrapper.querySelector('.block');
            const color1RemoveBtn = document.createElement('button');
            color1RemoveBtn.className = 'remove-btn';
            color1RemoveBtn.innerHTML = '√ó';
            color1RemoveBtn.onclick = function() { color1Wrapper.remove(); updateBlockCount(); };
            color1Block.appendChild(color1RemoveBtn);
            mainNestedArea.appendChild(color1Wrapper);
            mainNestedArea.classList.remove('empty');
            console.log("‚úì Couleur ajout√©e");
            
            // 5. Cr√©er la boucle imbriqu√©e "r√©p√©ter i fois"
            const innerLoop1Wrapper = document.createElement('div');
            innerLoop1Wrapper.className = 'program-block block-capsule';
            const innerLoop1HTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span> fois</div>`;
            innerLoop1Wrapper.innerHTML = innerLoop1HTML;
            
            const innerLoop1ValueSlot = innerLoop1Wrapper.querySelector('.value-slot');
            const innerLoop1VarBlock = document.createElement('div');
            innerLoop1VarBlock.className = 'block variables';
            innerLoop1VarBlock.setAttribute('data-type', 'var-value');
            innerLoop1VarBlock.innerHTML = `<select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select>`;
            innerLoop1ValueSlot.appendChild(innerLoop1VarBlock);
            
            const innerLoop1Block = innerLoop1Wrapper.querySelector('.block');
            const innerLoop1RemoveBtn = document.createElement('button');
            innerLoop1RemoveBtn.className = 'remove-btn';
            innerLoop1RemoveBtn.innerHTML = '√ó';
            innerLoop1RemoveBtn.onclick = function() { innerLoop1Wrapper.remove(); updateBlockCount(); };
            innerLoop1Block.appendChild(innerLoop1RemoveBtn);
            
            const innerLoop1NestedArea = document.createElement('div');
            innerLoop1NestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(innerLoop1NestedArea);
            innerLoop1Wrapper.appendChild(innerLoop1NestedArea);
            
            const innerLoop1CapsuleBottom = document.createElement('div');
            innerLoop1CapsuleBottom.className = 'block-capsule-bottom';
            innerLoop1CapsuleBottom.style.background = getComputedStyle(innerLoop1Block).background;
            innerLoop1Wrapper.appendChild(innerLoop1CapsuleBottom);
            
            mainNestedArea.appendChild(innerLoop1Wrapper);
            console.log("‚úì Premi√®re boucle imbriqu√©e cr√©√©e");
            
            // 6. Premi√®re condition "si p = 1 alors"
            const if1Wrapper = document.createElement('div');
            if1Wrapper.className = 'program-block block-capsule';
            if1Wrapper.innerHTML = `<div class="block sensing" data-type="if">si <select class="var-select" onclick="event.stopPropagation()"><option value="p" selected>p</option></select> <select class="compare-op" onclick="event.stopPropagation()"><option value="=">=</option></select> <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="text" value="1" onclick="event.stopPropagation()"></span> alors</div>`;
            
            const if1Block = if1Wrapper.querySelector('.block');
            const if1RemoveBtn = document.createElement('button');
            if1RemoveBtn.className = 'remove-btn';
            if1RemoveBtn.innerHTML = '√ó';
            if1RemoveBtn.onclick = function() { if1Wrapper.remove(); updateBlockCount(); };
            if1Block.appendChild(if1RemoveBtn);
            
            const if1NestedArea = document.createElement('div');
            if1NestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(if1NestedArea);
            if1Wrapper.appendChild(if1NestedArea);
            
            const if1CapsuleBottom = document.createElement('div');
            if1CapsuleBottom.className = 'block-capsule-bottom';
            if1CapsuleBottom.style.background = getComputedStyle(if1Block).background;
            if1Wrapper.appendChild(if1CapsuleBottom);
            
            innerLoop1NestedArea.appendChild(if1Wrapper);
            innerLoop1NestedArea.classList.remove('empty');
            
            // Ajouter les blocs dans if1: tourner droite, avancer, tourner gauche
            const right1Wrapper = document.createElement('div');
            right1Wrapper.className = 'program-block';
            right1Wrapper.innerHTML = `<div class="block motion" data-type="right">tourner ‚Üª droite</div>`;
            const right1Block = right1Wrapper.querySelector('.block');
            const right1RemoveBtn = document.createElement('button');
            right1RemoveBtn.className = 'remove-btn';
            right1RemoveBtn.innerHTML = '√ó';
            right1RemoveBtn.onclick = function() { right1Wrapper.remove(); updateBlockCount(); };
            right1Block.appendChild(right1RemoveBtn);
            if1NestedArea.appendChild(right1Wrapper);
            
            const forward1Wrapper = document.createElement('div');
            forward1Wrapper.className = 'program-block';
            forward1Wrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
            const forward1Block = forward1Wrapper.querySelector('.block');
            const forward1RemoveBtn = document.createElement('button');
            forward1RemoveBtn.className = 'remove-btn';
            forward1RemoveBtn.innerHTML = '√ó';
            forward1RemoveBtn.onclick = function() { forward1Wrapper.remove(); updateBlockCount(); };
            forward1Block.appendChild(forward1RemoveBtn);
            if1NestedArea.appendChild(forward1Wrapper);
            
            const left1Wrapper = document.createElement('div');
            left1Wrapper.className = 'program-block';
            left1Wrapper.innerHTML = `<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>`;
            const left1Block = left1Wrapper.querySelector('.block');
            const left1RemoveBtn = document.createElement('button');
            left1RemoveBtn.className = 'remove-btn';
            left1RemoveBtn.innerHTML = '√ó';
            left1RemoveBtn.onclick = function() { left1Wrapper.remove(); updateBlockCount(); };
            left1Block.appendChild(left1RemoveBtn);
            if1NestedArea.appendChild(left1Wrapper);
            if1NestedArea.classList.remove('empty');
            console.log("‚úì Condition 'si p = 1' cr√©√©e");
            
            // 7. Deuxi√®me condition "si p = -1 alors"
            const if2Wrapper = document.createElement('div');
            if2Wrapper.className = 'program-block block-capsule';
            if2Wrapper.innerHTML = `<div class="block sensing" data-type="if">si <select class="var-select" onclick="event.stopPropagation()"><option value="p" selected>p</option></select> <select class="compare-op" onclick="event.stopPropagation()"><option value="=">=</option></select> <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="text" value="-1" onclick="event.stopPropagation()"></span> alors</div>`;
            
            const if2Block = if2Wrapper.querySelector('.block');
            const if2RemoveBtn = document.createElement('button');
            if2RemoveBtn.className = 'remove-btn';
            if2RemoveBtn.innerHTML = '√ó';
            if2RemoveBtn.onclick = function() { if2Wrapper.remove(); updateBlockCount(); };
            if2Block.appendChild(if2RemoveBtn);
            
            const if2NestedArea = document.createElement('div');
            if2NestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(if2NestedArea);
            if2Wrapper.appendChild(if2NestedArea);
            
            const if2CapsuleBottom = document.createElement('div');
            if2CapsuleBottom.className = 'block-capsule-bottom';
            if2CapsuleBottom.style.background = getComputedStyle(if2Block).background;
            if2Wrapper.appendChild(if2CapsuleBottom);
            
            innerLoop1NestedArea.appendChild(if2Wrapper);
            
            // Ajouter les blocs dans if2: tourner gauche, avancer, tourner droite
            const left2Wrapper = document.createElement('div');
            left2Wrapper.className = 'program-block';
            left2Wrapper.innerHTML = `<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>`;
            const left2Block = left2Wrapper.querySelector('.block');
            const left2RemoveBtn = document.createElement('button');
            left2RemoveBtn.className = 'remove-btn';
            left2RemoveBtn.innerHTML = '√ó';
            left2RemoveBtn.onclick = function() { left2Wrapper.remove(); updateBlockCount(); };
            left2Block.appendChild(left2RemoveBtn);
            if2NestedArea.appendChild(left2Wrapper);
            
            const forward2Wrapper = document.createElement('div');
            forward2Wrapper.className = 'program-block';
            forward2Wrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
            const forward2Block = forward2Wrapper.querySelector('.block');
            const forward2RemoveBtn = document.createElement('button');
            forward2RemoveBtn.className = 'remove-btn';
            forward2RemoveBtn.innerHTML = '√ó';
            forward2RemoveBtn.onclick = function() { forward2Wrapper.remove(); updateBlockCount(); };
            forward2Block.appendChild(forward2RemoveBtn);
            if2NestedArea.appendChild(forward2Wrapper);
            
            const right2Wrapper = document.createElement('div');
            right2Wrapper.className = 'program-block';
            right2Wrapper.innerHTML = `<div class="block motion" data-type="right">tourner ‚Üª droite</div>`;
            const right2Block = right2Wrapper.querySelector('.block');
            const right2RemoveBtn = document.createElement('button');
            right2RemoveBtn.className = 'remove-btn';
            right2RemoveBtn.innerHTML = '√ó';
            right2RemoveBtn.onclick = function() { right2Wrapper.remove(); updateBlockCount(); };
            right2Block.appendChild(right2RemoveBtn);
            if2NestedArea.appendChild(right2Wrapper);
            if2NestedArea.classList.remove('empty');
            console.log("‚úì Condition 'si p = -1' cr√©√©e");
            
            // 8. Ajouter "avancer" dans la premi√®re boucle "r√©p√©ter i fois" (apr√®s les conditions)
            const forward3Wrapper = document.createElement('div');
            forward3Wrapper.className = 'program-block';
            forward3Wrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
            const forward3Block = forward3Wrapper.querySelector('.block');
            const forward3RemoveBtn = document.createElement('button');
            forward3RemoveBtn.className = 'remove-btn';
            forward3RemoveBtn.innerHTML = '√ó';
            forward3RemoveBtn.onclick = function() { forward3Wrapper.remove(); updateBlockCount(); };
            forward3Block.appendChild(forward3RemoveBtn);
            innerLoop1NestedArea.appendChild(forward3Wrapper);
            
            // 9. Ajouter "couleur" dans la premi√®re boucle "r√©p√©ter i fois"
            const color2Wrapper = document.createElement('div');
            color2Wrapper.className = 'program-block';
            color2Wrapper.innerHTML = `<div class="block looks" data-type="color" data-value="${randomColor}">couleur ${randomColorName}</div>`;
            const color2Block = color2Wrapper.querySelector('.block');
            const color2RemoveBtn = document.createElement('button');
            color2RemoveBtn.className = 'remove-btn';
            color2RemoveBtn.innerHTML = '√ó';
            color2RemoveBtn.onclick = function() { color2Wrapper.remove(); updateBlockCount(); };
            color2Block.appendChild(color2RemoveBtn);
            innerLoop1NestedArea.appendChild(color2Wrapper);
            console.log("‚úì Avancer et couleur ajout√©s dans la premi√®re boucle r√©p√©ter i fois");
            
            // 10. Ajouter "tourner gauche" (premier tourner gauche)
            const left3Wrapper = document.createElement('div');
            left3Wrapper.className = 'program-block';
            left3Wrapper.innerHTML = `<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>`;
            const left3Block = left3Wrapper.querySelector('.block');
            const left3RemoveBtn = document.createElement('button');
            left3RemoveBtn.className = 'remove-btn';
            left3RemoveBtn.innerHTML = '√ó';
            left3RemoveBtn.onclick = function() { left3Wrapper.remove(); updateBlockCount(); };
            left3Block.appendChild(left3RemoveBtn);
            mainNestedArea.appendChild(left3Wrapper);
            
            // 11. Cr√©er la deuxi√®me boucle imbriqu√©e "r√©p√©ter i fois"
            const innerLoop2Wrapper = document.createElement('div');
            innerLoop2Wrapper.className = 'program-block block-capsule';
            const innerLoop2HTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span> fois</div>`;
            innerLoop2Wrapper.innerHTML = innerLoop2HTML;
            
            const innerLoop2ValueSlot = innerLoop2Wrapper.querySelector('.value-slot');
            const innerLoop2VarBlock = document.createElement('div');
            innerLoop2VarBlock.className = 'block variables';
            innerLoop2VarBlock.setAttribute('data-type', 'var-value');
            innerLoop2VarBlock.innerHTML = `<select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select>`;
            innerLoop2ValueSlot.appendChild(innerLoop2VarBlock);
            
            const innerLoop2Block = innerLoop2Wrapper.querySelector('.block');
            const innerLoop2RemoveBtn = document.createElement('button');
            innerLoop2RemoveBtn.className = 'remove-btn';
            innerLoop2RemoveBtn.innerHTML = '√ó';
            innerLoop2RemoveBtn.onclick = function() { innerLoop2Wrapper.remove(); updateBlockCount(); };
            innerLoop2Block.appendChild(innerLoop2RemoveBtn);
            
            const innerLoop2NestedArea = document.createElement('div');
            innerLoop2NestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(innerLoop2NestedArea);
            innerLoop2Wrapper.appendChild(innerLoop2NestedArea);
            
            const innerLoop2CapsuleBottom = document.createElement('div');
            innerLoop2CapsuleBottom.className = 'block-capsule-bottom';
            innerLoop2CapsuleBottom.style.background = getComputedStyle(innerLoop2Block).background;
            innerLoop2Wrapper.appendChild(innerLoop2CapsuleBottom);
            
            mainNestedArea.appendChild(innerLoop2Wrapper);
            console.log("‚úì Deuxi√®me boucle imbriqu√©e cr√©√©e");
            
            // 12. Ajouter "avancer" dans la deuxi√®me boucle imbriqu√©e
            const forward4Wrapper = document.createElement('div');
            forward4Wrapper.className = 'program-block';
            forward4Wrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
            const forward4Block = forward4Wrapper.querySelector('.block');
            const forward4RemoveBtn = document.createElement('button');
            forward4RemoveBtn.className = 'remove-btn';
            forward4RemoveBtn.innerHTML = '√ó';
            forward4RemoveBtn.onclick = function() { forward4Wrapper.remove(); updateBlockCount(); };
            forward4Block.appendChild(forward4RemoveBtn);
            innerLoop2NestedArea.appendChild(forward4Wrapper);
            innerLoop2NestedArea.classList.remove('empty');
            
            // 15. Ajouter "tourner gauche"
            const left4Wrapper = document.createElement('div');
            left4Wrapper.className = 'program-block';
            left4Wrapper.innerHTML = `<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>`;
            const left4Block = left4Wrapper.querySelector('.block');
            const left4RemoveBtn = document.createElement('button');
            left4RemoveBtn.className = 'remove-btn';
            left4RemoveBtn.innerHTML = '√ó';
            left4RemoveBtn.onclick = function() { left4Wrapper.remove(); updateBlockCount(); };
            left4Block.appendChild(left4RemoveBtn);
            mainNestedArea.appendChild(left4Wrapper);
            console.log("‚úì Tourner gauche ajout√©");
            
            // 16. Cr√©er "mettre p √† (p √ó -1)"
            const setPWrapper = document.createElement('div');
            setPWrapper.className = 'program-block';
            const setPBlock = document.createElement('div');
            setPBlock.className = 'block variables';
            setPBlock.setAttribute('data-type', 'variable');
            setPBlock.innerHTML = `mettre <select onclick="event.stopPropagation()" class="var-select"><option value="p" selected>p</option></select> √† <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span>`;
            createOperatorInValueSlot(setPBlock, 'p', '*', '-1');
            const setPRemoveBtn = document.createElement('button');
            setPRemoveBtn.className = 'remove-btn';
            setPRemoveBtn.innerHTML = '√ó';
            setPRemoveBtn.onclick = function() { setPWrapper.remove(); updateBlockCount(); };
            setPBlock.appendChild(setPRemoveBtn);
            setPWrapper.appendChild(setPBlock);
            mainNestedArea.appendChild(setPWrapper);
            console.log("‚úì Bloc mettre p √† (p √ó -1) cr√©√©");
            
            // Mettre √† jour l'affichage
            updateAllVariableSelectors();
            updateVariableBlocksVisibility();
            updateBlockCount();
            
            console.log("=== Programme croix g√©n√©r√© avec succ√®s ! ===");
            showResult('‚úÖ Programme Croix g√©n√©r√© avec succ√®s !', true);
        }
        
        // G√©n√©rer le programme pour le carr√©
        function generateSquareProgram() {
            console.log("=== G√©n√©ration du carr√© ===");
            
            // Choisir une couleur al√©atoire
            const colors = ['red', 'yellow', 'green', 'blue', 'black'];
            const colorNames = {
                'red': 'ROUGE',
                'yellow': 'JAUNE',
                'green': 'VERT',
                'blue': 'BLEU',
                'black': 'NOIR'
            };
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            const randomColorName = colorNames[randomColor];
            console.log("Couleur al√©atoire:", randomColor, "(" + randomColorName + ")");
            
            // G√©n√©rer une valeur al√©atoire pour i entre 1 et 9
            const randomI = Math.floor(Math.random() * 9) + 1; // 1 √† 9
            console.log("Valeur de i:", randomI, "(carr√© de taille", randomI + "√ó" + randomI + ")");
            
            // Calculer la position de la fl√®che
            // Le carr√© fait i√ói cases
            // Pour ne pas toucher les bords, on doit √™tre √† au moins (i-1) cases des bords
            // Si i=9, le carr√© fait 9√ó9, donc la fl√®che doit √™tre en (9,0) = premi√®re case en bas √† gauche
            // Si i=1, le carr√© fait 1√ó1, on peut √™tre n'importe o√π sauf les bords
            
            // Position: ligne 9-i+1 √† 9 (partie basse), colonne 0 √† 9-i (partie gauche)
            const minRow = Math.max(1, 10 - randomI); // Ne pas √™tre sur ligne 0
            const maxRow = 9; // Toujours en bas
            const minCol = 0;
            const maxCol = Math.max(0, 9 - randomI); // Laisser la place pour i cases √† droite
            
            let targetRow, targetCol;
            
            if (randomI === 9) {
                // Cas sp√©cial: carr√© 9√ó9, forcer position (9, 0)
                targetRow = 9;
                targetCol = 0;
            } else {
                // Position al√©atoire dans la plage autoris√©e
                targetRow = minRow + Math.floor(Math.random() * (maxRow - minRow + 1));
                targetCol = minCol + Math.floor(Math.random() * (maxCol - minCol + 1));
            }
            
            console.log("Position cible: ligne", targetRow, "colonne", targetCol);
            console.log("Plage autoris√©e: lignes [" + minRow + "-" + maxRow + "], colonnes [" + minCol + "-" + maxCol + "]");
            
            // Calculer le d√©placement depuis la position de d√©part (9, 5)
            const startRow = 9;
            const startCol = 5;
            const deltaRow = targetRow - startRow;
            const deltaCol = targetCol - startCol;
            console.log("D√©placement: deltaRow =", deltaRow, ", deltaCol =", deltaCol);
            
            // Cr√©er la variable i
            if (!createdVariables.includes('i')) {
                createdVariables.push('i');
            }
            variables['i'] = randomI;
            updateVariableDisplay();
            console.log("Variable cr√©√©e: i=" + randomI);
            
            // G√©n√©rer les blocs de d√©placement initial avec garantie d'orientation vers le haut
            generateInitialMovementForCheckerboard(deltaRow, deltaCol);
            
            // 1. Cr√©er "mettre i √† [randomI]"
            const varIHTML = `<div class="block variables" data-type="variable">mettre <select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select> √† <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${randomI}" onclick="event.stopPropagation()"></span></div>`;
            addBlockToProgram({ 
                type: 'variable',
                html: varIHTML,
                selectValues: ['i']
            });
            console.log("‚úì Variable i cr√©√©e");
            
            // 2. Cr√©er la boucle externe "r√©p√©ter 4 fois"
            const outerLoopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="4" onclick="event.stopPropagation()"></span> fois</div>`;
            addBlockToProgram({ 
                type: 'repeat',
                html: outerLoopHTML
            });
            console.log("‚úì Boucle externe cr√©√©e (4 fois)");
            
            const programBlocks = document.getElementById('program-blocks');
            const outerLoopBlock = programBlocks.lastElementChild;
            const outerNestedArea = outerLoopBlock.querySelector('.nested-blocks');
            
            // 3. Cr√©er la boucle interne "r√©p√©ter i fois"
            const innerLoopWrapper = document.createElement('div');
            innerLoopWrapper.className = 'program-block block-capsule';
            const innerLoopHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"></span> fois</div>`;
            innerLoopWrapper.innerHTML = innerLoopHTML;
            
            const innerLoopValueSlot = innerLoopWrapper.querySelector('.value-slot');
            const innerLoopVarBlock = document.createElement('div');
            innerLoopVarBlock.className = 'block variables';
            innerLoopVarBlock.setAttribute('data-type', 'var-value');
            innerLoopVarBlock.innerHTML = `<select onclick="event.stopPropagation()" class="var-select"><option value="i" selected>i</option></select>`;
            innerLoopValueSlot.appendChild(innerLoopVarBlock);
            
            const innerLoopBlock = innerLoopWrapper.querySelector('.block');
            const innerLoopRemoveBtn = document.createElement('button');
            innerLoopRemoveBtn.className = 'remove-btn';
            innerLoopRemoveBtn.innerHTML = '√ó';
            innerLoopRemoveBtn.onclick = function() { innerLoopWrapper.remove(); updateBlockCount(); };
            innerLoopBlock.appendChild(innerLoopRemoveBtn);
            
            const innerNestedArea = document.createElement('div');
            innerNestedArea.className = 'nested-blocks empty';
            setupNestedAreaDrop(innerNestedArea);
            innerLoopWrapper.appendChild(innerNestedArea);
            
            const innerCapsuleBottom = document.createElement('div');
            innerCapsuleBottom.className = 'block-capsule-bottom';
            innerCapsuleBottom.style.background = getComputedStyle(innerLoopBlock).background;
            innerLoopWrapper.appendChild(innerCapsuleBottom);
            
            outerNestedArea.appendChild(innerLoopWrapper);
            outerNestedArea.classList.remove('empty');
            console.log("‚úì Boucle interne cr√©√©e (i fois)");
            
            // 4. Ajouter "couleur" dans la boucle interne
            const colorWrapper = document.createElement('div');
            colorWrapper.className = 'program-block';
            colorWrapper.innerHTML = `<div class="block looks" data-type="color" data-value="${randomColor}">couleur ${randomColorName}</div>`;
            const colorBlock = colorWrapper.querySelector('.block');
            const colorRemoveBtn = document.createElement('button');
            colorRemoveBtn.className = 'remove-btn';
            colorRemoveBtn.innerHTML = '√ó';
            colorRemoveBtn.onclick = function() { colorWrapper.remove(); updateBlockCount(); };
            colorBlock.appendChild(colorRemoveBtn);
            innerNestedArea.appendChild(colorWrapper);
            innerNestedArea.classList.remove('empty');
            console.log("‚úì Couleur ajout√©e");
            
            // 5. Ajouter "avancer" dans la boucle interne
            const forwardWrapper = document.createElement('div');
            forwardWrapper.className = 'program-block';
            forwardWrapper.innerHTML = '<div class="block motion" data-type="forward">avancer</div>';
            const forwardBlock = forwardWrapper.querySelector('.block');
            const forwardRemoveBtn = document.createElement('button');
            forwardRemoveBtn.className = 'remove-btn';
            forwardRemoveBtn.innerHTML = '√ó';
            forwardRemoveBtn.onclick = function() { forwardWrapper.remove(); updateBlockCount(); };
            forwardBlock.appendChild(forwardRemoveBtn);
            innerNestedArea.appendChild(forwardWrapper);
            console.log("‚úì Avancer ajout√©");
            
            // 6. Ajouter "tourner droite" dans la boucle externe
            const rightWrapper = document.createElement('div');
            rightWrapper.className = 'program-block';
            rightWrapper.innerHTML = `<div class="block motion" data-type="right">tourner ‚Üª droite</div>`;
            const rightBlock = rightWrapper.querySelector('.block');
            const rightRemoveBtn = document.createElement('button');
            rightRemoveBtn.className = 'remove-btn';
            rightRemoveBtn.innerHTML = '√ó';
            rightRemoveBtn.onclick = function() { rightWrapper.remove(); updateBlockCount(); };
            rightBlock.appendChild(rightRemoveBtn);
            outerNestedArea.appendChild(rightWrapper);
            console.log("‚úì Tourner droite ajout√©");
            
            // Mettre √† jour l'affichage
            updateAllVariableSelectors();
            updateVariableBlocksVisibility();
            updateBlockCount();
            
            console.log("=== Programme carr√© g√©n√©r√© avec succ√®s ! ===");
            showResult('‚úÖ Programme Carr√© g√©n√©r√© avec succ√®s !', true);
        }
        
        // Supprimer la fonction createProgramBlockElement qui n'est plus utilis√©e
        
        // G√©n√©rer le programme basique (sans boucles)
        function generateBasicProgram(optimizedPath) {
            const program = [];
            
            // Position de d√©part de la tortue
            let currentPos = { row: 9, col: 5 };
            let currentDirection = 0;
            
            console.log("Position de d√©part:", currentPos, "Direction:", currentDirection);
            
            optimizedPath.forEach((cell, index) => {
                console.log(`\nTraitement cellule ${index + 1}:`, cell);
                
                // Calculer le chemin vers cette cellule
                const pathResult = calculatePathToCell(currentPos, cell, currentDirection);
                
                console.log("Mouvements √† effectuer:", pathResult.moves);
                
                // Ajouter les mouvements au programme
                pathResult.moves.forEach(move => {
                    program.push({
                        type: move.type,
                        blockType: 'movement'
                    });
                });
                
                // Ajouter le bloc de couleur
                program.push({
                    type: 'color',
                    value: cell.color,
                    blockType: 'color'
                });
                
                // Mettre √† jour la position et direction actuelles
                currentPos = { row: cell.row, col: cell.col };
                currentDirection = pathResult.finalDirection;
            });
            
            return program;
        }
        
        // DIFFICULT√â 2: Optimiser le programme avec des boucles "r√©p√©ter"
        function optimizeWithLoops(program) {
            const optimized = [];
            let i = 0;
            
            while (i < program.length) {
                const current = program[i];
                
                // Chercher des s√©quences r√©p√©titives
                const pattern = findRepeatPattern(program, i);
                
                if (pattern && pattern.count >= 2) {
                    // On a trouv√© un motif r√©p√©titif !
                    console.log(`Pattern trouv√©: ${pattern.length} blocs r√©p√©t√©s ${pattern.count} fois`);
                    
                    optimized.push({
                        type: 'repeat',
                        times: pattern.count,
                        nested: pattern.blocks,
                        blockType: 'loop'
                    });
                    
                    i += pattern.length * pattern.count;
                } else {
                    // Pas de r√©p√©tition, ajouter le bloc tel quel
                    optimized.push(current);
                    i++;
                }
            }
            
            return optimized;
        }
        
        // Trouver un motif r√©p√©titif √† partir d'une position
        function findRepeatPattern(program, startIndex) {
            // Tester diff√©rentes longueurs de motif (de 2 √† 10 blocs)
            for (let patternLength = 2; patternLength <= Math.min(10, program.length - startIndex); patternLength++) {
                const pattern = program.slice(startIndex, startIndex + patternLength);
                let repeatCount = 1;
                let currentIndex = startIndex + patternLength;
                
                // Compter combien de fois le motif se r√©p√®te
                while (currentIndex + patternLength <= program.length) {
                    const nextSegment = program.slice(currentIndex, currentIndex + patternLength);
                    
                    if (patternsMatch(pattern, nextSegment)) {
                        repeatCount++;
                        currentIndex += patternLength;
                    } else {
                        break;
                    }
                }
                
                // Si le motif se r√©p√®te au moins 2 fois, on le retourne
                if (repeatCount >= 2) {
                    return {
                        blocks: pattern,
                        length: patternLength,
                        count: repeatCount
                    };
                }
            }
            
            return null;
        }
        
        // V√©rifier si deux motifs sont identiques
        function patternsMatch(pattern1, pattern2) {
            if (pattern1.length !== pattern2.length) return false;
            
            for (let i = 0; i < pattern1.length; i++) {
                if (pattern1[i].type !== pattern2[i].type) return false;
                if (pattern1[i].type === 'color' && pattern1[i].value !== pattern2[i].value) return false;
            }
            
            return true;
        }
        
        // Ajouter les blocs du programme √† l'interface
        function addProgramBlocks(program) {
            program.forEach(block => {
                if (block.type === 'repeat') {
                    // Cr√©er un bloc r√©p√©ter avec blocs imbriqu√©s
                    const repeatHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${block.times}" min="1" max="100" onclick="event.stopPropagation()"></span> fois</div>`;
                    addBlockToProgram({ 
                        type: 'repeat', 
                        html: repeatHTML 
                    });
                    
                    // Ajouter les blocs imbriqu√©s
                    const programBlocks = document.getElementById('program-blocks');
                    const lastBlock = programBlocks.lastElementChild;
                    const nestedArea = lastBlock.querySelector('.nested-blocks');
                    
                    if (nestedArea && block.nested) {
                        block.nested.forEach(nestedBlock => {
                            addNestedBlockFromData(nestedBlock, nestedArea);
                        });
                        nestedArea.classList.remove('empty');
                    }
                } else if (block.type === 'variable') {
                    // Cr√©er un bloc variable
                    let blockHTML = `<div class="block variables" data-type="variable">mettre <select onclick="event.stopPropagation()" class="var-select"><option value="${block.varName}">${block.varName}</option></select> √† <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${block.varValue || '0'}" onclick="event.stopPropagation()"></span></div>`;
                    
                    addBlockToProgram({ 
                        type: 'variable',
                        html: blockHTML,
                        selectValues: [block.varName]
                    });
                    
                    // Ajouter la variable √† la liste si elle n'existe pas
                    if (!createdVariables.includes(block.varName)) {
                        createdVariables.push(block.varName);
                        updateAllVariableSelectors();
                        updateVariableBlocksVisibility();
                    }
                } else if (block.type === 'change-var') {
                    // Cr√©er un bloc ajouter √† variable
                    let blockHTML = `<div class="block variables" data-type="change-var">ajouter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${block.changeValue || '1'}" onclick="event.stopPropagation()"></span> √† <select onclick="event.stopPropagation()" class="var-select"><option value="${block.varName}">${block.varName}</option></select></div>`;
                    
                    addBlockToProgram({ 
                        type: 'change-var',
                        html: blockHTML,
                        selectValues: [block.varName]
                    });
                } else if (block.type === 'if') {
                    // Cr√©er un bloc condition
                    let blockHTML = `<div class="block sensing" data-type="if">si <select class="var-select" onclick="event.stopPropagation()"><option value="${block.varName}">${block.varName}</option></select> <select class="compare-op" onclick="event.stopPropagation()"><option value="${block.operator}">${block.operator}</option></select> <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="text" placeholder="valeur" value="${block.compareValue}" onclick="event.stopPropagation()"></span> alors</div>`;
                    
                    addBlockToProgram({ 
                        type: 'if',
                        html: blockHTML,
                        selectValues: [block.varName, block.operator]
                    });
                    
                    // Ajouter les blocs imbriqu√©s
                    const programBlocks = document.getElementById('program-blocks');
                    const lastBlock = programBlocks.lastElementChild;
                    const nestedArea = lastBlock.querySelector('.nested-blocks');
                    
                    if (nestedArea && block.nested) {
                        block.nested.forEach(nestedBlock => {
                            addNestedBlockFromData(nestedBlock, nestedArea);
                        });
                        nestedArea.classList.remove('empty');
                    }
                } else {
                    // Bloc simple
                    let blockHTML = '';
                    
                    if (block.type === 'forward') {
                        blockHTML = '<div class="block motion" data-type="forward">avancer</div>';
                    } else if (block.type === 'right') {
                        blockHTML = '<div class="block motion" data-type="right">tourner ‚Üª droite</div>';
                    } else if (block.type === 'left') {
                        blockHTML = '<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>';
                    } else if (block.type === 'color') {
                        const colorUpper = block.value.toUpperCase();
                        blockHTML = `<div class="block looks" data-type="color" data-value="${block.value}">couleur ${colorUpper}</div>`;
                    }
                    
                    if (blockHTML) {
                        addBlockToProgram({ 
                            type: block.type, 
                            value: block.value,
                            html: blockHTML 
                        });
                    }
                }
            });
        }
        
        // Ajouter un bloc imbriqu√© depuis les donn√©es
        function addNestedBlockFromData(blockData, nestedArea) {
            // G√©rer les blocs imbriqu√©s complexes (r√©p√©ter, if dans une boucle)
            if (blockData.type === 'repeat' || blockData.type === 'if') {
                let blockHTML = '';
                
                if (blockData.type === 'repeat') {
                    blockHTML = `<div class="block control" data-type="repeat">r√©p√©ter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${blockData.times}" min="1" max="100" onclick="event.stopPropagation()"></span> fois</div>`;
                } else if (blockData.type === 'if') {
                    blockHTML = `<div class="block sensing" data-type="if">si <select class="var-select" onclick="event.stopPropagation()"><option value="${blockData.varName}">${blockData.varName}</option></select> <select class="compare-op" onclick="event.stopPropagation()"><option value="${blockData.operator}">${blockData.operator}</option></select> <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="text" placeholder="valeur" value="${blockData.compareValue}" onclick="event.stopPropagation()"></span> alors</div>`;
                }
                
                const wrapper = document.createElement('div');
                wrapper.innerHTML = blockHTML;
                addNestedBlock({ type: blockData.type, html: wrapper.innerHTML }, nestedArea);
                
                // Ajouter les blocs doublement imbriqu√©s
                if (blockData.nested) {
                    const addedBlock = nestedArea.lastElementChild;
                    const doubleNestedArea = addedBlock.querySelector('.nested-blocks');
                    if (doubleNestedArea) {
                        blockData.nested.forEach(deepBlock => {
                            addNestedBlockFromData(deepBlock, doubleNestedArea);
                        });
                        doubleNestedArea.classList.remove('empty');
                    }
                }
                
                return;
            }
            
            // Blocs simples
            let blockHTML = '';
            
            if (blockData.type === 'forward') {
                blockHTML = '<div class="block motion" data-type="forward">avancer</div>';
            } else if (blockData.type === 'right') {
                blockHTML = '<div class="block motion" data-type="right">tourner ‚Üª droite</div>';
            } else if (blockData.type === 'left') {
                blockHTML = '<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>';
            } else if (blockData.type === 'color') {
                const colorUpper = blockData.value.toUpperCase();
                blockHTML = `<div class="block looks" data-type="color" data-value="${blockData.value}">couleur ${colorUpper}</div>`;
            } else if (blockData.type === 'variable') {
                blockHTML = `<div class="block variables" data-type="variable">mettre <select onclick="event.stopPropagation()" class="var-select"><option value="${blockData.varName}">${blockData.varName}</option></select> √† <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${blockData.varValue || '0'}" onclick="event.stopPropagation()"></span></div>`;
            } else if (blockData.type === 'change-var') {
                blockHTML = `<div class="block variables" data-type="change-var">ajouter <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)"><input type="number" value="${blockData.changeValue || '1'}" onclick="event.stopPropagation()"></span> √† <select onclick="event.stopPropagation()" class="var-select"><option value="${blockData.varName}">${blockData.varName}</option></select></div>`;
            }
            
            if (blockHTML) {
                const wrapper = document.createElement('div');
                wrapper.innerHTML = blockHTML;
                addNestedBlock({ type: blockData.type, value: blockData.value, html: wrapper.innerHTML }, nestedArea);
            }
        }
        
        // Compter le nombre de boucles dans un programme
        function countLoops(program) {
            return program.filter(block => block.type === 'repeat').length;
        }
        
        function optimizePath(cells) {
            if (cells.length === 0) return [];
            
            const startPos = { row: 9, col: 5 }; // Position de d√©part
            const remaining = [...cells];
            const optimized = [];
            let current = startPos;
            let currentColor = null;
            
            // Tant qu'il reste des cellules √† visiter
            while (remaining.length > 0) {
                let minDistance = Infinity;
                let nearestIndex = 0;
                let foundSameColor = false;
                
                // PRIORIT√â 1: Chercher d'abord une cellule de la m√™me couleur √† proximit√©
                if (currentColor !== null) {
                    remaining.forEach((cell, index) => {
                        if (cell.color === currentColor) {
                            const distance = manhattanDistance(current, cell);
                            // Bonus : consid√©rer les cellules de m√™me couleur comme 30% plus proches
                            const adjustedDistance = distance * 0.7;
                            if (adjustedDistance < minDistance) {
                                minDistance = adjustedDistance;
                                nearestIndex = index;
                                foundSameColor = true;
                            }
                        }
                    });
                }
                
                // PRIORIT√â 2: Si pas de m√™me couleur √† proximit√©, prendre la plus proche
                if (!foundSameColor) {
                    minDistance = Infinity;
                    remaining.forEach((cell, index) => {
                        const distance = manhattanDistance(current, cell);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestIndex = index;
                        }
                    });
                }
                
                // Ajouter la cellule s√©lectionn√©e au chemin
                const nearest = remaining[nearestIndex];
                optimized.push(nearest);
                current = nearest;
                currentColor = nearest.color;
                
                // Retirer la cellule du tableau des restantes
                remaining.splice(nearestIndex, 1);
            }
            
            return optimized;
        }
        
        // Calculer la distance de Manhattan entre deux positions
        function manhattanDistance(pos1, pos2) {
            return Math.abs(pos1.row - pos2.row) + Math.abs(pos1.col - pos2.col);
        }
        
        // Calculer le chemin complet vers une cellule cible
        function calculatePathToCell(from, to, startDirection) {
            const moves = [];
            let currentDir = startDirection;
            
            // Calculer les d√©placements n√©cessaires
            const deltaRow = to.row - from.row; // Positif = vers le bas, N√©gatif = vers le haut
            const deltaCol = to.col - from.col; // Positif = vers la droite, N√©gatif = vers la gauche
            
            console.log(`  Delta: row=${deltaRow}, col=${deltaCol}`);
            
            // OPTIMISATION 2: Choisir l'ordre vertical/horizontal selon la direction actuelle
            // pour minimiser les rotations
            const needsVertical = deltaRow !== 0;
            const needsHorizontal = deltaCol !== 0;
            
            // D√©terminer quelle direction n√©cessite moins de rotations
            let doVerticalFirst = true;
            
            if (needsVertical && needsHorizontal) {
                const verticalDir = deltaRow > 0 ? 2 : 0;
                const horizontalDir = deltaCol > 0 ? 1 : 3;
                
                const verticalRotations = countRotations(currentDir, verticalDir);
                const horizontalRotations = countRotations(currentDir, horizontalDir);
                
                // Faire d'abord le mouvement qui n√©cessite le moins de rotations
                doVerticalFirst = verticalRotations <= horizontalRotations;
            }
            
            // Ex√©cuter les mouvements dans l'ordre optimal
            if (doVerticalFirst) {
                // Phase 1: D√©placement vertical
                if (needsVertical) {
                    const targetDir = deltaRow > 0 ? 2 : 0;
                    const rotations = getRotationMoves(currentDir, targetDir);
                    moves.push(...rotations);
                    currentDir = targetDir;
                    
                    const distance = Math.abs(deltaRow);
                    for (let i = 0; i < distance; i++) {
                        moves.push({ type: 'forward' });
                    }
                }
                
                // Phase 2: D√©placement horizontal
                if (needsHorizontal) {
                    const targetDir = deltaCol > 0 ? 1 : 3;
                    const rotations = getRotationMoves(currentDir, targetDir);
                    moves.push(...rotations);
                    currentDir = targetDir;
                    
                    const distance = Math.abs(deltaCol);
                    for (let i = 0; i < distance; i++) {
                        moves.push({ type: 'forward' });
                    }
                }
            } else {
                // Phase 1: D√©placement horizontal d'abord
                if (needsHorizontal) {
                    const targetDir = deltaCol > 0 ? 1 : 3;
                    const rotations = getRotationMoves(currentDir, targetDir);
                    moves.push(...rotations);
                    currentDir = targetDir;
                    
                    const distance = Math.abs(deltaCol);
                    for (let i = 0; i < distance; i++) {
                        moves.push({ type: 'forward' });
                    }
                }
                
                // Phase 2: D√©placement vertical
                if (needsVertical) {
                    const targetDir = deltaRow > 0 ? 2 : 0;
                    const rotations = getRotationMoves(currentDir, targetDir);
                    moves.push(...rotations);
                    currentDir = targetDir;
                    
                    const distance = Math.abs(deltaRow);
                    for (let i = 0; i < distance; i++) {
                        moves.push({ type: 'forward' });
                    }
                }
            }
            
            return {
                moves: moves,
                finalDirection: currentDir
            };
        }
        
        // Compter le nombre de rotations n√©cessaires
        function countRotations(fromDir, toDir) {
            let diff = toDir - fromDir;
            if (diff > 2) diff -= 4;
            if (diff < -2) diff += 4;
            return Math.abs(diff);
        }
        
        // Calculer les rotations n√©cessaires pour passer d'une direction √† une autre
        function getRotationMoves(fromDir, toDir) {
            const moves = [];
            let diff = toDir - fromDir;
            
            // Normaliser la diff√©rence entre -3 et 3
            if (diff > 2) diff -= 4;
            if (diff < -2) diff += 4;
            
            if (diff === 1) {
                // Tourner √† droite une fois
                moves.push({ type: 'right' });
            } else if (diff === -1) {
                // Tourner √† gauche une fois
                moves.push({ type: 'left' });
            } else if (diff === 2 || diff === -2) {
                // Faire demi-tour (deux rotations √† droite)
                moves.push({ type: 'right' });
                moves.push({ type: 'right' });
            }
            
            return moves;
        }
        
        function clearPaintedCells() {
            paintedCells = {};
            const teacherGrid = document.getElementById('teacher-grid');
            if (teacherGrid) {
                const cells = teacherGrid.querySelectorAll('.grid-cell');
                cells.forEach(cell => {
                    cell.style.backgroundColor = 'white';
                });
            }
        }
        
        function getPaintedCellsData() {
            // Retourne une copie des cellules peintes pour sauvegarde
            return JSON.parse(JSON.stringify(paintedCells));
        }
        
        function loadPaintedCells(data) {
            // Charger les cellules peintes depuis les donn√©es sauvegard√©es
            if (!data) return;
            
            paintedCells = JSON.parse(JSON.stringify(data));
            const teacherGrid = document.getElementById('teacher-grid');
            if (!teacherGrid) return;
            
            const cells = teacherGrid.querySelectorAll('.grid-cell');
            
            // R√©initialiser toutes les cellules
            cells.forEach(cell => {
                cell.style.backgroundColor = 'white';
            });
            
            // Utiliser la m√™me colorMap que dans le reste de l'app
            const colorMap = {
                'red': '#dc3545',
                'yellow': '#ffc107',
                'green': '#28a745',
                'blue': '#007bff',
                'black': '#343a40'
            };
            
            // Appliquer les couleurs sauvegard√©es
            for (let [cellKey, color] of Object.entries(paintedCells)) {
                const [row, col] = cellKey.split('-').map(Number);
                const index = row * GRID_SIZE + col;
                if (cells[index]) {
                    cells[index].style.backgroundColor = colorMap[color] || '#FFFFFF';
                }
            }
        }
        // ===== FIN MODULE PINCEAU =====
        
        // Raccourci clavier P pour mode professeur et ECHAP pour fermer la modal
        document.addEventListener('keydown', function(e) {
            if (e.key === 'p' || e.key === 'P') {
                // Ne pas d√©clencher si on est en train de taper dans un input
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                    e.preventDefault(); // Emp√™cher la touche P de s'√©crire
                    switchMode('teacher');
                }
            }
            
            // Fermer la modal de mot de passe avec ECHAP
            if (e.key === 'Escape') {
                const passwordModal = document.getElementById('password-modal');
                if (passwordModal.classList.contains('active')) {
                    closePasswordModal();
                }
            }
        });

        function updateModeDisplay() {
            const studentLeft = document.getElementById('student-left');
            const teacherLeft = document.getElementById('teacher-left');
            const modeBtns = document.querySelectorAll('.mode-btn');
            const headerScore = document.getElementById('header-score-display');
            const appHeader = document.getElementById('app-header');
            const headerSubtitle = document.getElementById('header-subtitle');
            const loadLevelsBtn = document.getElementById('load-levels-btn');
            const saveOnlineBtn = document.getElementById('save-online-btn');

            if (currentMode === 'student') {
                studentLeft.style.display = 'block';
                teacherLeft.style.display = 'none';
                modeBtns[0].classList.remove('active');
                modeBtns[1].classList.remove('active');
                modeBtns[2].classList.add('active');
                modeBtns[3].classList.remove('active');
                headerScore.style.display = 'block'; // Afficher le score en mode √©l√®ve
                appHeader.classList.remove('teacher-mode'); // Couleur bleue par d√©faut
                document.body.classList.remove('teacher-mode'); // Retirer classe du body
                headerSubtitle.style.display = 'none'; // Masquer le sous-titre
                loadLevelsBtn.style.display = 'none'; // Masquer le bouton charger
                saveOnlineBtn.style.display = 'none'; // Masquer le bouton sauvegarder
                // Recharger les niveaux √©l√®ve pour afficher les nouveaux niveaux cr√©√©s
                loadCursusLevels();
            } else {
                studentLeft.style.display = 'none';
                teacherLeft.style.display = 'block';
                modeBtns[0].classList.remove('active');
                modeBtns[1].classList.remove('active');
                modeBtns[2].classList.remove('active');
                modeBtns[3].classList.add('active');
                headerScore.style.display = 'none'; // Masquer le score en mode professeur
                appHeader.classList.add('teacher-mode'); // Couleur violette pour le mode professeur
                document.body.classList.add('teacher-mode'); // Ajouter classe au body
                headerSubtitle.style.display = 'block'; // Afficher le sous-titre
                loadLevelsBtn.style.display = 'block'; // Afficher le bouton charger
                saveOnlineBtn.style.display = 'block'; // Afficher le bouton sauvegarder
                
                // Initialiser le mode pinceau en mode professeur
                setTimeout(() => {
                    initPaintMode();
                }, 100);
            }
            
            // Mettre √† jour les boutons mobiles
            updateMobileModeButtons();
            
            clearProgram();
            clearGrid();
            clearPaintedCells();
        }

        // Fonction pour g√©rer le pliage/d√©pliage des cat√©gories
        function toggleCategory(header) {
            const categoryBlocks = header.nextElementSibling;
            const isExpanded = header.classList.contains('expanded');
            
            if (isExpanded) {
                header.classList.remove('expanded');
                header.classList.add('collapsed');
                categoryBlocks.classList.add('hidden');
            } else {
                header.classList.remove('collapsed');
                header.classList.add('expanded');
                categoryBlocks.classList.remove('hidden');
            }
        }

        // Drag & Drop
        function allowDrop(ev) {
            ev.preventDefault();
            ev.currentTarget.classList.add('drag-over');
        }

        function dragLeave(ev) {
            if (ev.target.classList.contains('program-area')) {
                ev.target.classList.remove('drag-over');
            }
        }

        function drag(ev) {
            const blockData = {
                type: ev.target.dataset.type,
                value: ev.target.dataset.value,
                op: ev.target.dataset.op,
                html: ev.target.outerHTML
            };
            
            // Capturer les valeurs des select pour les conserver
            const selects = ev.target.querySelectorAll('select');
            const selectValues = [];
            selects.forEach(select => {
                selectValues.push(select.value);
            });
            blockData.selectValues = selectValues;
            
            ev.dataTransfer.setData('text', JSON.stringify(blockData));
        }

        function drop(ev) {
            ev.preventDefault();
            ev.currentTarget.classList.remove('drag-over');
            
            const dataText = ev.dataTransfer.getData('text');
            if (!dataText) return;
            
            let data;
            try {
                data = JSON.parse(dataText);
            } catch (e) {
                console.error('Erreur de parsing JSON:', e);
                return;
            }
            
            // Emp√™cher le d√©p√¥t des blocs op√©rateurs et var-value dans la zone principale
            if (data.type === 'operator' || data.type === 'var-value') {
                console.log('Ces blocs ne peuvent √™tre d√©pos√©s que dans les emplacements de valeurs');
                return;
            }
            
            // V√©rifier si on d√©place un bloc existant ou si on en ajoute un nouveau depuis la palette
            const dragging = document.querySelector('.dragging');
            if (dragging) {
                // C'est un bloc existant qui est d√©plac√©, ne rien faire ici
                // Le gestionnaire ondrop du bloc cible s'en occupe
                return;
            }
            
            // C'est un nouveau bloc depuis la palette
            const programArea = document.getElementById('program-blocks');
            const targetBlock = ev.target.closest('.program-block');
            
            // Cr√©er le nouveau bloc
            addBlockToProgram(data);
            const newBlock = programArea.lastElementChild;
            
            // Si on a un bloc cible, ins√©rer √† la bonne position
            if (targetBlock && programArea.contains(targetBlock)) {
                const rect = targetBlock.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                
                if (ev.clientY < midpoint) {
                    programArea.insertBefore(newBlock, targetBlock);
                } else {
                    programArea.insertBefore(newBlock, targetBlock.nextSibling);
                }
            }
            // Sinon le bloc reste √† la fin (comportement par d√©faut d'appendChild)
        }
        
        function dropCondition(ev) {
            // Cette fonction n'est plus utilis√©e car le bloc if int√®gre maintenant directement la condition
            ev.preventDefault();
            ev.stopPropagation();
        }

        function setupNestedAreaDrop(nestedArea) {
            // Fonction pour g√©rer le drop et trouver o√π ins√©rer
            const handleDrop = function(e) {
                e.stopPropagation();
                e.preventDefault();
                
                // Trouver la vraie nested-area parente
                const actualNestedArea = e.currentTarget.closest ? e.currentTarget.closest('.nested-blocks') : nestedArea;
                if (!actualNestedArea) return;
                
                const dragging = document.querySelector('.dragging');
                if (dragging) {
                    // D√©placer un bloc existant
                    const targetBlock = e.target.closest('.program-block');
                    if (targetBlock && targetBlock !== dragging && actualNestedArea.contains(targetBlock)) {
                        // Ins√©rer avant ou apr√®s le bloc cible selon la position Y
                        const rect = targetBlock.getBoundingClientRect();
                        const midpoint = rect.top + rect.height / 2;
                        if (e.clientY < midpoint) {
                            actualNestedArea.insertBefore(dragging, targetBlock);
                        } else {
                            actualNestedArea.insertBefore(dragging, targetBlock.nextSibling);
                        }
                    } else {
                        // Ajouter √† la fin
                        actualNestedArea.appendChild(dragging);
                    }
                } else {
                    // Ajouter un nouveau bloc depuis la palette
                    const dataText = e.dataTransfer.getData('text');
                    if (!dataText) return;
                    
                    let nestedData;
                    try {
                        nestedData = JSON.parse(dataText);
                    } catch (err) {
                        console.error('Erreur de parsing JSON:', err);
                        return;
                    }
                    
                    // Emp√™cher le d√©p√¥t des blocs op√©rateurs et var-value dans les zones imbriqu√©es
                    if (nestedData.type === 'operator' || nestedData.type === 'var-value') {
                        console.log('Ces blocs ne peuvent √™tre d√©pos√©s que dans les emplacements de valeurs');
                        return;
                    }
                    
                    // Trouver le bloc cible pour insertion
                    const targetBlock = e.target.closest('.program-block');
                    if (targetBlock && actualNestedArea.contains(targetBlock)) {
                        const rect = targetBlock.getBoundingClientRect();
                        const midpoint = rect.top + rect.height / 2;
                        
                        // Cr√©er le nouveau bloc d'abord
                        addNestedBlock(nestedData, actualNestedArea);
                        const newBlock = actualNestedArea.lastElementChild;
                        
                        // Puis le d√©placer √† la bonne position
                        if (e.clientY < midpoint) {
                            actualNestedArea.insertBefore(newBlock, targetBlock);
                        } else {
                            actualNestedArea.insertBefore(newBlock, targetBlock.nextSibling);
                        }
                    } else {
                        // Ajouter √† la fin
                        addNestedBlock(nestedData, actualNestedArea);
                    }
                }
                actualNestedArea.classList.remove('empty');
                actualNestedArea.classList.remove('drag-over');
            };
            
            const handleDragOver = function(e) { 
                e.preventDefault(); 
                e.stopPropagation();
                const actualNestedArea = e.currentTarget.closest ? e.currentTarget.closest('.nested-blocks') : nestedArea;
                if (actualNestedArea) {
                    actualNestedArea.classList.add('drag-over');
                }
            };
            
            const handleDragLeave = function(e) {
                if (e.target === nestedArea) {
                    nestedArea.classList.remove('drag-over');
                }
            };
            
            // Ajouter les √©v√©nements sur la zone elle-m√™me
            nestedArea.ondrop = handleDrop;
            nestedArea.ondragover = handleDragOver;
            nestedArea.ondragleave = handleDragLeave;
            
            // Observer les nouveaux blocs ajout√©s pour leur ajouter aussi les gestionnaires
            const observer = new MutationObserver(mutations => {
                mutations.forEach(mutation => {
                    mutation.addedNodes.forEach(node => {
                        if (node.nodeType === 1 && node.classList.contains('program-block')) {
                            // Ajouter les gestionnaires sur le nouveau bloc
                            node.ondragover = handleDragOver;
                            node.ondrop = handleDrop;
                        }
                    });
                });
            });
            
            observer.observe(nestedArea, { childList: true });
        }

        // Fonction pour valider et g√©rer les inputs num√©riques dans les blocs
        function setupNumericInputValidation(blockElement) {
            // Attraper TOUS les inputs : dans le bloc ET dans les value-slots
            const inputs = blockElement.querySelectorAll('input[type="text"], input[type="number"]');
            
            inputs.forEach(input => {
                // V√©rifier si d√©j√† initialis√© pour √©viter les doublons
                if (input.dataset.validationInitialized === 'true') {
                    return; // D√©j√† fait, passer au suivant
                }
                
                // Marquer comme initialis√©
                input.dataset.validationInitialized = 'true';
                
                // Ignorer les inputs qui ont un placeholder mais pas de value (s√©lection de variable)
                const placeholder = input.placeholder;
                if (placeholder && (placeholder === 'a' || placeholder === 'b' || placeholder === 'valeur')) {
                    // C'est un input pour value-slot qui peut recevoir variable/op√©rateur
                    // On doit quand m√™me le valider s'il contient un nombre
                }
                
                // Sauvegarder la valeur initiale
                let previousValue = input.value || '10';
                
                // Enlever pattern et inputmode restrictifs pour permettre les n√©gatifs
                input.removeAttribute('pattern');
                
                // Au focus : s√©lectionner tout le texte
                input.addEventListener('focus', function() {
                    this.select();
                    previousValue = this.value;
                });
                
                // √Ä chaque saisie : valider en temps r√©el
                input.addEventListener('input', function() {
                    validateNumericInput(this);
                });
                
                // Au blur : restaurer si invalide
                input.addEventListener('blur', function() {
                    const value = this.value.trim();
                    
                    // Si vide, restaurer la valeur pr√©c√©dente
                    if (value === '') {
                        this.value = previousValue;
                        this.style.background = '';
                        this.style.border = '';
                        checkAllInputsValidity();
                        return;
                    }
                    
                    // D√©terminer les limites selon le type de bloc
                    const block = this.closest('.block');
                    let minValue = 1;
                    let maxValue = 100;
                    
                    if (block && (block.classList.contains('variables') || 
                                 block.classList.contains('operators') || 
                                 block.classList.contains('sensing'))) {
                        minValue = -10000;
                        maxValue = 10000;
                    }
                    
                    // Si invalide, restaurer la valeur pr√©c√©dente
                    if (!isValidNumber(value, minValue, maxValue)) {
                        this.value = previousValue;
                        this.style.background = '';
                        this.style.border = '';
                        checkAllInputsValidity();
                    } else {
                        // Valide, sauvegarder comme nouvelle valeur pr√©c√©dente
                        previousValue = this.value;
                        this.style.background = '';
                        this.style.border = '';
                        checkAllInputsValidity();
                    }
                });
            });
        }
        
        // Valider un input num√©rique
        function validateNumericInput(input) {
            const value = input.value.trim();
            
            // Vide = en attente, jaune l√©ger
            if (value === '') {
                input.style.background = '#FFF9C4'; // Jaune l√©ger
                input.style.border = '2px solid #FBC02D';
                checkAllInputsValidity();
                return;
            }
            
            // D√©terminer les limites selon le type de bloc
            const block = input.closest('.block');
            let minValue = 1;
            let maxValue = 100;
            
            // Blocs variables, op√©rateurs, condition : limites √©tendues
            if (block && (block.classList.contains('variables') || 
                         block.classList.contains('operators') || 
                         block.classList.contains('sensing'))) {
                minValue = -10000;
                maxValue = 10000;
            }
            
            // Valider
            if (!isValidNumber(value, minValue, maxValue)) {
                // Invalide = rouge
                input.style.background = '#FFCDD2';
                input.style.border = '2px solid #F44336';
            } else {
                // Valide = style normal (blanc)
                input.style.background = '';
                input.style.border = '';
            }
            
            checkAllInputsValidity();
        }
        
        // V√©rifier si une valeur est un nombre valide
        function isValidNumber(value, minValue = 1, maxValue = 100) {
            // Autoriser les nombres n√©gatifs si minValue est n√©gatif
            const pattern = minValue < 0 ? /^-?\d+$/ : /^\d+$/;
            
            // Doit √™tre un nombre (avec - optionnel si n√©gatif autoris√©)
            if (!pattern.test(value)) {
                return false;
            }
            
            const num = parseInt(value, 10);
            
            // Doit √™tre dans les limites
            if (isNaN(num) || num < minValue || num > maxValue) {
                return false;
            }
            
            return true;
        }
        
        // V√©rifier tous les inputs du programme
        function checkAllInputsValidity() {
            const programBlocks = document.getElementById('program-blocks');
            // TOUS les inputs text et number
            const allInputs = programBlocks.querySelectorAll('input[type="text"], input[type="number"]');
            
            let hasInvalidInput = false;
            
            allInputs.forEach(input => {
                const value = input.value.trim();
                
                // Si vide, ignorer (sera g√©r√© au blur)
                if (value === '') {
                    hasInvalidInput = true;
                    return;
                }
                
                // Ignorer si ce n'est pas un nombre (peut-√™tre une variable ou op√©rateur ins√©r√©)
                if (!/^-?\d+$/.test(value)) {
                    return;
                }
                
                // D√©terminer les limites selon le type de bloc
                const block = input.closest('.block');
                let minValue = 1;
                let maxValue = 100;
                
                // Blocs variables, op√©rateurs, condition : limites √©tendues
                if (block && (block.classList.contains('variables') || 
                             block.classList.contains('operators') || 
                             block.classList.contains('sensing'))) {
                    minValue = -10000;
                    maxValue = 10000;
                }
                
                // V√©rifier la validit√©
                if (!isValidNumber(value, minValue, maxValue)) {
                    hasInvalidInput = true;
                }
            });
            
            // Griser/activer TOUS les boutons "Tester"
            const runButtons = document.querySelectorAll('button[onclick="executeProgram()"]');
            runButtons.forEach(runButton => {
                if (hasInvalidInput) {
                    runButton.disabled = true;
                    runButton.style.opacity = '0.5';
                    runButton.style.cursor = 'not-allowed';
                    runButton.title = 'Corrigez les valeurs invalides avant de tester';
                } else {
                    runButton.disabled = false;
                    runButton.style.opacity = '1';
                    runButton.style.cursor = 'pointer';
                    runButton.title = '';
                }
            });
        }
        
        function addBlockToProgram(blockData) {
            const programArea = document.getElementById('program-blocks');
            const blockElement = document.createElement('div');
            blockElement.className = 'program-block';
            
            // Si c'est un bloc "r√©p√©ter" ou "si", cr√©er une capsule
            if (blockData.type === 'repeat' || blockData.type === 'if') {
                blockElement.classList.add('block-capsule');
                blockElement.innerHTML = blockData.html;
                
                const block = blockElement.querySelector('.block');
                block.removeAttribute('draggable');
                block.removeAttribute('ondragstart');
                
                // Restaurer les valeurs des select
                if (blockData.selectValues && blockData.selectValues.length > 0) {
                    const selects = block.querySelectorAll('select');
                    selects.forEach((select, index) => {
                        if (blockData.selectValues[index]) {
                            select.value = blockData.selectValues[index];
                        }
                    });
                }
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '√ó';
                removeBtn.onclick = function() {
                    blockElement.remove();
                    updateBlockCount();
                };
                block.appendChild(removeBtn);
                
                // Ajouter zone pour les blocs imbriqu√©s
                const nestedArea = document.createElement('div');
                nestedArea.className = 'nested-blocks empty';
                setupNestedAreaDrop(nestedArea);
                blockElement.appendChild(nestedArea);
                
                // Ajouter le bas de la capsule
                const capsuleBottom = document.createElement('div');
                capsuleBottom.className = 'block-capsule-bottom';
                capsuleBottom.style.background = getComputedStyle(block).background;
                blockElement.appendChild(capsuleBottom);
            } else {
                blockElement.innerHTML = blockData.html;
                
                const block = blockElement.querySelector('.block');
                block.removeAttribute('draggable');
                block.removeAttribute('ondragstart');
                
                // Restaurer les valeurs des select
                if (blockData.selectValues && blockData.selectValues.length > 0) {
                    const selects = block.querySelectorAll('select');
                    selects.forEach((select, index) => {
                        if (blockData.selectValues[index]) {
                            select.value = blockData.selectValues[index];
                        }
                    });
                }
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '√ó';
                removeBtn.onclick = function() {
                    blockElement.remove();
                    updateBlockCount();
                };
                block.appendChild(removeBtn);
            }
            
            // IMPORTANT: Initialiser la validation des inputs num√©riques
            setupNumericInputValidation(blockElement);
            
            // Rendre le bloc d√©pla√ßable dans la zone de programmation
            blockElement.draggable = true;
            blockElement.ondragstart = function(e) {
                e.stopPropagation();
                blockElement.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/html', blockElement.innerHTML);
                e.dataTransfer.setData('blockIndex', Array.from(programArea.children).indexOf(blockElement));
            };
            
            blockElement.ondragend = function() {
                blockElement.classList.remove('dragging');
                document.querySelectorAll('.drag-over-top, .drag-over-bottom, .drag-over').forEach(el => {
                    el.classList.remove('drag-over-top', 'drag-over-bottom', 'drag-over');
                });
            };
            
            blockElement.ondragover = function(e) {
                e.preventDefault();
                e.stopPropagation();
                const dragging = document.querySelector('.dragging');
                
                // Afficher l'indicateur pour les blocs existants OU pour les nouveaux blocs depuis la palette
                if ((!dragging || dragging !== blockElement)) {
                    const rect = blockElement.getBoundingClientRect();
                    const midpoint = rect.top + rect.height / 2;
                    
                    document.querySelectorAll('.drag-over-top, .drag-over-bottom').forEach(el => {
                        el.classList.remove('drag-over-top', 'drag-over-bottom');
                    });
                    
                    if (e.clientY < midpoint) {
                        blockElement.classList.add('drag-over-top');
                    } else {
                        blockElement.classList.add('drag-over-bottom');
                    }
                }
            };
            
            blockElement.ondrop = function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const dragging = document.querySelector('.dragging');
                
                if (dragging && dragging !== blockElement) {
                    // C'est un bloc existant qu'on d√©place
                    const rect = blockElement.getBoundingClientRect();
                    const midpoint = rect.top + rect.height / 2;
                    
                    if (e.clientY < midpoint) {
                        programArea.insertBefore(dragging, blockElement);
                    } else {
                        programArea.insertBefore(dragging, blockElement.nextSibling);
                    }
                } else if (!dragging) {
                    // C'est un nouveau bloc depuis la palette
                    const dataText = e.dataTransfer.getData('text');
                    if (!dataText) return;
                    
                    let data;
                    try {
                        data = JSON.parse(dataText);
                    } catch (err) {
                        console.error('Erreur de parsing JSON:', err);
                        return;
                    }
                    
                    // Emp√™cher le d√©p√¥t des blocs op√©rateurs et var-value
                    if (data.type === 'operator' || data.type === 'var-value') {
                        console.log('Ces blocs ne peuvent √™tre d√©pos√©s que dans les emplacements de valeurs');
                        return;
                    }
                    
                    // Cr√©er le nouveau bloc
                    addBlockToProgram(data);
                    const newBlock = programArea.lastElementChild;
                    
                    // Ins√©rer √† la bonne position
                    const rect = blockElement.getBoundingClientRect();
                    const midpoint = rect.top + rect.height / 2;
                    
                    if (e.clientY < midpoint) {
                        programArea.insertBefore(newBlock, blockElement);
                    } else {
                        programArea.insertBefore(newBlock, blockElement.nextSibling);
                    }
                }
                
                document.querySelectorAll('.drag-over-top, .drag-over-bottom').forEach(el => {
                    el.classList.remove('drag-over-top', 'drag-over-bottom');
                });
            };
            
            programArea.appendChild(blockElement);
            updateBlockCount();
        }

        function addNestedBlock(blockData, parentArea) {
            const blockElement = document.createElement('div');
            blockElement.className = 'program-block';
            
            // Si c'est un bloc "r√©p√©ter" ou "si", cr√©er une capsule m√™me pour les blocs imbriqu√©s
            if (blockData.type === 'repeat' || blockData.type === 'if') {
                blockElement.classList.add('block-capsule');
                blockElement.innerHTML = blockData.html;
                
                const block = blockElement.querySelector('.block');
                block.removeAttribute('draggable');
                block.removeAttribute('ondragstart');
                
                // Restaurer les valeurs des select
                if (blockData.selectValues && blockData.selectValues.length > 0) {
                    const selects = block.querySelectorAll('select');
                    selects.forEach((select, index) => {
                        if (blockData.selectValues[index]) {
                            select.value = blockData.selectValues[index];
                        }
                    });
                }
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '√ó';
                removeBtn.onclick = function() {
                    blockElement.remove();
                    updateBlockCount();
                    if (parentArea.children.length === 0) {
                        parentArea.classList.add('empty');
                    }
                };
                block.appendChild(removeBtn);
                
                // Ajouter zone pour les blocs doublement imbriqu√©s
                const nestedArea = document.createElement('div');
                nestedArea.className = 'nested-blocks empty';
                setupNestedAreaDrop(nestedArea);
                blockElement.appendChild(nestedArea);
                
                // Ajouter le bas de la capsule
                const capsuleBottom = document.createElement('div');
                capsuleBottom.className = 'block-capsule-bottom';
                capsuleBottom.style.background = getComputedStyle(block).background;
                blockElement.appendChild(capsuleBottom);
            } else {
                blockElement.innerHTML = blockData.html;
                
                const block = blockElement.querySelector('.block');
                block.removeAttribute('draggable');
                block.removeAttribute('ondragstart');
                
                // Restaurer les valeurs des select
                if (blockData.selectValues && blockData.selectValues.length > 0) {
                    const selects = block.querySelectorAll('select');
                    selects.forEach((select, index) => {
                        if (blockData.selectValues[index]) {
                            select.value = blockData.selectValues[index];
                        }
                    });
                }
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '√ó';
                removeBtn.onclick = function() {
                    blockElement.remove();
                    updateBlockCount();
                    if (parentArea.children.length === 0) {
                        parentArea.classList.add('empty');
                    }
                };
                block.appendChild(removeBtn);
            }
            
            // IMPORTANT: Initialiser la validation des inputs num√©riques
            setupNumericInputValidation(blockElement);
            
            // Rendre le bloc d√©pla√ßable m√™me s'il est imbriqu√©
            blockElement.draggable = true;
            blockElement.ondragstart = function(e) {
                e.stopPropagation();
                blockElement.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            };
            
            blockElement.ondragend = function() {
                blockElement.classList.remove('dragging');
                document.querySelectorAll('.drag-over-top, .drag-over-bottom').forEach(el => {
                    el.classList.remove('drag-over-top', 'drag-over-bottom');
                });
            };
            
            blockElement.ondragover = function(e) {
                e.preventDefault();
                e.stopPropagation();
                const dragging = document.querySelector('.dragging');
                if (dragging && dragging !== blockElement) {
                    const rect = blockElement.getBoundingClientRect();
                    const midpoint = rect.top + rect.height / 2;
                    
                    document.querySelectorAll('.drag-over-top, .drag-over-bottom').forEach(el => {
                        el.classList.remove('drag-over-top', 'drag-over-bottom');
                    });
                    
                    if (e.clientY < midpoint) {
                        blockElement.classList.add('drag-over-top');
                    } else {
                        blockElement.classList.add('drag-over-bottom');
                    }
                }
            };
            
            blockElement.ondrop = function(e) {
                e.preventDefault();
                e.stopPropagation();
                const dragging = document.querySelector('.dragging');
                if (dragging && dragging !== blockElement) {
                    const rect = blockElement.getBoundingClientRect();
                    const midpoint = rect.top + rect.height / 2;
                    
                    if (e.clientY < midpoint) {
                        parentArea.insertBefore(dragging, blockElement);
                    } else {
                        parentArea.insertBefore(dragging, blockElement.nextSibling);
                    }
                }
                document.querySelectorAll('.drag-over-top, .drag-over-bottom').forEach(el => {
                    el.classList.remove('drag-over-top', 'drag-over-bottom');
                });
            };
            
            parentArea.appendChild(blockElement);
            updateBlockCount();
        }

        // Ex√©cution du programme
        function executeProgram() {
            clearGrid();
            resetTurtle();
            variables = {};
            updateVariableDisplay();
            
            // R√©cup√©rer la grille active
            getActiveGrid();
            
            const blocks = document.getElementById('program-blocks').querySelectorAll(':scope > .program-block');
            
            try {
                executeBlocks(blocks);
            } catch (error) {
                showResult('Erreur dans le programme: ' + error.message, false);
            }
        }

        // Fonction utilitaire pour √©valuer une valeur depuis un value-slot
        function evaluateValueSlot(valueSlot) {
            if (!valueSlot) return 0;
            
            // V√©rifier si un bloc op√©rateur a √©t√© d√©pos√©
            const operatorBlock = valueSlot.querySelector('.block[data-type="operator"]');
            if (operatorBlock) {
                const opValueSlots = operatorBlock.querySelectorAll('.value-slot');
                const opSelect = operatorBlock.querySelector(':scope > select');
                const operation = opSelect ? opSelect.value : '+';
                
                // R√©cup√©rer la premi√®re valeur (r√©cursif pour g√©rer les op√©rateurs imbriqu√©s)
                let val1 = 0;
                if (opValueSlots[0]) {
                    val1 = evaluateValueSlot(opValueSlots[0]);
                }
                
                // R√©cup√©rer la deuxi√®me valeur (r√©cursif pour g√©rer les op√©rateurs imbriqu√©s)
                let val2 = 0;
                if (opValueSlots[1]) {
                    val2 = evaluateValueSlot(opValueSlots[1]);
                }
                
                // Calculer le r√©sultat
                switch (operation) {
                    case '+': return val1 + val2;
                    case '-': return val1 - val2;
                    case '*': return val1 * val2;
                    case '/': return val2 !== 0 ? val1 / val2 : 0;
                    default: return 0;
                }
            }
            
            // V√©rifier si un bloc variable a √©t√© d√©pos√©
            const varBlock = valueSlot.querySelector('.block[data-type="var-value"]');
            if (varBlock) {
                const varName = varBlock.querySelector('select').value;
                return variables[varName] || 0;
            }
            
            // Sinon, r√©cup√©rer la valeur de l'input
            const input = valueSlot.querySelector('input');
            if (input) {
                const inputVal = input.value;
                return !isNaN(inputVal) && inputVal !== '' ? parseFloat(inputVal) : 0;
            }
            
            return 0;
        }

        function executeBlocks(blocks) {
            for (let block of blocks) {
                const blockElement = block.querySelector('.block');
                const type = blockElement.dataset.type;
                
                switch(type) {
                    case 'color':
                        turtle.color = blockElement.dataset.value;
                        // Colorier UNIQUEMENT la case actuelle, sans activer drawMode
                        paintCell(turtle.x, turtle.y, turtle.color);
                        break;
                    case 'forward':
                        moveForward();
                        break;
                    case 'back':
                        moveBackward();
                        break;
                    case 'right':
                        turnRight();
                        break;
                    case 'left':
                        turnLeft();
                        break;
                    case 'repeat':
                        const valueSlotRepeat = blockElement.querySelector('.value-slot');
                        let times = Math.round(evaluateValueSlot(valueSlotRepeat)) || 1;
                        
                        // S'assurer que times est au moins 1
                        if (times < 1) times = 1;
                        
                        const nestedArea = block.querySelector('.nested-blocks');
                        if (nestedArea) {
                            // CORRECTION: S√©lectionner uniquement les enfants directs, pas tous les descendants
                            const nestedBlocks = Array.from(nestedArea.children).filter(child => child.classList.contains('program-block'));
                            for (let i = 0; i < times; i++) {
                                executeBlocks(nestedBlocks);
                            }
                        }
                        break;
                    case 'variable':
                        const varSelect = blockElement.querySelector('select');
                        const varName = varSelect ? varSelect.value : '';
                        
                        // R√©cup√©rer la valeur depuis le value-slot (peut √™tre un nombre, une variable ou un op√©rateur)
                        const valueSlotVar = blockElement.querySelector('.value-slot');
                        const varValue = evaluateValueSlot(valueSlotVar);
                        
                        if (varName) {
                            // S'assurer que la variable est dans la liste des variables cr√©√©es
                            if (!createdVariables.includes(varName)) {
                                createdVariables.push(varName);
                            }
                            variables[varName] = varValue;
                            updateVariableDisplay();
                        }
                        break;
                    case 'change-var':
                        const changeSelect = blockElement.querySelector('select');
                        const changeVarName = changeSelect ? changeSelect.value : '';
                        
                        // R√©cup√©rer la valeur depuis le value-slot (peut √™tre un nombre, une variable ou un op√©rateur)
                        const valueSlotChange = blockElement.querySelector('.value-slot');
                        const changeValue = evaluateValueSlot(valueSlotChange);
                        
                        if (changeVarName && variables.hasOwnProperty(changeVarName)) {
                            variables[changeVarName] += changeValue;
                            updateVariableDisplay();
                        }
                        break;
                    case 'if':
                        const ifVarSelect = blockElement.querySelector('.var-select');
                        const compareOp = blockElement.querySelector('.compare-op');
                        const valueSlot = blockElement.querySelector('.value-slot');
                        
                        if (ifVarSelect && compareOp && valueSlot) {
                            const ifVarName = ifVarSelect.value;
                            const operator = compareOp.value;
                            
                            // R√©cup√©rer la valeur (soit depuis un input, soit depuis un bloc variable ou op√©rateur d√©pos√©)
                            let compareValue;
                            const varBlock = valueSlot.querySelector('.block[data-type="var-value"]');
                            const operatorBlock = valueSlot.querySelector('.block[data-type="operator"]');
                            const valueInput = valueSlot.querySelector('input[type="text"]');
                            
                            if (operatorBlock) {
                                // √âvaluer le bloc op√©rateur
                                const opValueSlots = operatorBlock.querySelectorAll('.value-slot');
                                const opSelect = operatorBlock.querySelector(':scope > select');
                                const operation = opSelect ? opSelect.value : '+';
                                
                                // R√©cup√©rer la premi√®re valeur
                                let val1 = 0;
                                if (opValueSlots[0]) {
                                    const v1Block = opValueSlots[0].querySelector('.block[data-type="var-value"]');
                                    if (v1Block) {
                                        const v1Name = v1Block.querySelector('select').value;
                                        val1 = variables[v1Name] || 0;
                                    } else {
                                        const v1Input = opValueSlots[0].querySelector('input');
                                        if (v1Input) {
                                            const inputVal = v1Input.value;
                                            val1 = !isNaN(inputVal) && inputVal !== '' ? parseFloat(inputVal) : 0;
                                        }
                                    }
                                }
                                
                                // R√©cup√©rer la deuxi√®me valeur
                                let val2 = 0;
                                if (opValueSlots[1]) {
                                    const v2Block = opValueSlots[1].querySelector('.block[data-type="var-value"]');
                                    if (v2Block) {
                                        const v2Name = v2Block.querySelector('select').value;
                                        val2 = variables[v2Name] || 0;
                                    } else {
                                        const v2Input = opValueSlots[1].querySelector('input');
                                        if (v2Input) {
                                            const inputVal = v2Input.value;
                                            val2 = !isNaN(inputVal) && inputVal !== '' ? parseFloat(inputVal) : 0;
                                        }
                                    }
                                }
                                
                                // Calculer le r√©sultat
                                switch (operation) {
                                    case '+': compareValue = val1 + val2; break;
                                    case '-': compareValue = val1 - val2; break;
                                    case '*': compareValue = val1 * val2; break;
                                    case '/': compareValue = val2 !== 0 ? val1 / val2 : 0; break;
                                    default: compareValue = 0;
                                }
                            } else if (varBlock) {
                                const refVarName = varBlock.querySelector('select').value;
                                compareValue = variables[refVarName];
                            } else if (valueInput) {
                                compareValue = valueInput.value;
                                // Essayer de convertir en nombre si possible
                                if (!isNaN(compareValue) && compareValue !== '') {
                                    compareValue = parseFloat(compareValue);
                                }
                            }
                            
                            // √âvaluer la condition
                            const varValue = variables[ifVarName];
                            let conditionResult = false;
                            
                            if (varValue !== undefined && compareValue !== undefined) {
                                switch (operator) {
                                    case '<':
                                        conditionResult = varValue < compareValue;
                                        break;
                                    case '>':
                                        conditionResult = varValue > compareValue;
                                        break;
                                    case '=':
                                        conditionResult = varValue == compareValue;
                                        break;
                                    case '<=':
                                        conditionResult = varValue <= compareValue;
                                        break;
                                    case '>=':
                                        conditionResult = varValue >= compareValue;
                                        break;
                                    case '‚â†':
                                    case '!=':
                                        conditionResult = varValue != compareValue;
                                        break;
                                }
                            }
                            
                            // Si la condition est vraie, ex√©cuter les blocs imbriqu√©s
                            if (conditionResult) {
                                const ifNestedArea = block.querySelector('.nested-blocks');
                                if (ifNestedArea) {
                                    const ifNestedBlocks = ifNestedArea.querySelectorAll(':scope > .program-block');
                                    executeBlocks(ifNestedBlocks);
                                }
                            }
                        }
                        break;
                    case 'operator':
                        // Les op√©rateurs sont plut√¥t utilis√©s dans les conditions
                        break;
                }
            }
        }

        function resetTurtle() {
            turtle = { x: 5, y: 9, direction: 0, color: 'black', drawMode: false };
            drawTurtle();
        }

        function moveForward() {
            const directions = [{x:0,y:-1}, {x:1,y:0}, {x:0,y:1}, {x:-1,y:0}];
            const dir = directions[turtle.direction];
            
            turtle.x += dir.x;
            turtle.y += dir.y;
            
            if (turtle.x < 0) turtle.x = 0;
            if (turtle.x >= GRID_SIZE) turtle.x = GRID_SIZE - 1;
            if (turtle.y < 0) turtle.y = 0;
            if (turtle.y >= GRID_SIZE) turtle.y = GRID_SIZE - 1;
            
            drawTurtle();
        }

        function moveBackward() {
            turnRight();
            turnRight();
            moveForward();
            turnRight();
            turnRight();
        }

        function turnRight() {
            turtle.direction = (turtle.direction + 1) % 4;
            drawTurtle();
        }

        function turnLeft() {
            turtle.direction = (turtle.direction + 3) % 4;
            drawTurtle();
        }

        function paintCell(x, y, color) {
            if (y >= 0 && y < GRID_SIZE && x >= 0 && x < GRID_SIZE) {
                grid[y][x].color = color;
                
                // Modifier le DOM si l'√©l√©ment existe (m√™me en mode aper√ßu pour afficher le motif)
                if (grid[y][x].element) {
                    const colorMap = {
                        'red': '#dc3545',
                        'yellow': '#ffc107',
                        'green': '#28a745',
                        'blue': '#007bff',
                        'black': '#343a40',
                        'white': '#ffffff'
                    };
                    grid[y][x].element.style.background = colorMap[color] || color;
                }
            }
        }

        function drawTurtle() {
            // Ne pas dessiner en mode aper√ßu
            if (window.isPreviewMode) {
                return;
            }
            
            // Dessiner une fl√®che pour indiquer la position et direction de la tortue
            const arrows = ['‚ñ≤', '‚ñ∂', '‚ñº', '‚óÄ'];
            if (turtle.y >= 0 && turtle.y < GRID_SIZE && turtle.x >= 0 && turtle.x < GRID_SIZE) {
                if (grid[turtle.y] && grid[turtle.y][turtle.x] && grid[turtle.y][turtle.x].element) {
                    grid[turtle.y][turtle.x].element.innerHTML = arrows[turtle.direction];
                    grid[turtle.y][turtle.x].element.style.fontSize = '20px';
                    grid[turtle.y][turtle.x].element.style.display = 'flex';
                    grid[turtle.y][turtle.x].element.style.alignItems = 'center';
                    grid[turtle.y][turtle.x].element.style.justifyContent = 'center';
                }
            }
        }

        function clearGrid() {
            getActiveGrid(); // S'assurer qu'on a la bonne grille
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    grid[y][x].color = 'white';
                    grid[y][x].element.style.background = 'white';
                    grid[y][x].element.innerHTML = '';
                }
            }
            resetTurtle();
            
            // NE PAS nettoyer les cellules peintes automatiquement
            // Elles seront nettoy√©es uniquement avec le bouton "Effacer" ou lors du changement de mode
        }
        
        // Fonction pour effacer la grille ET les cellules peintes (pour le bouton Effacer)
        function clearGridAndPaint() {
            clearGrid();
            clearProgram(); // Effacer √©galement le programme
            if (currentMode === 'teacher') {
                clearPaintedCells();
            }
        }

        function clearProgram() {
            document.getElementById('program-blocks').innerHTML = '';
            programBlocks = []; // Vider le tableau interne
            const resultMsg = document.getElementById('result-message');
            if (resultMsg) resultMsg.innerHTML = '';
            const teacherResultMsg = document.getElementById('teacher-result-message');
            if (teacherResultMsg) teacherResultMsg.innerHTML = '';
            updateBlockCount();
        }
        
        // Mettre √† jour le compteur de blocs
        function updateBlockCount() {
            const programBlocks = document.getElementById('program-blocks');
            const blocks = programBlocks.querySelectorAll(':scope > .program-block');
            let totalCount = countTotalBlocks(blocks);
            
            const blockCountSpan = document.getElementById('block-count');
            if (blockCountSpan) {
                blockCountSpan.textContent = `(${totalCount} bloc${totalCount > 1 ? 's' : ''})`;
            }
        }

        // Gestion des niveaux
        function loadCursusLevels() {
            currentCursus = document.getElementById('cursus-select').value;
            const levelSelect = document.getElementById('level-select');
            levelSelect.innerHTML = '';
            
            const cursusInfo = cursusData[currentCursus];
            const levels = cursusInfo.levels || {};
            const levelKeys = Object.keys(levels).sort((a, b) => parseInt(a) - parseInt(b));
            const levelsPerWorld = cursusInfo.levelsPerWorld || 10;
            
            if (levelKeys.length === 0) {
                levelSelect.innerHTML = '<option value="0">Aucun niveau disponible</option>';
                // Nettoyer la grille si aucun niveau
                clearGrid();
                clearPaintedCells();
                return; // IMPORTANT : ne pas appeler loadLevel()
            }
            
            levelKeys.forEach((levelNum) => {
                const level = levels[levelNum];
                const levelIndex = parseInt(levelNum) - 1;
                const worldNum = Math.floor(levelIndex / levelsPerWorld) + 1;
                const levelInWorld = (levelIndex % levelsPerWorld) + 1;
                
                // V√©rifier si le monde est d√©bloqu√©
                const worldUnlocked = score >= (cursusInfo.pointsPerWorld[worldNum - 1] || 0);
                
                // V√©rifier le statut de compl√©tion du niveau
                const levelKey = `${currentCursus}-${levelNum}`;
                const completionStatus = completedLevels[levelKey];
                
                const option = document.createElement('option');
                option.value = levelNum;
                
                // Construire le texte avec les coches appropri√©es
                let statusIcon = '';
                if (completionStatus === 2) {
                    statusIcon = '‚úì‚úì '; // Double coche pour 2 points
                } else if (completionStatus === 1) {
                    statusIcon = '‚úì '; // Simple coche pour 1 point
                }
                
                option.textContent = `${statusIcon}Monde ${worldNum} - Niveau ${levelInWorld} - Blocs optimaux : ${level.blockCount}`;
                option.disabled = !worldUnlocked;
                if (!worldUnlocked) {
                    option.textContent += ` üîí (${cursusInfo.pointsPerWorld[worldNum - 1]} pts requis)`;
                }
                levelSelect.appendChild(option);
            });
            
            // Charger le premier niveau d√©bloqu√©
            const firstUnlocked = Array.from(levelSelect.options).find(opt => !opt.disabled);
            if (firstUnlocked) {
                levelSelect.value = firstUnlocked.value;
            }
            
            loadLevel();
        }

        function loadLevel() {
            const levelNum = document.getElementById('level-select').value;
            const level = cursusData[currentCursus].levels[levelNum];
            
            if (!level) {
                // Nettoyer la grille target si pas de niveau
                const targetGridElement = document.getElementById('target-grid');
                if (targetGridElement) {
                    const targetCells = targetGridElement.querySelectorAll('.grid-cell');
                    targetCells.forEach(cell => {
                        cell.style.background = 'white';
                        cell.innerHTML = '';
                    });
                }
                return;
            }
            
            currentLevelIndex = parseInt(levelNum) - 1;
            
            clearGrid();
            clearProgram();
            document.getElementById('result-message').innerHTML = '';
            
            // Afficher le motif attendu dans target-grid
            displayTargetPattern(level);
        }
        
        function displayTargetPattern(level) {
            // Utiliser la grille target pour afficher le motif
            const targetGridElement = document.getElementById('target-grid');
            if (!targetGridElement) return;
            
            // Vider la grille target
            const targetCells = targetGridElement.querySelectorAll('.grid-cell');
            targetCells.forEach(cell => {
                cell.style.background = 'white';
                cell.innerHTML = '';
            });
            
            // Activer le mode aper√ßu pour d√©sactiver drawTurtle
            window.isPreviewMode = true;
            
            // Simuler l'ex√©cution du programme du professeur dans la grille target
            const savedGrid = grid;
            const savedTurtle = { ...turtle };
            const savedVariables = { ...variables };
            const savedCreatedVariables = [...createdVariables];
            
            // Restaurer les variables du niveau
            if (level.variables) {
                createdVariables = [...(level.variables.createdVariables || [])];
                variables = { ...(level.variables.variableValues || {}) };
            } else {
                createdVariables = [];
                variables = {};
            }
            
            grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                grid[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = targetCells[y * GRID_SIZE + x];
                    grid[y][x] = { element: cell, color: 'white' };
                }
            }
            
            // Ex√©cuter le programme pour dessiner le motif attendu (sans afficher la fl√®che)
            resetTurtle();
            executeSavedBlocks(level.blocks);
            
            // NE PAS appeler drawTurtle() pour la grille target - c'est ici le bug
            // Nettoyer les fl√®ches √©ventuellement affich√©es
            targetCells.forEach(cell => {
                cell.innerHTML = '';
            });
            
            // Restaurer la grille et la tortue originales
            grid = savedGrid;
            turtle = savedTurtle;
            
            // MODE √âL√àVE : R√©initialiser les variables (ne pas garder celles du prof)
            variables = {};
            createdVariables = [];
            
            // Masquer l'affichage des variables (l'√©l√®ve n'a pas encore cr√©√© de variables)
            updateVariableDisplay();
            
            // D√©sactiver le mode aper√ßu
            window.isPreviewMode = false;
        }

        function validateLevel() {
            const levelNum = document.getElementById('level-select').value;
            const level = cursusData[currentCursus].levels[levelNum];
            if (!level) {
                alert('Aucun niveau √† valider');
                return;
            }
            
            // Ex√©cuter le programme de l'√©l√®ve
            clearGrid();
            resetTurtle();
            getActiveGrid();
            const blocks = document.getElementById('program-blocks').querySelectorAll(':scope > .program-block');
            executeBlocks(blocks);
            const studentGrid = getGridState();
            
            // Ex√©cuter le programme du professeur
            clearGrid();
            resetTurtle();
            getActiveGrid();
            const teacherBlocks = level.blocks;
            executeSavedBlocks(teacherBlocks);
            const teacherGrid = getGridState();
            
            // Comparer les grilles
            const isCorrect = compareGrids(studentGrid, teacherGrid);
            const blockCount = countTotalBlocks(blocks);
            const isOptimal = blockCount <= level.blockCount;
            
            if (isCorrect) {
                // V√©rifier si ce niveau a d√©j√† √©t√© compl√©t√©
                const levelKey = `${currentCursus}-${levelNum}`;
                const levelStatus = completedLevels[levelKey];
                
                let pointsEarned = 0;
                let wasAlreadyCompleted = false;
                let wasAlreadyOptimal = false;
                
                if (!levelStatus) {
                    // Premi√®re fois que le niveau est compl√©t√©
                    completedLevels[levelKey] = 1; // 1 point pour validation
                    
                    // +1 point pour avoir r√©solu le niveau
                    pointsEarned += 1;
                    score += 1;
                    
                    // +1 point bonus si optimal
                    if (isOptimal) {
                        completedLevels[levelKey] = 2; // 2 points pour optimal
                        pointsEarned += 1;
                        score += 1;
                    }
                } else {
                    // Le niveau a d√©j√† √©t√© compl√©t√©
                    wasAlreadyCompleted = true;
                    wasAlreadyOptimal = (levelStatus === 2);
                    
                    // Si le niveau √©tait d√©j√† compl√©t√© mais pas optimal, et maintenant il l'est
                    if (levelStatus === 1 && isOptimal) {
                        completedLevels[levelKey] = 2;
                        pointsEarned += 1;
                        score += 1;
                    }
                }
                
                // Afficher la popup de f√©licitations
                showSuccessPopup(isOptimal, blockCount, level.blockCount, pointsEarned, wasAlreadyCompleted, wasAlreadyOptimal);
                
                const scoreElement = document.getElementById('score');
                if (scoreElement) {
                    scoreElement.textContent = score;
                }
                saveScore();
                saveCompletedLevels();
                
                // Mettre √† jour uniquement les coches dans la liste sans recharger
                updateLevelChecks();
            } else {
                showResult('‚ùå Le motif ne correspond pas. R√©essaie !', false);
            }
        }
        
        function updateLevelChecks() {
            // Met √† jour les coches dans la liste sans changer la s√©lection
            const levelSelect = document.getElementById('level-select');
            const currentValue = levelSelect.value; // Sauvegarder la valeur actuelle
            const cursusInfo = cursusData[currentCursus];
            const levels = cursusInfo.levels || {};
            const levelsPerWorld = cursusInfo.levelsPerWorld || 10;
            
            // Parcourir toutes les options et mettre √† jour le texte
            Array.from(levelSelect.options).forEach((option) => {
                const levelNum = option.value;
                if (levelNum === '0') return; // Skip "Aucun niveau disponible"
                
                const level = levels[levelNum];
                if (!level) return;
                
                const levelIndex = parseInt(levelNum) - 1;
                const worldNum = Math.floor(levelIndex / levelsPerWorld) + 1;
                const levelInWorld = (levelIndex % levelsPerWorld) + 1;
                const worldUnlocked = score >= (cursusInfo.pointsPerWorld[worldNum - 1] || 0);
                
                // V√©rifier le statut de compl√©tion
                const levelKey = `${currentCursus}-${levelNum}`;
                const completionStatus = completedLevels[levelKey];
                
                // Construire le texte avec les coches appropri√©es
                let statusIcon = '';
                if (completionStatus === 2) {
                    statusIcon = '‚úì‚úì '; // Double coche pour 2 points
                } else if (completionStatus === 1) {
                    statusIcon = '‚úì '; // Simple coche pour 1 point
                }
                
                option.textContent = `${statusIcon}Monde ${worldNum} - Niveau ${levelInWorld} - Blocs optimaux : ${level.blockCount}`;
                option.disabled = !worldUnlocked;
                if (!worldUnlocked) {
                    option.textContent += ` üîí (${cursusInfo.pointsPerWorld[worldNum - 1]} pts requis)`;
                }
            });
            
            // Restaurer la s√©lection
            levelSelect.value = currentValue;
        }

        function showSuccessPopup(isOptimal, studentBlockCount, teacherBlockCount, pointsEarned, wasAlreadyCompleted, wasAlreadyOptimal) {
            const overlay = document.getElementById('success-overlay');
            const popup = document.getElementById('success-popup');
            const title = document.getElementById('success-title');
            const message = document.getElementById('success-message');
            const bonusMessage = document.getElementById('bonus-message');
            const btnNext = document.getElementById('btn-next-level');
            
            // Configurer le titre et le message selon la situation
            if (!wasAlreadyCompleted) {
                // Premi√®re fois que le niveau est r√©ussi
                if (isOptimal) {
                    title.textContent = 'üèÜ Bravo ! Parfait !';
                    message.textContent = `Tu as r√©ussi ce niveau avec le nombre optimal de blocs ! +${pointsEarned} points`;
                    bonusMessage.style.display = 'none';
                } else {
                    title.textContent = '‚úÖ Bravo !';
                    message.textContent = `Tu as r√©ussi ce niveau ! +${pointsEarned} point`;
                    bonusMessage.textContent = `üí° Gagne un point de plus en cr√©ant ce motif avec ${teacherBlockCount} blocs au maximum`;
                    bonusMessage.style.display = 'block';
                }
            } else {
                // Le niveau avait d√©j√† √©t√© compl√©t√©
                if (wasAlreadyOptimal) {
                    // D√©j√† r√©solu de mani√®re optimale
                    title.textContent = '‚úÖ Niveau d√©j√† r√©ussi !';
                    message.textContent = `Tu as d√©j√† obtenu tous les points pour ce niveau.`;
                    bonusMessage.style.display = 'none';
                } else if (isOptimal) {
                    // Maintenant r√©solu de mani√®re optimale
                    title.textContent = 'üèÜ Excellent !';
                    message.textContent = `Tu as optimis√© ta solution ! +${pointsEarned} point bonus`;
                    bonusMessage.style.display = 'none';
                } else {
                    // Toujours pas optimal
                    title.textContent = '‚úÖ Niveau d√©j√† r√©ussi !';
                    message.textContent = `Tu as d√©j√† obtenu +1 point pour ce niveau.`;
                    bonusMessage.textContent = `üí° Gagne un point de plus en cr√©ant ce motif avec ${teacherBlockCount} blocs au maximum`;
                    bonusMessage.style.display = 'block';
                }
            }
            
            // Configurer le bouton "Niveau suivant"
            // V√©rifier s'il existe un niveau suivant d√©bloqu√©
            const levelSelect = document.getElementById('level-select');
            const currentOption = levelSelect.options[levelSelect.selectedIndex];
            const nextOption = levelSelect.options[levelSelect.selectedIndex + 1];
            
            if (nextOption && !nextOption.disabled) {
                // Il y a un niveau suivant disponible
                btnNext.style.display = 'block';
                btnNext.innerHTML = '<span class="btn-icon">‚û°Ô∏è</span><span class="btn-text">Niveau suivant</span>';
            } else {
                // Pas de niveau suivant ou niveau verrouill√©
                btnNext.style.display = 'block';
                btnNext.innerHTML = '<span class="btn-icon">üèÜ</span><span class="btn-text">Cursus termin√© !</span>';
            }
            
            // Afficher la popup
            overlay.classList.add('show');
            popup.classList.add('show');
        }

        function closeSuccessPopup() {
            const overlay = document.getElementById('success-overlay');
            const popup = document.getElementById('success-popup');
            overlay.classList.remove('show');
            popup.classList.remove('show');
        }

        function restartLevel() {
            closeSuccessPopup();
            // Vider le programme
            document.getElementById('program-blocks').innerHTML = '';
            // R√©initialiser la grille
            clearGrid();
            resetTurtle();
        }

        function nextLevel() {
            closeSuccessPopup();
            
            const levelSelect = document.getElementById('level-select');
            const currentIndex = levelSelect.selectedIndex;
            const nextOption = levelSelect.options[currentIndex + 1];
            
            if (nextOption && !nextOption.disabled) {
                // Passer au niveau suivant
                levelSelect.selectedIndex = currentIndex + 1;
                loadLevel();
                
                // Vider le programme
                document.getElementById('program-blocks').innerHTML = '';
                // R√©initialiser la grille
                clearGrid();
                resetTurtle();
            } else {
                // Tous les niveaux termin√©s
                showResult('üèÜ F√©licitations ! Tu as termin√© tous les niveaux de ce cursus !', true);
            }
        }

        function getGridState() {
            const state = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                state[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    state[y][x] = grid[y][x].color;
                }
            }
            return state;
        }

        function compareGrids(grid1, grid2) {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid1[y][x] !== grid2[y][x]) {
                        return false;
                    }
                }
            }
            return true;
        }

        function executeSavedBlocks(blocks) {
            // Fonction pour ex√©cuter des blocs sauvegard√©s
            for (let block of blocks) {
                switch(block.type) {
                    case 'color':
                        turtle.color = block.value;
                        // Colorier UNIQUEMENT la case actuelle
                        paintCell(turtle.x, turtle.y, turtle.color);
                        break;
                    case 'forward':
                        moveForward();
                        break;
                    case 'back':
                        moveBackward();
                        break;
                    case 'right':
                        turnRight();
                        break;
                    case 'left':
                        turnLeft();
                        break;
                    case 'repeat':
                        let repeatTimes = 1;
                        
                        // Si une variable est utilis√©e
                        if (block.timesVar) {
                            repeatTimes = variables[block.timesVar] || 1;
                        } else {
                            repeatTimes = block.times || 1;
                        }
                        
                        for (let i = 0; i < repeatTimes; i++) {
                            if (block.nested && block.nested.length > 0) {
                                executeSavedBlocks(block.nested);
                            }
                        }
                        break;
                    case 'variable':
                        if (block.varName) {
                            let value = 0;
                            
                            // Si une variable est utilis√©e pour la valeur
                            if (block.varValueVar) {
                                value = variables[block.varValueVar] || 0;
                            } else {
                                value = parseInt(block.varValue) || 0;
                            }
                            
                            variables[block.varName] = value;
                            updateVariableDisplay();
                        }
                        break;
                    case 'change-var':
                        if (block.varName && variables.hasOwnProperty(block.varName)) {
                            let changeAmount = 0;
                            
                            // Si une variable est utilis√©e pour la valeur de changement
                            if (block.changeValueVar) {
                                changeAmount = variables[block.changeValueVar] || 0;
                            } else {
                                changeAmount = parseInt(block.changeValue) || 0;
                            }
                            
                            variables[block.varName] += changeAmount;
                            updateVariableDisplay();
                        }
                        break;
                    case 'if':
                        // √âvaluer la condition
                        if (block.varName && block.operator !== undefined) {
                            const varValue = variables[block.varName];
                            let compareValue = block.compareValue;
                            
                            // Essayer de convertir en nombre si possible
                            if (!isNaN(compareValue) && compareValue !== '') {
                                compareValue = parseFloat(compareValue);
                            }
                            
                            let conditionResult = false;
                            
                            if (varValue !== undefined && compareValue !== undefined) {
                                switch (block.operator) {
                                    case '<':
                                        conditionResult = varValue < compareValue;
                                        break;
                                    case '>':
                                        conditionResult = varValue > compareValue;
                                        break;
                                    case '=':
                                        conditionResult = varValue == compareValue;
                                        break;
                                    case '<=':
                                        conditionResult = varValue <= compareValue;
                                        break;
                                    case '>=':
                                        conditionResult = varValue >= compareValue;
                                        break;
                                }
                            }
                            
                            // Si la condition est vraie, ex√©cuter les blocs imbriqu√©s
                            if (conditionResult && block.nested && block.nested.length > 0) {
                                executeSavedBlocks(block.nested);
                            }
                        }
                        break;
                }
            }
        }

        // Mode professeur
        function loadTeacherLevels() {
            const cursus = document.getElementById('teacher-cursus-select').value;
            const levelSelect = document.getElementById('teacher-level-select');
            
            // IMPORTANT : D√©sactiver temporairement l'√©v√©nement onchange
            levelSelect.onchange = null;
            
            levelSelect.innerHTML = '<option value="new">+ Nouveau niveau</option>';
            
            const cursusInfo = cursusData[cursus];
            const levels = cursusInfo.levels || {};
            const levelKeys = Object.keys(levels).sort((a, b) => parseInt(a) - parseInt(b));
            const levelsPerWorld = cursusInfo.levelsPerWorld || 10;
            
            levelKeys.forEach((levelNum) => {
                const level = levels[levelNum];
                const levelIndex = parseInt(levelNum) - 1;
                const worldNum = Math.floor(levelIndex / levelsPerWorld) + 1;
                const levelInWorld = (levelIndex % levelsPerWorld) + 1;
                
                const option = document.createElement('option');
                option.value = levelNum;
                option.textContent = `Monde ${worldNum} - Niveau ${levelInWorld} - Blocs optimaux : ${level.blockCount}`;
                levelSelect.appendChild(option);
            });
            
            // Charger automatiquement le premier niveau s'il existe
            if (levelKeys.length > 0) {
                levelSelect.value = levelKeys[0];
                loadTeacherLevel();
            } else {
                // Aucun niveau : nettoyer l'interface et r√©initialiser
                clearProgram();
                clearGrid();
                clearPaintedCells();
                lastLoadedLevel = null;
            }
            
            // R√©activer l'√©v√©nement onchange
            levelSelect.onchange = saveCurrentAndLoadTeacherLevel;
        }
        
        function loadTeacherLevel() {
            const levelNum = document.getElementById('teacher-level-select').value;
            
            // M√©moriser le niveau qu'on charge
            lastLoadedLevel = levelNum;
            
            // G√©rer l'√©tat du bouton "√âcraser niveau"
            const overwriteBtn = document.getElementById('overwrite-level-btn');
            if (levelNum === 'new') {
                overwriteBtn.disabled = true;
                overwriteBtn.style.opacity = '0.5';
                overwriteBtn.style.cursor = 'not-allowed';
            } else {
                overwriteBtn.disabled = false;
                overwriteBtn.style.opacity = '1';
                overwriteBtn.style.cursor = 'pointer';
            }
            
            clearProgram();
            clearGrid();
            
            if (levelNum === 'new') {
                clearPaintedCells();
                return;
            }
            
            const cursus = document.getElementById('teacher-cursus-select').value;
            const level = cursusData[cursus].levels[levelNum];
            
            if (level) {
                // Restaurer les variables si elles existent
                if (level.variables) {
                    createdVariables = [...(level.variables.createdVariables || [])];
                    variables = { ...(level.variables.variableValues || {}) };
                    updateVariableDisplay();
                } else {
                    // Pas de variables sauvegard√©es, r√©initialiser
                    createdVariables = [];
                    variables = {};
                    updateVariableDisplay();
                }
                
                // Charger les blocs sauvegard√©s
                const programArea = document.getElementById('program-blocks');
                level.blocks.forEach(blockData => {
                    loadSavedBlock(blockData, programArea);
                });
                
                // Charger l'√©tat de la grille si disponible
                if (level.gridState) {
                    loadGridState(level.gridState);
                }
                
                // Charger les cellules peintes si disponibles
                if (level.paintedCells) {
                    loadPaintedCells(level.paintedCells);
                } else {
                    clearPaintedCells();
                }
                
                // Ex√©cuter automatiquement le programme pour afficher le motif (pour tous les niveaux)
                setTimeout(() => executeProgram(), 100);
            }
        }
        
        // Variable pour stocker le dernier niveau charg√©
        let lastLoadedLevel = null;
        
        // √âcraser le niveau s√©lectionn√© avec les modifications actuelles
        function overwriteSelectedLevel() {
            const levelNum = document.getElementById('teacher-level-select').value;
            
            if (levelNum === 'new') {
                alert('‚ö†Ô∏è Veuillez d\'abord s√©lectionner un niveau existant √† √©craser, ou utilisez le bouton "Ajouter" pour cr√©er un nouveau niveau.');
                return;
            }
            
            const cursus = document.getElementById('teacher-cursus-select').value;
            
            // R√©cup√©rer les blocs du programme
            const programBlocks = document.getElementById('program-blocks');
            const blocks = programBlocks.querySelectorAll(':scope > .program-block');
            const savedBlocks = [];
            
            blocks.forEach(block => {
                const blockData = extractBlockData(block);
                savedBlocks.push(blockData);
            });
            
            if (savedBlocks.length === 0) {
                alert('‚ö†Ô∏è Veuillez cr√©er un programme avec des blocs avant d\'√©craser le niveau');
                return;
            }
            
            // Sauvegarder l'√©tat de la grille
            const gridState = getGridState();
            
            // Sauvegarder les cellules peintes
            const paintedCellsData = getPaintedCellsData();
            
            const newLevel = {
                blocks: savedBlocks,
                blockCount: countTotalBlocks(blocks),
                gridState: gridState,
                paintedCells: paintedCellsData
            };
            
            // Sauvegarder les variables si elles existent
            if (createdVariables.length > 0) {
                newLevel.variables = {
                    createdVariables: [...createdVariables],
                    variableValues: { ...variables }
                };
            }
            
            // √âcraser le niveau existant
            cursusData[cursus].levels[levelNum] = newLevel;
            
            saveToStorage();
            markAsModified(); // Marquer qu'il y a eu des modifications
            
            // Recharger le niveau pour confirmer les modifications
            // On d√©sactive temporairement onchange pour √©viter de recharger deux fois
            const levelSelect = document.getElementById('teacher-level-select');
            levelSelect.onchange = null;
            loadTeacherLevel();
            levelSelect.onchange = saveCurrentAndLoadTeacherLevel;
            
            showResult(`‚úÖ Niveau ${levelNum} √©cras√© avec succ√®s !`, true);
        }
        
        // Charger un niveau SANS sauvegarder automatiquement
        function saveCurrentAndLoadTeacherLevel() {
            const levelSelect = document.getElementById('teacher-level-select');
            const newLevel = levelSelect.value;
            
            // NE PLUS sauvegarder automatiquement - l'utilisateur doit cliquer sur "√âcraser niveau"
            // Simplement charger le nouveau niveau
            loadTeacherLevel();
        }
        
        function loadSavedBlock(blockData, container) {
            // Recr√©er le HTML du bloc
            let blockHTML = '';
            let blockClass = '';
            
            switch(blockData.type) {
                case 'color':
                    blockClass = 'looks';
                    blockHTML = `<div class="block ${blockClass}" data-type="color" data-value="${blockData.value}">couleur ${blockData.value.toUpperCase()}</div>`;
                    break;
                case 'forward':
                    blockClass = 'motion';
                    blockHTML = '<div class="block motion" data-type="forward">avancer</div>';
                    break;
                case 'back':
                    blockClass = 'motion';
                    blockHTML = '<div class="block motion" data-type="back">reculer</div>';
                    break;
                case 'right':
                    blockClass = 'motion';
                    blockHTML = '<div class="block motion" data-type="right">tourner ‚Üª droite</div>';
                    break;
                case 'left':
                    blockClass = 'motion';
                    blockHTML = '<div class="block motion" data-type="left">tourner ‚Ü∫ gauche</div>';
                    break;
                case 'repeat':
                    blockClass = 'control';
                    if (blockData.timesVar) {
                        // Si une variable est utilis√©e, recr√©er le bloc avec le bloc variable
                        blockHTML = `<div class="block control" data-type="repeat">
                            r√©p√©ter 
                            <span class="value-slot filled" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)">
                                <div class="block variables inline-block" data-type="var-value">
                                    <select onclick="event.stopPropagation()" class="var-select">
                                        <option value="">variable</option>
                                    </select>
                                </div>
                            </span>
                            fois
                        </div>`;
                    } else {
                        // Sinon, utiliser l'input number
                        blockHTML = `<div class="block control" data-type="repeat">
                            r√©p√©ter 
                            <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)">
                                <input type="number" value="${blockData.times || 10}" min="1" max="100">
                            </span>
                            fois
                        </div>`;
                    }
                    break;
                case 'variable':
                    blockClass = 'variables';
                    if (blockData.varValueVar) {
                        // Si une variable est utilis√©e pour la valeur
                        blockHTML = `<div class="block variables" data-type="variable">
                            mettre <select onclick="event.stopPropagation()" class="var-select"><option value="">nom</option></select> √† 
                            <span class="value-slot filled" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)">
                                <div class="block variables inline-block" data-type="var-value">
                                    <select onclick="event.stopPropagation()" class="var-select">
                                        <option value="">variable</option>
                                    </select>
                                </div>
                            </span>
                        </div>`;
                    } else {
                        // Sinon, utiliser l'input number
                        blockHTML = `<div class="block variables" data-type="variable">
                            mettre <select onclick="event.stopPropagation()" class="var-select"><option value="">nom</option></select> √† 
                            <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)">
                                <input type="number" value="${blockData.varValue || 0}" onclick="event.stopPropagation()">
                            </span>
                        </div>`;
                    }
                    break;
                case 'change-var':
                    blockClass = 'variables';
                    if (blockData.changeValueVar) {
                        // Si une variable est utilis√©e pour la valeur
                        blockHTML = `<div class="block variables" data-type="change-var">
                            ajouter 
                            <span class="value-slot filled" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)">
                                <div class="block variables inline-block" data-type="var-value">
                                    <select onclick="event.stopPropagation()" class="var-select">
                                        <option value="">variable</option>
                                    </select>
                                </div>
                            </span>
                            √† <select onclick="event.stopPropagation()" class="var-select"><option value="">nom</option></select>
                        </div>`;
                    } else {
                        // Sinon, utiliser l'input number
                        blockHTML = `<div class="block variables" data-type="change-var">
                            ajouter 
                            <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)">
                                <input type="number" value="${blockData.changeValue || 1}" onclick="event.stopPropagation()">
                            </span>
                            √† <select onclick="event.stopPropagation()" class="var-select"><option value="">nom</option></select>
                        </div>`;
                    }
                    break;
                case 'if':
                    blockClass = 'sensing';
                    blockHTML = `<div class="block sensing" data-type="if">
                        si 
                        <select class="var-select" onclick="event.stopPropagation()">
                            <option value="">variable</option>
                        </select>
                        <select class="compare-op" onclick="event.stopPropagation()">
                            <option value="<"${blockData.operator === '<' ? ' selected' : ''}>&lt;</option>
                            <option value=">"${blockData.operator === '>' ? ' selected' : ''}>&gt;</option>
                            <option value="="${blockData.operator === '=' ? ' selected' : ''}>=</option>
                            <option value="<="${blockData.operator === '<=' ? ' selected' : ''}>&le;</option>
                            <option value=">="${blockData.operator === '>=' ? ' selected' : ''}>&ge;</option>
                        </select>
                        <span class="value-slot" ondrop="dropValueOrOperator(event)" ondragover="allowDrop(event)">
                            <input type="text" value="${blockData.compareValue || ''}" placeholder="valeur" onclick="event.stopPropagation()">
                        </span>
                        alors
                    </div>`;
                    break;
            }
            
            const blockElement = document.createElement('div');
            blockElement.className = 'program-block';
            
            if (blockData.type === 'repeat' || blockData.type === 'if') {
                blockElement.classList.add('block-capsule');
                blockElement.innerHTML = blockHTML;
                
                const block = blockElement.querySelector('.block');
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '√ó';
                removeBtn.onclick = function() {
                    blockElement.remove();
                    updateBlockCount();
                };
                block.appendChild(removeBtn);
                
                // Pour le bloc if, remplir le s√©lecteur de variables
                if (blockData.type === 'if') {
                    const varSelect = block.querySelector('.var-select');
                    if (varSelect) {
                        // Ajouter toutes les variables disponibles
                        for (let varName of createdVariables) {
                            const option = document.createElement('option');
                            option.value = varName;
                            option.textContent = varName;
                            if (varName === blockData.varName) {
                                option.selected = true;
                            }
                            varSelect.appendChild(option);
                        }
                    }
                }
                
                // Pour le bloc repeat avec variable, remplir le s√©lecteur de variables
                if (blockData.type === 'repeat' && blockData.timesVar) {
                    const varSelect = block.querySelector('.var-select');
                    if (varSelect) {
                        // Ajouter toutes les variables disponibles
                        for (let varName of createdVariables) {
                            const option = document.createElement('option');
                            option.value = varName;
                            option.textContent = varName;
                            if (varName === blockData.timesVar) {
                                option.selected = true;
                            }
                            varSelect.appendChild(option);
                        }
                    }
                }
                
                // Pour le bloc variable, remplir les s√©lecteurs
                if (blockData.type === 'variable') {
                    // Remplir le premier s√©lecteur (nom de la variable √† cr√©er)
                    const varSelects = block.querySelectorAll('.var-select');
                    if (varSelects[0]) {
                        for (let varName of createdVariables) {
                            const option = document.createElement('option');
                            option.value = varName;
                            option.textContent = varName;
                            if (varName === blockData.varName) {
                                option.selected = true;
                            }
                            varSelects[0].appendChild(option);
                        }
                    }
                    
                    // Si une variable est utilis√©e pour la valeur, remplir le deuxi√®me s√©lecteur
                    if (blockData.varValueVar && varSelects[1]) {
                        for (let varName of createdVariables) {
                            const option = document.createElement('option');
                            option.value = varName;
                            option.textContent = varName;
                            if (varName === blockData.varValueVar) {
                                option.selected = true;
                            }
                            varSelects[1].appendChild(option);
                        }
                    }
                }
                
                // Pour le bloc change-var, remplir les s√©lecteurs
                if (blockData.type === 'change-var') {
                    const varSelects = block.querySelectorAll('.var-select');
                    
                    // Si une variable est utilis√©e pour la valeur de changement, remplir le premier s√©lecteur
                    if (blockData.changeValueVar && varSelects[0]) {
                        for (let varName of createdVariables) {
                            const option = document.createElement('option');
                            option.value = varName;
                            option.textContent = varName;
                            if (varName === blockData.changeValueVar) {
                                option.selected = true;
                            }
                            varSelects[0].appendChild(option);
                        }
                    }
                    
                    // Remplir le dernier s√©lecteur (nom de la variable √† modifier)
                    const lastSelect = varSelects[varSelects.length - 1];
                    if (lastSelect) {
                        for (let varName of createdVariables) {
                            const option = document.createElement('option');
                            option.value = varName;
                            option.textContent = varName;
                            if (varName === blockData.varName) {
                                option.selected = true;
                            }
                            lastSelect.appendChild(option);
                        }
                    }
                }
                
                // Ajouter zone pour les blocs imbriqu√©s
                const nestedArea = document.createElement('div');
                nestedArea.className = 'nested-blocks';
                if (!blockData.nested || blockData.nested.length === 0) {
                    nestedArea.classList.add('empty');
                }
                nestedArea.ondrop = function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    
                    const dataText = e.dataTransfer.getData('text');
                    if (!dataText) return;
                    
                    let nestedData;
                    try {
                        nestedData = JSON.parse(dataText);
                    } catch (err) {
                        console.error('Erreur de parsing JSON:', err);
                        return;
                    }
                    
                    addNestedBlock(nestedData, nestedArea);
                    nestedArea.classList.remove('empty');
                };
                nestedArea.ondragover = function(e) { 
                    e.preventDefault(); 
                    e.stopPropagation();
                };
                blockElement.appendChild(nestedArea);
                
                // Charger les blocs imbriqu√©s
                if (blockData.nested && blockData.nested.length > 0) {
                    blockData.nested.forEach(nested => {
                        loadSavedBlock(nested, nestedArea);
                    });
                }
                
                // Ajouter le bas de la capsule
                const capsuleBottom = document.createElement('div');
                capsuleBottom.className = 'block-capsule-bottom';
                capsuleBottom.style.background = getComputedStyle(block).background;
                blockElement.appendChild(capsuleBottom);
            } else {
                blockElement.innerHTML = blockHTML;
                
                const block = blockElement.querySelector('.block');
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '√ó';
                removeBtn.onclick = function() {
                    blockElement.remove();
                    updateBlockCount();
                };
                block.appendChild(removeBtn);
            }
            
            // Rendre le bloc d√©pla√ßable
            blockElement.draggable = true;
            blockElement.ondragstart = function(e) {
                e.stopPropagation();
                blockElement.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            };
            
            blockElement.ondragend = function() {
                blockElement.classList.remove('dragging');
                document.querySelectorAll('.drag-over-top, .drag-over-bottom').forEach(el => {
                    el.classList.remove('drag-over-top', 'drag-over-bottom');
                });
            };
            
            container.appendChild(blockElement);
            
            // IMPORTANT: Peupler tous les selects de variables avec createdVariables
            const varSelects = blockElement.querySelectorAll('.var-select, select.var-select');
            varSelects.forEach(select => {
                // Sauvegarder la valeur √† s√©lectionner
                let valueToSelect = select.value || select.getAttribute('data-value');
                
                // Si c'est dans un repeat et qu'on a timesVar
                const parentBlock = select.closest('.block[data-type="repeat"]');
                if (parentBlock && blockData.type === 'repeat' && blockData.timesVar) {
                    valueToSelect = blockData.timesVar;
                }
                
                // Si c'est dans un variable et qu'on a varName
                const varBlock = select.closest('.block[data-type="variable"]');
                if (varBlock && blockData.type === 'variable' && blockData.varName) {
                    // C'est le premier select (nom de la variable)
                    if (select.classList.contains('var-select') && !select.closest('.value-slot')) {
                        valueToSelect = blockData.varName;
                    }
                    // C'est le second select (valeur variable)
                    else if (blockData.varValueVar) {
                        valueToSelect = blockData.varValueVar;
                    }
                }
                
                // Si c'est dans un change-var
                const changeVarBlock = select.closest('.block[data-type="change-var"]');
                if (changeVarBlock && blockData.type === 'change-var') {
                    if (blockData.varName && !select.closest('.value-slot')) {
                        valueToSelect = blockData.varName;
                    } else if (blockData.changeValueVar) {
                        valueToSelect = blockData.changeValueVar;
                    }
                }
                
                // Si c'est dans un if
                const ifBlock = select.closest('.block[data-type="if"]');
                if (ifBlock && blockData.type === 'if' && blockData.varName) {
                    if (select.classList.contains('var-select')) {
                        valueToSelect = blockData.varName;
                    }
                }
                
                // Peupler le select avec les variables disponibles
                select.innerHTML = '<option value="">choisir...</option>';
                createdVariables.forEach(varName => {
                    const option = document.createElement('option');
                    option.value = varName;
                    option.textContent = varName;
                    if (varName === valueToSelect) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
                
                // Si aucune variable ne correspond, ajouter une option pour la valeur
                if (valueToSelect && !createdVariables.includes(valueToSelect)) {
                    const option = document.createElement('option');
                    option.value = valueToSelect;
                    option.textContent = valueToSelect;
                    option.selected = true;
                    select.appendChild(option);
                }
            });
        }
        
        function loadGridState(gridState) {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (gridState[y] && gridState[y][x]) {
                        paintCell(x, y, gridState[y][x]);
                    }
                }
            }
        }
        
        async function deleteLevel() {
            const levelNum = document.getElementById('teacher-level-select').value;
            if (levelNum === 'new') {
                alert('Aucun niveau s√©lectionn√© √† supprimer');
                return;
            }
            
            const cursus = document.getElementById('teacher-cursus-select').value;
            const level = cursusData[cursus].levels[levelNum];
            
            if (!level) {
                alert('Niveau introuvable');
                return;
            }
            
            // Afficher la popup de confirmation personnalis√©e
            const confirmed = await customConfirm(`‚ö†Ô∏è Supprimer le niveau ${levelNum} ?\n\nCette action est irr√©versible.`);
            
            if (confirmed) {
                // Supprimer le niveau
                delete cursusData[cursus].levels[levelNum];
                
                // Sauvegarder
                saveToStorage();
                markAsModified(); // Marquer qu'il y a eu des modifications
                
                // Recharger l'interface
                loadTeacherLevels();
                
                alert('‚úÖ Niveau supprim√© !');
            }
        }

        function addOrSaveLevel() {
            // TOUJOURS ajouter un nouveau niveau (ignorer le niveau s√©lectionn√©)
            const cursus = document.getElementById('teacher-cursus-select').value;
            
            // V√©rifier le nombre total de niveaux dans TOUS les cursus
            let totalLevels = 0;
            for (let cursusName in cursusData) {
                totalLevels += Object.keys(cursusData[cursusName].levels).length;
            }
            
            if (totalLevels >= MAX_TOTAL_LEVELS) {
                alert('‚ùå Limite atteinte : vous avez d√©j√† ${MAX_TOTAL_LEVELS} niveaux au total (tous cursus confondus). Impossible d\'en ajouter davantage.');
                return;
            }
            
            // R√©cup√©rer les blocs du programme
            const programBlocks = document.getElementById('program-blocks');
            const blocks = programBlocks.querySelectorAll(':scope > .program-block');
            const savedBlocks = [];
            
            blocks.forEach(block => {
                const blockData = extractBlockData(block);
                savedBlocks.push(blockData);
            });
            
            if (savedBlocks.length === 0) {
                alert('Veuillez cr√©er un programme avec des blocs avant d\'ajouter');
                return;
            }
            
            // Sauvegarder l'√©tat de la grille
            const gridState = getGridState();
            
            // Sauvegarder les cellules peintes
            const paintedCellsData = getPaintedCellsData();
            
            const newLevel = {
                blocks: savedBlocks,
                blockCount: countTotalBlocks(blocks),
                gridState: gridState,
                paintedCells: paintedCellsData
            };
            
            // Calculer le nombre total de niveaux possibles selon la configuration
            const levelsPerWorld = cursusData[cursus].levelsPerWorld || 10;
            const numWorlds = cursusData[cursus].worlds || 1;
            const totalPossibleLevels = numWorlds * levelsPerWorld;
            
            // Obtenir les niveaux existants tri√©s
            const existingLevels = Object.keys(cursusData[cursus].levels).map(n => parseInt(n)).sort((a, b) => a - b);
            
            let nextLevelNum = 1;
            
            // Chercher le premier trou dans TOUS les niveaux possibles
            for (let i = 1; i <= totalPossibleLevels; i++) {
                if (!existingLevels.includes(i)) {
                    // Trou trouv√© !
                    nextLevelNum = i;
                    break;
                }
            }
            
            // Si tous les niveaux sont remplis, ajouter apr√®s le dernier
            if (existingLevels.includes(nextLevelNum) || nextLevelNum > totalPossibleLevels) {
                if (existingLevels.length > 0) {
                    nextLevelNum = Math.max(...existingLevels) + 1;
                } else {
                    nextLevelNum = 1;
                }
            }
            
            // Sauvegarder les variables si elles existent
            if (createdVariables.length > 0) {
                newLevel.variables = {
                    createdVariables: [...createdVariables],
                    variableValues: { ...variables }
                };
            }
            
            cursusData[cursus].levels[nextLevelNum.toString()] = newLevel;
            
            // Calculer le nombre de mondes n√©cessaires
            const requiredWorlds = Math.ceil(nextLevelNum / levelsPerWorld);
            
            // Mettre √† jour le nombre de mondes si n√©cessaire
            if (!cursusData[cursus].worlds || cursusData[cursus].worlds < requiredWorlds) {
                cursusData[cursus].worlds = requiredWorlds;
                
                // Ajuster aussi pointsPerWorld
                if (!cursusData[cursus].pointsPerWorld) {
                    cursusData[cursus].pointsPerWorld = [0];
                }
                while (cursusData[cursus].pointsPerWorld.length < requiredWorlds) {
                    cursusData[cursus].pointsPerWorld.push(0);
                }
            }
            
            saveToStorage();
            markAsModified(); // Marquer qu'il y a eu des modifications
            loadTeacherLevels();
            
            // S√©lectionner le niveau ajout√©
            const levelSelect = document.getElementById('teacher-level-select');
            levelSelect.value = nextLevelNum.toString();
            
            // Charger ce niveau
            if (nextLevelNum.toString() !== levelSelect.options[1]?.value) {
                levelSelect.onchange = null;
                loadTeacherLevel();
                levelSelect.onchange = saveCurrentAndLoadTeacherLevel;
            }
            
            const worldNum = Math.floor((nextLevelNum - 1) / levelsPerWorld) + 1;
            const levelInWorld = ((nextLevelNum - 1) % levelsPerWorld) + 1;
            showResult(`‚úÖ Niveau cr√©√© : Monde ${worldNum}, Niveau ${levelInWorld} !`, true);
        }

        function saveLevel() {
            const cursus = document.getElementById('teacher-cursus-select').value;
            
            // R√©cup√©rer les blocs du programme
            const programBlocks = document.getElementById('program-blocks');
            const blocks = programBlocks.querySelectorAll(':scope > .program-block');
            const savedBlocks = [];
            
            blocks.forEach(block => {
                const blockData = extractBlockData(block);
                savedBlocks.push(blockData);
            });
            
            if (savedBlocks.length === 0) {
                alert('Veuillez cr√©er un programme avec des blocs avant de sauvegarder');
                return;
            }
            
            // Sauvegarder l'√©tat de la grille
            const gridState = getGridState();
            
            // Sauvegarder les cellules peintes
            const paintedCellsData = getPaintedCellsData();
            
            const newLevel = {
                blocks: savedBlocks,
                blockCount: countTotalBlocks(blocks),
                gridState: gridState,
                paintedCells: paintedCellsData
            };
            
            const levelNum = document.getElementById('teacher-level-select').value;
            let savedLevelNum; // Variable pour stocker le num√©ro du niveau sauvegard√©
            
            if (levelNum === 'new') {
                // Calculer le nombre total de niveaux possibles selon la configuration
                const levelsPerWorld = cursusData[cursus].levelsPerWorld || 10;
                const numWorlds = cursusData[cursus].worlds || 1;
                const totalPossibleLevels = numWorlds * levelsPerWorld;
                
                // Obtenir les niveaux existants tri√©s
                const existingLevels = Object.keys(cursusData[cursus].levels).map(n => parseInt(n)).sort((a, b) => a - b);
                
                let nextLevelNum = 1;
                
                // Chercher le premier trou dans TOUS les niveaux possibles (pas seulement jusqu'au dernier existant)
                for (let i = 1; i <= totalPossibleLevels; i++) {
                    if (!existingLevels.includes(i)) {
                        // Trou trouv√© !
                        nextLevelNum = i;
                        break;
                    }
                }
                
                // Si tous les niveaux sont remplis, ajouter apr√®s le dernier
                if (existingLevels.includes(nextLevelNum) || nextLevelNum > totalPossibleLevels) {
                    if (existingLevels.length > 0) {
                        nextLevelNum = Math.max(...existingLevels) + 1;
                    } else {
                        nextLevelNum = 1;
                    }
                }
                
                // Sauvegarder les variables si elles existent
                if (createdVariables.length > 0) {
                    newLevel.variables = {
                        createdVariables: [...createdVariables],
                        variableValues: { ...variables }
                    };
                }
                
                cursusData[cursus].levels[nextLevelNum.toString()] = newLevel;
                savedLevelNum = nextLevelNum.toString(); // Stocker le num√©ro du nouveau niveau
                
                // Calculer le nombre de mondes n√©cessaires
                const requiredWorlds = Math.ceil(nextLevelNum / levelsPerWorld);
                
                // Mettre √† jour le nombre de mondes si n√©cessaire
                if (!cursusData[cursus].worlds || cursusData[cursus].worlds < requiredWorlds) {
                    cursusData[cursus].worlds = requiredWorlds;
                    
                    // Ajuster aussi pointsPerWorld
                    if (!cursusData[cursus].pointsPerWorld) {
                        cursusData[cursus].pointsPerWorld = [0];
                    }
                    while (cursusData[cursus].pointsPerWorld.length < requiredWorlds) {
                        cursusData[cursus].pointsPerWorld.push(0);
                    }
                }
                
                const worldNum = Math.floor((nextLevelNum - 1) / levelsPerWorld) + 1;
                const levelInWorld = ((nextLevelNum - 1) % levelsPerWorld) + 1;
                showResult(`‚úÖ Niveau cr√©√© : Monde ${worldNum}, Niveau ${levelInWorld} !`, true);
            } else {
                // Sauvegarder les variables si elles existent
                if (createdVariables.length > 0) {
                    newLevel.variables = {
                        createdVariables: [...createdVariables],
                        variableValues: { ...variables }
                    };
                }
                
                cursusData[cursus].levels[levelNum] = newLevel;
                savedLevelNum = levelNum; // Stocker le num√©ro du niveau modifi√©
                showResult('‚úÖ Niveau modifi√© avec succ√®s !', true);
            }
            
            saveToStorage();
            loadTeacherLevels();
            
            // Res√©lectionner le niveau qui vient d'√™tre sauvegard√©
            const levelSelect = document.getElementById('teacher-level-select');
            levelSelect.value = savedLevelNum;
            
            // Charger explicitement ce niveau (car loadTeacherLevels a d√©j√† charg√© le premier)
            if (savedLevelNum !== levelSelect.options[1]?.value) {
                // D√©sactiver temporairement onchange pour √©viter double appel
                levelSelect.onchange = null;
                loadTeacherLevel();
                levelSelect.onchange = saveCurrentAndLoadTeacherLevel;
            }
        }
        
        function extractBlockData(blockElement) {
            const block = blockElement.querySelector('.block');
            const type = block.dataset.type;
            const blockData = { type };
            
            if (type === 'color') {
                blockData.value = block.dataset.value;
            } else if (type === 'repeat') {
                const valueSlot = block.querySelector('.value-slot');
                
                // V√©rifier si un bloc variable a √©t√© d√©pos√©
                const varBlock = valueSlot ? valueSlot.querySelector('.block[data-type="var-value"]') : null;
                if (varBlock) {
                    const varSelect = varBlock.querySelector('select');
                    blockData.timesVar = varSelect ? varSelect.value : '';
                } else {
                    const input = block.querySelector('input[type="number"]');
                    blockData.times = input ? parseInt(input.value) : 10;
                }
                
                // R√©cup√©rer les blocs imbriqu√©s
                const nestedArea = blockElement.querySelector('.nested-blocks');
                if (nestedArea) {
                    const nestedBlocks = nestedArea.querySelectorAll(':scope > .program-block');
                    blockData.nested = [];
                    nestedBlocks.forEach(nested => {
                        blockData.nested.push(extractBlockData(nested));
                    });
                }
            } else if (type === 'variable') {
                const varSelect = block.querySelector('.var-select');
                blockData.varName = varSelect ? varSelect.value : '';
                
                // R√©cup√©rer la valeur depuis le value-slot
                const valueSlot = block.querySelector('.value-slot');
                if (valueSlot) {
                    const varBlock = valueSlot.querySelector('.block[data-type="var-value"]');
                    const operatorBlock = valueSlot.querySelector('.block[data-type="operator"]');
                    
                    if (varBlock) {
                        const refVarSelect = varBlock.querySelector('select');
                        blockData.varValueVar = refVarSelect ? refVarSelect.value : '';
                    } else if (operatorBlock) {
                        blockData.varValueOperator = extractBlockData(operatorBlock.parentElement);
                    } else {
                        const input = valueSlot.querySelector('input[type="number"]');
                        blockData.varValue = input ? input.value : '0';
                    }
                }
            } else if (type === 'change-var') {
                const varSelect = block.querySelector('select');
                blockData.varName = varSelect ? varSelect.value : '';
                
                // R√©cup√©rer la valeur depuis le value-slot
                const valueSlot = block.querySelector('.value-slot');
                if (valueSlot) {
                    const varBlock = valueSlot.querySelector('.block[data-type="var-value"]');
                    const operatorBlock = valueSlot.querySelector('.block[data-type="operator"]');
                    
                    if (varBlock) {
                        const refVarSelect = varBlock.querySelector('select');
                        blockData.changeValueVar = refVarSelect ? refVarSelect.value : '';
                    } else if (operatorBlock) {
                        blockData.changeValueOperator = extractBlockData(operatorBlock.parentElement);
                    } else {
                        const input = valueSlot.querySelector('input[type="number"]');
                        blockData.changeValue = input ? input.value : '1';
                    }
                }
            } else if (type === 'if') {
                const varSelect = block.querySelector('.var-select');
                const compareOp = block.querySelector('.compare-op');
                const valueSlot = block.querySelector('.value-slot');
                const valueInput = valueSlot ? valueSlot.querySelector('input[type="text"]') : null;
                
                blockData.varName = varSelect ? varSelect.value : '';
                blockData.operator = compareOp ? compareOp.value : '=';
                blockData.compareValue = valueInput ? valueInput.value : '';
                
                // R√©cup√©rer les blocs imbriqu√©s
                const nestedArea = blockElement.querySelector('.nested-blocks');
                if (nestedArea) {
                    const nestedBlocks = nestedArea.querySelectorAll(':scope > .program-block');
                    blockData.nested = [];
                    nestedBlocks.forEach(nested => {
                        blockData.nested.push(extractBlockData(nested));
                    });
                }
            } else if (type === 'operator') {
                const valueSlots = block.querySelectorAll('.value-slot');
                const select = block.querySelector('select');
                blockData.op = select ? select.value : block.dataset.op;
                
                // Premier emplacement (a)
                if (valueSlots[0]) {
                    const varBlock = valueSlots[0].querySelector('.block[data-type="var-value"]');
                    if (varBlock) {
                        const varSelect = varBlock.querySelector('select');
                        blockData.aVar = varSelect ? varSelect.value : '';
                    } else {
                        const input = valueSlots[0].querySelector('input[type="text"]');
                        blockData.a = input ? input.value : '';
                    }
                }
                
                // Deuxi√®me emplacement (b)
                if (valueSlots[1]) {
                    const varBlock = valueSlots[1].querySelector('.block[data-type="var-value"]');
                    if (varBlock) {
                        const varSelect = varBlock.querySelector('select');
                        blockData.bVar = varSelect ? varSelect.value : '';
                    } else {
                        const input = valueSlots[1].querySelector('input[type="text"]');
                        blockData.b = input ? input.value : '';
                    }
                }
            }
            
            return blockData;
        }
        
        function countTotalBlocks(blocks) {
            let count = 0;
            blocks.forEach(block => {
                count++;
                const nestedArea = block.querySelector('.nested-blocks');
                if (nestedArea) {
                    const nestedBlocks = nestedArea.querySelectorAll(':scope > .program-block');
                    count += countTotalBlocks(nestedBlocks);
                }
            });
            return count;
        }

        // Affichage des variables
        function updateVariableDisplay() {
            const varDisplay = document.getElementById('variable-display');
            const varList = document.getElementById('variables-list');
            
            if (Object.keys(variables).length > 0) {
                varDisplay.style.display = 'block';
                varList.innerHTML = '';
                for (let [name, value] of Object.entries(variables)) {
                    const varItem = document.createElement('div');
                    varItem.textContent = `${name} = ${value}`;
                    varList.appendChild(varItem);
                }
            } else {
                varDisplay.style.display = 'none';
            }
            
            // Mettre √† jour tous les s√©lecteurs de variables dans la palette
            updateVariableSelectors();
        }
        
        function updateVariableSelectors() {
            // Ne mettre √† jour que les s√©lecteurs dans la palette (middle-panel), pas ceux dans la zone de programmation
            const palette = document.querySelector('.middle-panel');
            if (!palette) return;
            
            const varSelects = palette.querySelectorAll('.var-select');
            const lastVariable = createdVariables.length > 0 ? createdVariables[createdVariables.length - 1] : '';
            
            varSelects.forEach(select => {
                const currentValue = select.value;
                const hadNoValue = currentValue === '' || currentValue === 'variable';
                select.innerHTML = '<option value="">variable</option>';
                
                for (let varName of createdVariables) {
                    const option = document.createElement('option');
                    option.value = varName;
                    option.textContent = varName;
                    
                    // Si c'√©tait la valeur s√©lectionn√©e, la garder
                    if (varName === currentValue) {
                        option.selected = true;
                    }
                    // Sinon, si le s√©lecteur √©tait vide, s√©lectionner la derni√®re variable
                    else if (hadNoValue && varName === lastVariable) {
                        option.selected = true;
                    }
                    
                    select.appendChild(option);
                }
                
                // S'assurer que la valeur est bien restaur√©e
                if (currentValue && createdVariables.includes(currentValue)) {
                    select.value = currentValue;
                }
            });
        }

        // Stockage local - D√âSACTIV√â (on utilise maintenant la sauvegarde en ligne uniquement)
        function saveToStorage() {
            // Ne plus sauvegarder localement
            // Les niveaux sont uniquement sauvegard√©s en ligne via api.php
        }

        function loadFromStorage() {
            // NETTOYER le localStorage au d√©marrage (page vide par d√©faut)
            localStorage.removeItem('cursusData');
            
            // R√©initialiser le score √† z√©ro
            score = 0;
            const scoreElement = document.getElementById('score');
            if (scoreElement) {
                scoreElement.textContent = score;
            }
            localStorage.setItem('score', '0');
            
            // R√©initialiser aussi les niveaux compl√©t√©s √† z√©ro
            completedLevels = {};
            localStorage.setItem('completedLevels', JSON.stringify(completedLevels));
        }

        function saveScore() {
            localStorage.setItem('score', score.toString());
        }

        function saveCompletedLevels() {
            try {
                localStorage.setItem('completedLevels', JSON.stringify(completedLevels));
            } catch (e) {
                console.error('Erreur de sauvegarde des niveaux compl√©t√©s:', e);
            }
        }

        // Messages
        function showResult(message, success) {
            const resultDiv = currentMode === 'student' ? 
                document.getElementById('result-message') : 
                document.getElementById('teacher-result-message');
            if (resultDiv) {
                resultDiv.textContent = message;
                resultDiv.className = success ? 'result-message success' : 'result-message error';
            }
        }

        // ========================================
        // SYST√àME DE SAUVEGARDE EN LIGNE
        // ========================================
        
        let captchaNum1, captchaNum2, captchaAnswer;
        let generatedPassword = '';

        // G√©n√©rer un code al√©atoire de 8 caract√®res
        function generatePassword() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Sans O, 0, I, 1 pour √©viter confusion
            let password = '';
            for (let i = 0; i < 8; i++) {
                password += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return password;
        }

        // Copier le mot de passe dans le presse-papier
        function copyPassword() {
            const passwordInput = document.getElementById('save-password');
            passwordInput.select();
            document.execCommand('copy');
            
            // Feedback visuel
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = '‚úÖ Copi√© !';
            button.style.background = '#4CAF50';
            setTimeout(() => {
                button.textContent = originalText;
                button.style.background = '#2196F3';
            }, 2000);
        }

        // G√©n√©rer un nouveau captcha
        function generateCaptcha() {
            captchaNum1 = Math.floor(Math.random() * 10) + 1;
            captchaNum2 = Math.floor(Math.random() * 10) + 1;
            captchaAnswer = captchaNum1 + captchaNum2;
            document.getElementById('captcha-question').textContent = `${captchaNum1} + ${captchaNum2} =`;
        }

        // Sauvegarder le niveau en cours puis ouvrir le modal de sauvegarde en ligne
        function saveLevelBeforeOnline() {
            const levelSelect = document.getElementById('teacher-level-select');
            
            // Si un niveau est en cours d'√©dition (pas "new"), le sauvegarder d'abord
            if (levelSelect && levelSelect.value !== 'new') {
                // V√©rifier qu'il y a des blocs dans le programme
                const programBlocks = document.getElementById('program-blocks');
                const blocks = programBlocks.querySelectorAll(':scope > .program-block');
                
                if (blocks.length > 0) {
                    // Sauvegarder le niveau en cours dans cursusData
                    saveLevel();
                }
            }
            
            // Ouvrir le modal de sauvegarde en ligne
            openSaveOnlineModal();
        }

        // Ouvrir le modal de sauvegarde
        function openSaveOnlineModal() {
            document.getElementById('save-online-modal').classList.add('active');
            document.getElementById('save-prof-name').value = '';
            document.getElementById('captcha-answer').value = '';
            document.getElementById('save-message').innerHTML = '';
            document.getElementById('success-url').style.display = 'none';
            
            // R√©initialiser les boutons (au cas o√π on aurait sauvegard√© avant)
            const buttonsDiv = document.getElementById('save-modal-buttons');
            buttonsDiv.innerHTML = `
                <button class="btn-confirm" onclick="confirmSaveOnline()">üíæ Sauvegarder</button>
                <button class="btn-cancel" onclick="closeSaveOnlineModal()">Annuler</button>
            `;
            
            // G√©n√©rer un nouveau code
            generatedPassword = generatePassword();
            document.getElementById('save-password').value = generatedPassword;
            
            generateCaptcha();
        }

        // Fermer le modal de sauvegarde
        function closeSaveOnlineModal() {
            document.getElementById('save-online-modal').classList.remove('active');
        }

        // Ouvrir le modal de chargement
        // Variables globales pour le tracking des modifications
        let loadedProfName = null;
        let hasModifications = false;
        
        // Ouvrir le modal de chargement des niveaux
        async function openLoadOnlineModal() {
            document.getElementById('load-online-modal').classList.add('active');
            document.getElementById('search-prof-name').value = '';
            document.getElementById('load-message').innerHTML = '';
            
            // Charger la liste des professeurs
            await loadProfessorsList();
        }

        // Fermer le modal de chargement
        function closeLoadOnlineModal() {
            document.getElementById('load-online-modal').classList.remove('active');
        }
        
        // Charger la liste de tous les professeurs
        async function loadProfessorsList() {
            const listDiv = document.getElementById('professors-list');
            listDiv.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">Chargement...</div>';
            
            try {
                const response = await fetch('api.php?action=list_professors');
                const result = await response.json();
                
                if (result.success && result.professors && result.professors.length > 0) {
                    listDiv.innerHTML = '';
                    result.professors.forEach(prof => {
                        const profDiv = document.createElement('div');
                        profDiv.className = 'professor-item';
                        profDiv.style.cssText = 'padding: 12px; margin: 5px 0; background: white; border: 2px solid #E0E0E0; border-radius: 6px; cursor: pointer; transition: all 0.2s;';
                        profDiv.innerHTML = `
                            <div style="font-weight: bold; font-size: 14px; color: #1976D2;">üë§ ${prof}</div>
                            <div style="font-size: 12px; color: #666; margin-top: 4px;">Cliquez pour charger les niveaux</div>
                        `;
                        profDiv.onmouseover = () => {
                            profDiv.style.background = '#E3F2FD';
                            profDiv.style.borderColor = '#2196F3';
                        };
                        profDiv.onmouseout = () => {
                            profDiv.style.background = 'white';
                            profDiv.style.borderColor = '#E0E0E0';
                        };
                        profDiv.onclick = () => loadProfessorLevels(prof);
                        listDiv.appendChild(profDiv);
                    });
                } else {
                    listDiv.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">Aucun professeur trouv√©</div>';
                }
            } catch (error) {
                console.error('Erreur:', error);
                listDiv.innerHTML = '<div style="text-align: center; color: #f44336; padding: 20px;">‚ùå Erreur de chargement</div>';
            }
        }
        
        // Filtrer la liste des professeurs
        function filterProfessors() {
            const searchValue = document.getElementById('search-prof-name').value.toLowerCase();
            const items = document.querySelectorAll('.professor-item');
            
            items.forEach(item => {
                const profName = item.textContent.toLowerCase();
                if (profName.includes(searchValue)) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        }
        
        // Charger les niveaux d'un professeur
        async function loadProfessorLevels(profName) {
            const messageDiv = document.getElementById('load-message');
            messageDiv.innerHTML = '<div class="info-box">‚è≥ Chargement en cours...</div>';
            
            try {
                const response = await fetch(`api.php?action=load_public&profName=${profName}`);
                const result = await response.json();
                
                if (result.success) {
                    // Charger les donn√©es
                    cursusData = result.cursusData;
                    saveToStorage();
                    loadTeacherLevels();
                    
                    // Marquer comme charg√© et sans modifications
                    loadedProfName = profName;
                    hasModifications = false;
                    updateCopyLinkButton();
                    
                    messageDiv.innerHTML = '<div class="info-box" style="background: #E8F5E9; border-color: #4CAF50; color: #2E7D32;">‚úÖ Niveaux charg√©s avec succ√®s !</div>';
                    
                    setTimeout(() => {
                        closeLoadOnlineModal();
                        showResult(`‚úÖ Niveaux de ${profName} charg√©s !`, true);
                    }, 1500);
                } else {
                    messageDiv.innerHTML = '<div class="error-message">‚ùå ' + result.message + '</div>';
                }
            } catch (error) {
                console.error('Erreur:', error);
                messageDiv.innerHTML = '<div class="error-message">‚ùå Erreur de chargement</div>';
            }
        }
        
        // Mettre √† jour la visibilit√© du bouton "Copier lien √©l√®ve"
        function updateCopyLinkButton() {
            const copyBtn = document.getElementById('copy-student-link-btn');
            const deleteBtn = document.getElementById('delete-online-btn');
            const mobileCopyBtn = document.getElementById('mobile-copy-student-link-btn');
            const mobileDeleteBtn = document.getElementById('mobile-delete-online-btn');
            
            console.log('üîç updateCopyLinkButton appel√©e');
            console.log('   loadedProfName:', loadedProfName);
            console.log('   hasModifications:', hasModifications);
            console.log('   mobileCopyBtn exists:', !!mobileCopyBtn);
            console.log('   mobileDeleteBtn exists:', !!mobileDeleteBtn);
            
            if (loadedProfName && !hasModifications) {
                console.log('   ‚úÖ Affichage des boutons');
                copyBtn.style.display = 'inline-block';
                deleteBtn.style.display = 'inline-block';
                // Utiliser setProperty avec !important pour surcharger le CSS
                if (mobileCopyBtn) mobileCopyBtn.style.setProperty('display', 'block', 'important');
                if (mobileDeleteBtn) mobileDeleteBtn.style.setProperty('display', 'block', 'important');
            } else {
                console.log('   ‚ùå Masquage des boutons');
                copyBtn.style.display = 'none';
                deleteBtn.style.display = 'none';
                // Utiliser setProperty avec !important pour surcharger le CSS
                if (mobileCopyBtn) mobileCopyBtn.style.setProperty('display', 'none', 'important');
                if (mobileDeleteBtn) mobileDeleteBtn.style.setProperty('display', 'none', 'important');
            }
            
            console.log('   mobileCopyBtn.style.display apr√®s:', mobileCopyBtn ? mobileCopyBtn.style.display : 'N/A');
            console.log('   mobileDeleteBtn.style.display apr√®s:', mobileDeleteBtn ? mobileDeleteBtn.style.display : 'N/A');
            
            // Synchroniser aussi les boutons sauvegarder/charger en ligne mobile
            syncMobileTeacherButtons();
        }
        
        // Copier le lien √©l√®ve
        function copyStudentLink() {
            if (!loadedProfName) {
                alert('‚ùå Aucun niveau charg√©');
                return;
            }
            
            const studentUrl = `https://www.lejardindesoiseaux.com/jeumotif/index.html?prof=${loadedProfName}`;
            
            // Copier dans le presse-papier
            navigator.clipboard.writeText(studentUrl).then(() => {
                const btn = document.getElementById('copy-student-link-btn');
                const originalText = btn.innerHTML;
                btn.innerHTML = '‚úÖ Copi√© !';
                btn.style.background = '#4CAF50';
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.style.background = '#FF9800';
                }, 2000);
            }).catch(err => {
                console.error('Erreur de copie:', err);
                alert('Lien √©l√®ve:\n' + studentUrl);
            });
        }
        
        // Ouvrir le modal de suppression
        function openDeleteOnlineModal() {
            if (!loadedProfName) {
                alert('‚ùå Aucune sauvegarde charg√©e');
                return;
            }
            document.getElementById('delete-online-modal').classList.add('active');
            document.getElementById('delete-password').value = '';
            document.getElementById('delete-message').innerHTML = '';
        }
        
        // Fermer le modal de suppression
        function closeDeleteOnlineModal() {
            document.getElementById('delete-online-modal').classList.remove('active');
        }
        
        // Confirmer la suppression
        async function confirmDeleteOnline() {
            const password = document.getElementById('delete-password').value;
            const messageDiv = document.getElementById('delete-message');
            
            if (!password) {
                messageDiv.innerHTML = '<div class="error-message">‚ö†Ô∏è Veuillez entrer votre code de s√©curit√©</div>';
                return;
            }
            
            if (!loadedProfName) {
                messageDiv.innerHTML = '<div class="error-message">‚ùå Erreur : aucun nom de professeur</div>';
                return;
            }
            
            // Confirmation finale
            const confirmText = `‚ö†Ô∏è ATTENTION ‚ö†Ô∏è\n\nVous √™tes sur le point de supprimer D√âFINITIVEMENT tous les niveaux de "${loadedProfName}".\n\nCette action est IRR√âVERSIBLE.\n\nVoulez-vous vraiment continuer ?`;
            if (!confirm(confirmText)) {
                return;
            }
            
            messageDiv.innerHTML = '<div class="info-box">‚è≥ Suppression en cours...</div>';
            
            try {
                const formData = new FormData();
                formData.append('action', 'delete');
                formData.append('profName', loadedProfName);
                formData.append('password', password);
                
                const response = await fetch('api.php', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.success) {
                    messageDiv.innerHTML = '<div class="info-box" style="background: #E8F5E9; border-color: #4CAF50; color: #2E7D32;">‚úÖ Sauvegarde supprim√©e avec succ√®s !</div>';
                    
                    // R√©initialiser les variables
                    loadedProfName = null;
                    hasModifications = false;
                    updateCopyLinkButton();
                    
                    setTimeout(() => {
                        closeDeleteOnlineModal();
                        showResult('‚úÖ Votre sauvegarde en ligne a √©t√© supprim√©e', true);
                    }, 2000);
                } else {
                    messageDiv.innerHTML = '<div class="error-message">‚ùå ' + result.message + '</div>';
                }
            } catch (error) {
                console.error('Erreur:', error);
                messageDiv.innerHTML = '<div class="error-message">‚ùå Erreur de connexion au serveur</div>';
            }
        }
        
        // Marquer qu'il y a eu des modifications (√† appeler quand on modifie un niveau)
        function markAsModified() {
            hasModifications = true;
            updateCopyLinkButton();
        }

        // Confirmer le chargement en ligne (ancienne m√©thode avec mot de passe - gard√©e pour compatibilit√©)
        async function confirmLoadOnline() {
            // Cette fonction n'est plus utilis√©e mais gard√©e pour √©viter les erreurs
            console.log('confirmLoadOnline deprecated');
        }

        // Confirmer la sauvegarde en ligne
        async function confirmSaveOnline() {
            const profName = document.getElementById('save-prof-name').value.trim();
            let password = document.getElementById('save-password').value; // Chang√© en let pour pouvoir r√©assigner
            const captchaUserAnswer = document.getElementById('captcha-answer').value;
            const messageDiv = document.getElementById('save-message');

            // Validations
            if (!profName) {
                messageDiv.innerHTML = '<div class="error-message">‚ö†Ô∏è Veuillez entrer votre nom</div>';
                return;
            }

            if (!/^[a-zA-Z0-9_-]+$/.test(profName)) {
                messageDiv.innerHTML = '<div class="error-message">‚ö†Ô∏è Le nom ne peut contenir que des lettres, chiffres, tirets et underscores</div>';
                return;
            }
            
            // V√©rification de profanit√©
            if (!PROFANITY_FILTER.isClean(profName)) {
                const errorMsg = PROFANITY_FILTER.getErrorMessage(profName);
                messageDiv.innerHTML = `<div class="error-message">‚ö†Ô∏è ${errorMsg}</div>`;
                return;
            }

            if (parseInt(captchaUserAnswer) !== captchaAnswer) {
                messageDiv.innerHTML = '<div class="error-message">‚ö†Ô∏è Captcha incorrect</div>';
                generateCaptcha();
                return;
            }

            // V√©rifier qu'il y a des niveaux √† sauvegarder
            const hasLevels = Object.values(cursusData).some(cursus => {
                if (Array.isArray(cursus)) {
                    return cursus.length > 0;
                } else if (cursus.levels) {
                    return Object.keys(cursus.levels).length > 0;
                }
                return false;
            });
            if (!hasLevels) {
                messageDiv.innerHTML = '<div class="error-message">‚ö†Ô∏è Vous devez cr√©er au moins un niveau avant de sauvegarder</div>';
                return;
            }

            // V√©rifier si un fichier existe d√©j√† (pour demander le mot de passe)
            try {
                const checkResponse = await fetch(`api.php?action=check&profName=${profName}`);
                const checkResult = await checkResponse.json();
                
                if (checkResult.exists) {
                    // Un fichier existe : demander le mot de passe pour v√©rifier
                    const existingPassword = prompt('‚ö†Ô∏è Ce nom est d√©j√† utilis√© !\n\nPour √©craser cette sauvegarde, entrez le code de s√©curit√© associ√© √† ce nom :\n\n(Annuler pour revenir)');
                    
                    if (!existingPassword) {
                        // L'utilisateur a annul√©
                        messageDiv.innerHTML = '<div class="error-message">‚ö†Ô∏è Sauvegarde annul√©e</div>';
                        return;
                    }
                    
                    // V√©rifier que le mot de passe correspond
                    const verifyFormData = new FormData();
                    verifyFormData.append('action', 'verify_password');
                    verifyFormData.append('profName', profName);
                    verifyFormData.append('password', existingPassword);
                    
                    const verifyResponse = await fetch('api.php', {
                        method: 'POST',
                        body: verifyFormData
                    });
                    
                    const verifyResult = await verifyResponse.json();
                    
                    if (!verifyResult.success) {
                        messageDiv.innerHTML = '<div class="error-message">‚ùå Code de s√©curit√© incorrect. Impossible d\'√©craser cette sauvegarde.</div>';
                        return;
                    }
                    
                    // Le mot de passe est correct, on peut continuer
                    // Utiliser le mot de passe existant pour la sauvegarde
                    password = existingPassword;
                }
            } catch (error) {
                // Si erreur de v√©rification, continuer quand m√™me
                console.log('Impossible de v√©rifier l\'existence du fichier');
            }

            // Afficher un message de chargement
            messageDiv.innerHTML = '<div class="info-box">‚è≥ Sauvegarde en cours...</div>';

            try {
                // Pr√©parer les donn√©es
                const formData = new FormData();
                formData.append('action', 'save');
                formData.append('profName', profName);
                formData.append('password', password);
                formData.append('captchaAnswer', captchaUserAnswer);
                formData.append('captchaExpected', captchaAnswer);
                formData.append('cursusData', JSON.stringify(cursusData));

                // Envoyer au serveur
                const response = await fetch('api.php', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    messageDiv.innerHTML = '<div class="info-box" style="background: #E8F5E9; border-color: #4CAF50; color: #2E7D32;">‚úÖ ' + result.message + '</div>';
                    const urlDiv = document.getElementById('success-url');
                    urlDiv.style.display = 'block';
                    urlDiv.innerHTML = `
                        <strong>üéâ Votre page est pr√™te !</strong><br><br>
                        Partagez ce lien avec vos √©l√®ves :<br>
                        <a href="https://${result.url}" target="_blank">https://${result.url}</a>
                        <br><br>
                        <small>üí° Vous pouvez modifier vos niveaux √† tout moment en rechargeant cette page et en cliquant sur "Charger les niveaux"</small>
                    `;
                    
                    // Activer le bouton "Copier lien √©l√®ve"
                    loadedProfName = result.profName;
                    hasModifications = false;
                    updateCopyLinkButton();
                    
                    // Remplacer les boutons par un seul bouton "Fermer"
                    const buttonsDiv = document.getElementById('save-modal-buttons');
                    buttonsDiv.innerHTML = '<button class="btn-confirm" onclick="closeSaveOnlineModal()" style="width: 100%;">‚úÖ Fermer</button>';
                } else {
                    messageDiv.innerHTML = '<div class="error-message">‚ùå ' + result.message + '</div>';
                    generateCaptcha(); // Reg√©n√©rer le captcha en cas d'erreur
                }
            } catch (error) {
                console.error('Erreur:', error);
                messageDiv.innerHTML = '<div class="error-message">‚ùå Erreur de connexion au serveur</div>';
                generateCaptcha();
            }
        }

        // Confirmer le chargement en ligne
        async function confirmLoadOnline() {
            const profName = document.getElementById('load-prof-name').value.trim();
            const password = document.getElementById('load-password').value;
            const messageDiv = document.getElementById('load-message');

            // Validations
            if (!profName || !password) {
                messageDiv.innerHTML = '<div class="error-message">‚ö†Ô∏è Veuillez remplir tous les champs</div>';
                return;
            }

            // Afficher un message de chargement
            messageDiv.innerHTML = '<div class="info-box">‚è≥ Chargement en cours...</div>';

            try {
                // Pr√©parer les donn√©es
                const formData = new FormData();
                formData.append('action', 'load');
                formData.append('profName', profName);
                formData.append('password', password);

                // Envoyer au serveur
                const response = await fetch('api.php', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    // Charger les donn√©es dans l'application
                    cursusData = result.cursusData;
                    saveToStorage(); // Sauvegarder localement aussi
                    loadTeacherLevels(); // Recharger l'interface
                    
                    messageDiv.innerHTML = '<div class="info-box" style="background: #E8F5E9; border-color: #4CAF50; color: #2E7D32;">‚úÖ Niveaux charg√©s avec succ√®s !</div>';
                    
                    setTimeout(() => {
                        closeLoadOnlineModal();
                        showResult('‚úÖ Vos niveaux ont √©t√© charg√©s !', true);
                    }, 1500);
                } else {
                    messageDiv.innerHTML = '<div class="error-message">‚ùå ' + result.message + '</div>';
                }
            } catch (error) {
                console.error('Erreur:', error);
                messageDiv.innerHTML = '<div class="error-message">‚ùå Erreur de connexion au serveur</div>';
            }
        }

        // Initialiser l'application
        window.onload = function() {
            init();
            checkProfParameter();
        };
        
        // V√©rifier si un param√®tre ?prof= est pr√©sent dans l'URL
        function checkProfParameter() {
            const urlParams = new URLSearchParams(window.location.search);
            const profName = urlParams.get('prof');
            
            console.log('üîç checkProfParameter: profName =', profName);
            
            if (profName) {
                console.log('‚úì Param√®tre prof d√©tect√©, activation mode chargement √©l√®ve');
                // CRITIQUE : D√©finir le flag IMM√âDIATEMENT avant tout appel async
                window.isStudentLoadMode = true;
                console.log('‚úì window.isStudentLoadMode =', window.isStudentLoadMode);
                
                // Mode √©l√®ve forc√© avec chargement automatique des niveaux du prof
                loadProfLevelsForStudent(profName);
            } else {
                console.log('‚ùå Pas de param√®tre prof dans l\'URL');
            }
        }
        
        // Charger les niveaux d'un prof pour un √©l√®ve
        async function loadProfLevelsForStudent(profName) {
            try {
                const response = await fetch(`api.php?action=load_public&profName=${profName}`);
                const result = await response.json();
                
                if (result.success) {
                    console.log('=== Mode √©l√®ve activ√© ===');
                    
                    // Charger les donn√©es du prof
                    cursusData = result.cursusData;
                    
                    // Forcer le mode √©l√®ve
                    currentMode = 'student';
                    
                    // Masquer les boutons prof par ID (pas par index pour √©viter de masquer les boutons √©l√®ve)
                    document.getElementById('save-online-btn').style.display = 'none';
                    document.getElementById('load-levels-btn').style.display = 'none';
                    
                    // Masquer les boutons Mode √âl√®ve et Mode Professeur
                    const allModeBtns = document.querySelectorAll('.mode-btn');
                    allModeBtns.forEach(btn => {
                        if (btn.textContent.includes('Mode √âl√®ve') || btn.textContent.includes('Mode Professeur')) {
                            btn.style.setProperty('display', 'none', 'important');
                        }
                    });
                    
                    // Masquer sp√©cifiquement les boutons mobiles par ID avec !important
                    const mobileStudentBtn = document.getElementById('mobile-student-mode-btn');
                    const mobileTeacherBtn = document.getElementById('mobile-teacher-mode-btn');
                    if (mobileStudentBtn) mobileStudentBtn.style.setProperty('display', 'none', 'important');
                    if (mobileTeacherBtn) mobileTeacherBtn.style.setProperty('display', 'none', 'important');
                    
                    // MOBILE : Afficher le DIV √©l√®ve avec les bons boutons
                    const mobileStudentButtonsDiv = document.getElementById('mobile-student-buttons');
                    if (mobileStudentButtonsDiv) mobileStudentButtonsDiv.style.setProperty('display', 'block', 'important');
                    
                    // MOBILE : Cacher le DIV professeur
                    const mobileTeacherButtonsDiv = document.getElementById('mobile-teacher-buttons');
                    if (mobileTeacherButtonsDiv) mobileTeacherButtonsDiv.style.setProperty('display', 'none', 'important');

                    
                    // D√©finir un flag global pour indiquer qu'on est en mode chargement √©l√®ve
                    window.isStudentLoadMode = true;
                    
                    // Afficher les boutons de sauvegarde √©l√®ve
                    const studentButtons = document.getElementById('student-save-buttons');
                    console.log('Element student-save-buttons:', studentButtons);
                    if (studentButtons) {
                        studentButtons.style.display = 'block';
                        console.log('Boutons √©l√®ve affich√©s');
                    } else {
                        console.error('Element student-save-buttons non trouv√© !');
                    }
                    
                    // Afficher un message discret indiquant le prof
                    const headerSubtitle = document.getElementById('header-subtitle');
                    headerSubtitle.textContent = `Niveaux de ${profName}`;
                    headerSubtitle.style.display = 'block';
                    headerSubtitle.style.opacity = '0.7';
                    headerSubtitle.style.fontSize = '12px';
                    
                    // Charger les niveaux
                    loadCursusLevels();
                    
                    // Mettre √† jour la date d'acc√®s c√¥t√© serveur
                    fetch(`api.php?action=access&prof=${profName}`);
                } else {
                    alert('‚ùå Impossible de charger les niveaux de ce professeur.');
                }
            } catch (error) {
                console.error('Erreur lors du chargement des niveaux:', error);
                alert('‚ùå Erreur de connexion au serveur.');
            }
        }
        
        // ============================================
        // SYST√àME DE DRAG TACTILE MOBILE
        // ============================================
        
        let touchDragState = {
            active: false,
            ghost: null,
            sourceBlock: null,
            placeholder: null,
            lastTargetBlock: null,
            lastPosition: null,
            lastMoveTime: 0,  // Pour throttling
            moveThreshold: 50, // ms entre chaque repositionnement
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0
        };
        
        function initMobileTouchDrag() {
            const blocks = document.querySelectorAll('#mobile-blocks-list .block, #mobile-blocks-list .value-block, #mobile-blocks-list .operator-block');
            
            blocks.forEach(block => {
                block.addEventListener('touchstart', handleTouchStart, { passive: false });
            });
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            
            const touch = e.touches[0];
            touchDragState.startX = touch.clientX;
            touchDragState.startY = touch.clientY;
            touchDragState.sourceBlock = e.currentTarget;
            touchDragState.active = true;
            
            // Cr√©er le bloc fant√¥me
            createGhostBlock(e.currentTarget, touch.clientX, touch.clientY);
            
            // Fermer le menu mobile
            setTimeout(() => closeMobileMenu(), 50);
            
            // Ajouter les listeners de mouvement
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            console.log('Touch drag d√©marr√©');
        }
        
        function createGhostBlock(sourceBlock, x, y) {
            // Cr√©er un clone visuel
            const ghost = sourceBlock.cloneNode(true);
            ghost.id = 'touch-drag-ghost';
            ghost.style.cssText = `
                position: fixed;
                left: ${x - 50}px;
                top: ${y - 25}px;
                z-index: 9999;
                opacity: 0.8;
                pointer-events: none;
                transform: rotate(3deg);
                box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            `;
            
            document.body.appendChild(ghost);
            touchDragState.ghost = ghost;
        }
        
        function handleTouchMove(e) {
            if (!touchDragState.active) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            touchDragState.currentX = touch.clientX;
            touchDragState.currentY = touch.clientY;
            
            // D√©placer le bloc fant√¥me (toujours fluide)
            if (touchDragState.ghost) {
                touchDragState.ghost.style.left = (touch.clientX - 50) + 'px';
                touchDragState.ghost.style.top = (touch.clientY - 25) + 'px';
            }
            
            // THROTTLING : ne repositionner le placeholder que toutes les 50ms
            const now = Date.now();
            if (now - touchDragState.lastMoveTime < touchDragState.moveThreshold) {
                return; // Trop t√¥t, on attend
            }
            touchDragState.lastMoveTime = now;
            
            // Cr√©er le placeholder s'il n'existe pas
            if (!touchDragState.placeholder) {
                touchDragState.placeholder = document.createElement('div');
                touchDragState.placeholder.id = 'menu-drag-placeholder';
                touchDragState.placeholder.style.cssText = `
                    height: 60px;
                    border: 2px dashed #4CAF50;
                    border-radius: 6px;
                    margin-bottom: 10px;
                    background: rgba(76, 175, 80, 0.1);
                `;
            }
            
            // Trouver l'√©l√©ment sous le doigt (en cachant le fant√¥me)
            touchDragState.ghost.style.display = 'none';
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            touchDragState.ghost.style.display = 'block';
            
            if (!elementBelow) return;
            
            // R√©cup√©rer le type de bloc source pour v√©rifier les restrictions
            const sourceBlockType = touchDragState.sourceBlock.dataset.type;
            
            // 1. V√©rifier si on survole un value-slot
            const valueSlot = elementBelow.closest('.value-slot');
            if (valueSlot && (sourceBlockType === 'var-value' || sourceBlockType === 'operator')) {
                // Pas de placeholder pour value-slots, juste un changement visuel
                valueSlot.style.background = 'rgba(76, 175, 80, 0.2)';
                // Enlever le placeholder s'il √©tait affich√© ailleurs
                if (touchDragState.placeholder.parentNode) {
                    touchDragState.placeholder.remove();
                }
                // Nettoyer les autres value-slots
                document.querySelectorAll('.value-slot').forEach(slot => {
                    if (slot !== valueSlot) {
                        slot.style.background = '';
                    }
                });
                return;
            } else {
                // Nettoyer tous les value-slots
                document.querySelectorAll('.value-slot').forEach(slot => {
                    slot.style.background = '';
                });
            }
            
            // Les blocs var-value et operator ne peuvent pas aller ailleurs
            if (sourceBlockType === 'var-value' || sourceBlockType === 'operator') {
                if (touchDragState.placeholder.parentNode) {
                    touchDragState.placeholder.remove();
                }
                return;
            }
            
            // 2. V√©rifier si on survole une zone nested-blocks
            const nestedBlocks = elementBelow.closest('.nested-blocks');
            if (nestedBlocks) {
                const blocksInNested = Array.from(nestedBlocks.querySelectorAll(':scope > .program-block'));
                const targetBlockInNested = blocksInNested.find(block => {
                    const rect = block.getBoundingClientRect();
                    return touch.clientY >= rect.top && touch.clientY <= rect.bottom;
                });
                
                if (targetBlockInNested) {
                    const rect = targetBlockInNested.getBoundingClientRect();
                    const middle = rect.top + rect.height / 2;
                    
                    let newPosition;
                    
                    // Si c'est un NOUVEAU bloc, d√©cider imm√©diatement
                    if (targetBlockInNested !== touchDragState.lastTargetBlock) {
                        newPosition = touch.clientY < middle ? 'before' : 'after';
                    } else {
                        // M√™me bloc : zone morte pour stabilit√©
                        const deadZone = rect.height * 0.2;
                        const upperThreshold = middle - deadZone;
                        const lowerThreshold = middle + deadZone;
                        
                        if (touch.clientY < upperThreshold) {
                            newPosition = 'before';
                        } else if (touch.clientY > lowerThreshold) {
                            newPosition = 'after';
                        } else {
                            newPosition = touchDragState.lastPosition;
                        }
                    }
                    
                    // Ne d√©placer que si changement
                    if (targetBlockInNested !== touchDragState.lastTargetBlock || newPosition !== touchDragState.lastPosition) {
                        let targetSibling;
                        if (newPosition === 'before') {
                            targetSibling = targetBlockInNested;
                        } else {
                            targetSibling = targetBlockInNested.nextSibling;
                        }
                        
                        // V√©rifier si le placeholder n'est pas d√©j√† au bon endroit
                        if (touchDragState.placeholder.nextSibling !== targetSibling) {
                            nestedBlocks.insertBefore(touchDragState.placeholder, targetSibling);
                        }
                        
                        touchDragState.lastTargetBlock = targetBlockInNested;
                        touchDragState.lastPosition = newPosition;
                    }
                } else {
                    // V√©rifier si le placeholder n'est pas d√©j√† √† la fin
                    if (touchDragState.placeholder.parentNode !== nestedBlocks || touchDragState.placeholder.nextSibling !== null) {
                        nestedBlocks.appendChild(touchDragState.placeholder);
                    }
                    touchDragState.lastTargetBlock = null;
                    touchDragState.lastPosition = null;
                }
                return;
            }
            
            // 3. V√©rifier si on survole le programme principal
            const programBlocks = document.getElementById('program-blocks');
            const programArea = elementBelow.closest('.program-area');
            
            if ((programBlocks && (elementBelow === programBlocks || programBlocks.contains(elementBelow))) || programArea) {
                // Si on survole la zone program-area (titre "Mon Programme") ou le conteneur vide
                if (programArea && !programBlocks.contains(elementBelow) && elementBelow !== programBlocks) {
                    // On est sur le titre ou la zone autour, pas sur un bloc
                    // Ajouter au D√âBUT du programme
                    if (programBlocks.children.length > 0) {
                        // Il y a d√©j√† des blocs, ins√©rer au d√©but
                        const firstBlock = programBlocks.firstElementChild;
                        if (touchDragState.placeholder.nextSibling !== firstBlock || touchDragState.placeholder.parentNode !== programBlocks) {
                            programBlocks.insertBefore(touchDragState.placeholder, firstBlock);
                            console.log('üìå Placeholder au d√©but (zone titre)');
                        }
                    } else {
                        // Programme vide
                        if (touchDragState.placeholder.parentNode !== programBlocks || touchDragState.placeholder.nextSibling !== null) {
                            programBlocks.appendChild(touchDragState.placeholder);
                            console.log('üì¶ Ajout√© √† la fin (vide)');
                        }
                    }
                    touchDragState.lastTargetBlock = null;
                    touchDragState.lastPosition = 'beginning';
                    return;
                }
                
                // Trouver le bloc le plus proche MAIS ignorer le placeholder
                let targetBlock = elementBelow.closest('.program-block');
                
                // Si on a cliqu√© sur le placeholder lui-m√™me, NE RIEN FAIRE
                if (elementBelow === touchDragState.placeholder || touchDragState.placeholder.contains(elementBelow)) {
                    console.log('üî¥ Ignor√©: elementBelow est le placeholder - on garde la position actuelle');
                    return; // SORTIR sans rien changer !
                }
                
                if (targetBlock) {
                    const rect = targetBlock.getBoundingClientRect();
                    const middle = rect.top + rect.height / 2;
                    
                    console.log('üìç Bloc d√©tect√©:', {
                        blockTop: rect.top,
                        blockBottom: rect.bottom,
                        middle: middle,
                        touchY: touch.clientY,
                        diffFromMiddle: touch.clientY - middle,
                        isNewBlock: targetBlock !== touchDragState.lastTargetBlock,
                        lastPosition: touchDragState.lastPosition
                    });
                    
                    let newPosition;
                    
                    // Si c'est un NOUVEAU bloc (changement de bloc cible), d√©cider imm√©diatement sans zone morte
                    if (targetBlock !== touchDragState.lastTargetBlock) {
                        newPosition = touch.clientY < middle ? 'before' : 'after';
                        console.log('üÜï Nouveau bloc ‚Üí position:', newPosition);
                    } else {
                        // M√™me bloc : utiliser la zone morte pour √©viter les oscillations
                        const deadZone = rect.height * 0.25; // 25% encore plus large
                        const upperThreshold = middle - deadZone;
                        const lowerThreshold = middle + deadZone;
                        
                        if (touch.clientY < upperThreshold) {
                            newPosition = 'before';
                            console.log('‚¨ÜÔ∏è Au-dessus zone morte ‚Üí before');
                        } else if (touch.clientY > lowerThreshold) {
                            newPosition = 'after';
                            console.log('‚¨áÔ∏è En-dessous zone morte ‚Üí after');
                        } else {
                            // Dans la zone morte, garder la position actuelle
                            newPosition = touchDragState.lastPosition;
                            console.log('üü° Zone morte ‚Üí garde:', newPosition);
                        }
                    }
                    
                    // Ne d√©placer le placeholder que si la position change VRAIMENT
                    if (newPosition && (targetBlock !== touchDragState.lastTargetBlock || newPosition !== touchDragState.lastPosition)) {
                        let targetSibling;
                        if (newPosition === 'before') {
                            targetSibling = targetBlock;
                        } else {
                            targetSibling = targetBlock.nextSibling;
                        }
                        
                        // V√©rifier si le placeholder n'est pas d√©j√† au bon endroit
                        const needsMove = touchDragState.placeholder.nextSibling !== targetSibling || 
                                         touchDragState.placeholder.parentNode !== targetBlock.parentNode;
                        
                        console.log('üîÑ Changement:', {
                            needsMove: needsMove,
                            oldPosition: touchDragState.lastPosition,
                            newPosition: newPosition
                        });
                        
                        if (needsMove) {
                            targetBlock.parentNode.insertBefore(touchDragState.placeholder, targetSibling);
                            console.log('‚úÖ Placeholder d√©plac√©');
                        } else {
                            console.log('‚è≠Ô∏è D√©j√† au bon endroit');
                        }
                        
                        touchDragState.lastTargetBlock = targetBlock;
                        touchDragState.lastPosition = newPosition;
                    } else {
                        console.log('‚è∏Ô∏è Pas de changement n√©cessaire');
                    }
                } else {
                    // Zone vide du programme, ajouter √† la fin
                    // V√©rifier si pas d√©j√† √† la fin
                    if (touchDragState.placeholder.parentNode !== programBlocks || touchDragState.placeholder.nextSibling !== null) {
                        programBlocks.appendChild(touchDragState.placeholder);
                        console.log('üì¶ Ajout√© √† la fin');
                    }
                    touchDragState.lastTargetBlock = null;
                    touchDragState.lastPosition = null;
                }
                return;
            }
            
            // Si on n'est sur aucune zone valide, retirer le placeholder
            if (touchDragState.placeholder.parentNode) {
                touchDragState.placeholder.remove();
            }
        }
        
        function handleTouchEnd(e) {
            if (!touchDragState.active) return;
            e.preventDefault();
            
            const touch = e.changedTouches[0];
            const dropX = touch.clientX;
            const dropY = touch.clientY;
            
            // Trouver l'√©l√©ment sous le doigt
            if (touchDragState.ghost) {
                touchDragState.ghost.style.display = 'none';
            }
            
            const elementBelow = document.elementFromPoint(dropX, dropY);
            console.log('Element sous le doigt:', elementBelow?.className);
            
            if (!elementBelow) {
                cleanupTouchDrag();
                return;
            }
            
            // R√©cup√©rer le type de bloc source
            const sourceBlockType = touchDragState.sourceBlock.dataset.type;
            console.log('Type de bloc:', sourceBlockType);
            
            // 1. V√©rifier si on d√©pose dans un VALUE-SLOT
            const valueSlot = elementBelow.closest('.value-slot');
            if (valueSlot) {
                console.log('Drop dans value-slot d√©tect√©');
                // Seuls les blocs var-value et operator peuvent aller dans value-slot
                if (sourceBlockType === 'var-value' || sourceBlockType === 'operator') {
                    handleDropInValueSlot(touchDragState.sourceBlock, valueSlot);
                } else {
                    console.log('‚ùå Ce type de bloc ne peut pas aller dans un value-slot');
                }
                cleanupTouchDrag();
                return;
            }
            
            // 2. V√©rifier si on d√©pose dans un NESTED-BLOCKS (bloc r√©p√©ter)
            const nestedBlocks = elementBelow.closest('.nested-blocks');
            if (nestedBlocks) {
                console.log('Drop dans nested-blocks d√©tect√©');
                // Les blocs var-value et operator NE PEUVENT PAS aller dans nested-blocks
                if (sourceBlockType === 'var-value' || sourceBlockType === 'operator') {
                    console.log('‚ùå Les blocs variables/op√©rateurs ne peuvent pas aller dans nested-blocks');
                } else {
                    addBlockToProgramFromTouch(touchDragState.sourceBlock, nestedBlocks, elementBelow, dropY);
                }
                cleanupTouchDrag();
                return;
            }
            
            // 3. V√©rifier si on d√©pose dans la ZONE PROGRAMME PRINCIPALE ou program-area
            const programBlocks = document.getElementById('program-blocks');
            const programArea = elementBelow.closest('.program-area');
            
            if ((programBlocks && (elementBelow === programBlocks || programBlocks.contains(elementBelow))) || programArea) {
                console.log('Drop dans programme principal ou zone titre d√©tect√©');
                // Les blocs var-value et operator NE PEUVENT PAS aller dans le programme principal
                if (sourceBlockType === 'var-value' || sourceBlockType === 'operator') {
                    console.log('‚ùå Les blocs variables/op√©rateurs ne peuvent pas aller dans le programme principal');
                } else {
                    addBlockToProgramFromTouch(touchDragState.sourceBlock, programBlocks, elementBelow, dropY);
                }
            }
            
            // Nettoyer
            cleanupTouchDrag();
            console.log('Touch drag termin√©');
        }
        
        // Nouvelle fonction pour g√©rer le drop dans les value-slots
        function handleDropInValueSlot(sourceBlock, valueSlot) {
            console.log('Traitement drop dans value-slot');
            
            // R√©cup√©rer les donn√©es du bloc
            const blockData = {
                type: sourceBlock.dataset.type,
                html: sourceBlock.outerHTML,
                selectValues: []
            };
            
            // R√©cup√©rer les valeurs des selects
            const selects = sourceBlock.querySelectorAll('select');
            selects.forEach(select => {
                blockData.selectValues.push(select.value);
            });
            
            // Sauvegarder l'input original pour pouvoir le restaurer
            const originalInput = valueSlot.querySelector('input');
            let inputHTML = '<input type="text" inputmode="numeric" pattern="[0-9]*" value="0" onclick="event.stopPropagation()">';
            
            if (originalInput) {
                const inputType = originalInput.type;
                const inputValue = originalInput.value;
                const placeholder = originalInput.placeholder;
                
                if (placeholder) {
                    inputHTML = `<input type="text" placeholder="${placeholder}" onclick="event.stopPropagation()">`;
                } else {
                    inputHTML = `<input type="text" inputmode="numeric" pattern="[0-9]*" value="${inputValue || '0'}" onclick="event.stopPropagation()">`;
                }
            }
            
            // Remplacer le contenu du value-slot
            valueSlot.innerHTML = blockData.html;
            valueSlot.classList.add('filled');
            
            // Modifier le bloc ins√©r√©
            const block = valueSlot.querySelector('.block, .value-block, .operator-block');
            if (block) {
                block.removeAttribute('draggable');
                block.removeAttribute('ondragstart');
                block.classList.add('inline-block');
                block.style.display = 'inline-flex';
                block.style.margin = '0';
                
                // Convertir les inputs en text pour mobile
                if (window.innerWidth <= 768) {
                    const inputs = block.querySelectorAll('input');
                    inputs.forEach(input => {
                        if (input.type === 'number') {
                            input.type = 'text';
                            input.inputMode = 'numeric';
                            input.pattern = '[0-9]*';
                        }
                    });
                }
                
                // Ajouter bouton de suppression
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '√ó';
                removeBtn.style.fontSize = '16px';
                removeBtn.style.padding = '4px 8px';
                removeBtn.onclick = function(e) {
                    e.stopPropagation();
                    valueSlot.innerHTML = inputHTML;
                    valueSlot.classList.remove('filled');
                };
                block.appendChild(removeBtn);
                
                // Si c'est un bloc variable, mettre √† jour le select
                if (blockData.type === 'var-value') {
                    const select = block.querySelector('.var-select');
                    if (select) {
                        const selectedValue = blockData.selectValues && blockData.selectValues.length > 0 ? blockData.selectValues[0] : '';
                        
                        select.innerHTML = '<option value="">choisir...</option>';
                        createdVariables.forEach(varName => {
                            const option = document.createElement('option');
                            option.value = varName;
                            option.textContent = varName;
                            select.appendChild(option);
                        });
                        
                        if (selectedValue && createdVariables.includes(selectedValue)) {
                            select.value = selectedValue;
                        }
                    }
                }
                
                // Si c'est un op√©rateur, g√©rer les value-slots internes
                if (blockData.type === 'operator') {
                    const innerValueSlots = block.querySelectorAll('.value-slot');
                    innerValueSlots.forEach(slot => {
                        if (blockData.selectValues) {
                            const innerSelects = slot.querySelectorAll('select');
                            innerSelects.forEach((select, index) => {
                                if (blockData.selectValues[index]) {
                                    select.value = blockData.selectValues[index];
                                }
                            });
                        }
                    });
                }
                
                // IMPORTANT : Appliquer la validation sur le bloc ins√©r√©
                setupNumericInputValidation(block);
                
                // √âGALEMENT : R√©initialiser la validation sur le bloc parent
                const parentProgramBlock = valueSlot.closest('.program-block');
                if (parentProgramBlock) {
                    setupNumericInputValidation(parentProgramBlock);
                }
            }
            
            console.log('‚úì Bloc ins√©r√© dans value-slot');
        }
        
        function addBlockToProgramFromTouch(sourceBlock, container, targetElement, dropY) {
            // R√©cup√©rer les donn√©es du bloc comme le fait drag()
            const blockData = {
                type: sourceBlock.dataset.type,
                html: sourceBlock.outerHTML,
                selectValues: []
            };
            
            // R√©cup√©rer les valeurs des select s'il y en a
            const selects = sourceBlock.querySelectorAll('select');
            selects.forEach(select => {
                blockData.selectValues.push(select.value);
            });
            
            // Utiliser la fonction NATIVE addBlockToProgram
            addBlockToProgram(blockData);
            
            // Le bloc est ajout√© √† #program-blocks par d√©faut
            const programBlocks = document.getElementById('program-blocks');
            const newBlock = programBlocks.lastElementChild;
            
            if (!newBlock) {
                console.error('Nouveau bloc non cr√©√©');
                return;
            }
            
            // Initialiser le drag tactile sur ce nouveau bloc
            if (window.innerWidth <= 768) {
                newBlock.addEventListener('touchstart', handleProgramBlockTouchStart, { passive: false });
                
                // Augmenter la taille pour mobile SEULEMENT sur le bloc interne
                const innerBlock = newBlock.querySelector('.block');
                if (innerBlock) {
                    innerBlock.style.minHeight = '56px';
                    innerBlock.style.fontSize = '16px';
                    innerBlock.style.padding = '14px';
                }
                
                // Convertir les input number en text pour mobile
                const numberInputs = newBlock.querySelectorAll('input[type="number"]');
                numberInputs.forEach(input => {
                    input.type = 'text';
                    input.inputMode = 'numeric';
                    input.pattern = '[0-9]*';
                });
                
                // Si c'est un bloc r√©p√©ter, initialiser le drag tactile sur nested-blocks
                const nestedBlocks = newBlock.querySelector('.nested-blocks');
                if (nestedBlocks) {
                    setupNestedBlocksTouchDrag(nestedBlocks);
                }
            }
            
            // D√âPLACER le bloc au bon endroit
            
            // Cas 1 : Drop dans nested-blocks (bloc r√©p√©ter)
            if (container.classList && container.classList.contains('nested-blocks')) {
                console.log('D√©placement vers nested-blocks');
                container.appendChild(newBlock);
                container.classList.remove('empty');
                
                // IMPORTANT : Ajouter le listener tactile sur ce bloc imbriqu√©
                if (window.innerWidth <= 768) {
                    newBlock.addEventListener('touchstart', handleProgramBlockTouchStart, { passive: false });
                    console.log('Listener tactile ajout√© au bloc imbriqu√©');
                }
                
                updateBlockCount();
                console.log('‚úì Bloc ajout√© dans nested-blocks');
                return;
            }
            
            // Cas 2 : Utiliser la position du placeholder s'il existe
            if (touchDragState.placeholder && touchDragState.placeholder.parentNode) {
                console.log('‚úì Utilisation de la position du placeholder');
                const placeholderParent = touchDragState.placeholder.parentNode;
                const placeholderNextSibling = touchDragState.placeholder.nextSibling;
                
                // Ins√©rer le nouveau bloc √† la place du placeholder
                placeholderParent.insertBefore(newBlock, placeholderNextSibling);
                console.log('‚úì Bloc ins√©r√© √† la position du placeholder');
            } else {
                // Cas 3 : Fallback - trouver la position avec dropY
                const targetBlock = targetElement.closest('.program-block');
                
                if (targetBlock && targetBlock !== newBlock && programBlocks.contains(targetBlock)) {
                    // On a trouv√© un bloc cible dans le programme principal
                    const rect = targetBlock.getBoundingClientRect();
                    const midpoint = rect.top + rect.height / 2;
                    
                    if (dropY < midpoint) {
                        // Ins√©rer AVANT le bloc cible
                        programBlocks.insertBefore(newBlock, targetBlock);
                        console.log('‚úì Bloc ins√©r√© AVANT √† Y:', dropY, 'midpoint:', midpoint);
                    } else {
                        // Ins√©rer APR√àS le bloc cible
                        if (targetBlock.nextSibling) {
                            programBlocks.insertBefore(newBlock, targetBlock.nextSibling);
                        }
                        console.log('‚úì Bloc ins√©r√© APR√àS √† Y:', dropY, 'midpoint:', midpoint);
                    }
                } else {
                    // Pas de cible sp√©cifique, reste √† la fin
                    console.log('‚úì Bloc ajout√© √† la fin du programme');
                }
            }
            
            // Mettre √† jour le compteur
            updateBlockCount();
        }
        
        // Nouvelle fonction pour configurer le drag tactile sur nested-blocks
        function setupNestedBlocksTouchDrag(nestedArea) {
            // Rendre la zone tactile r√©active
            nestedArea.addEventListener('touchstart', function(e) {
                // Ne rien faire - on laisse le touchstart du bloc se propager
            }, { passive: true });
            
            console.log('Nested-blocks configur√© pour tactile');
        }
        
        // Cette fonction n'est plus utilis√©e - on utilise addBlockToProgram natif
        function createProgramBlockFromSource_UNUSED(sourceBlock) {
            return null;
        }
        
        function cleanupTouchDrag() {
            // Supprimer le bloc fant√¥me
            if (touchDragState.ghost) {
                touchDragState.ghost.remove();
            }
            
            // Supprimer le placeholder
            if (touchDragState.placeholder) {
                touchDragState.placeholder.remove();
            }
            
            // Nettoyer les backgrounds des value-slots
            document.querySelectorAll('.value-slot').forEach(slot => {
                slot.style.background = '';
            });
            
            // R√©initialiser l'√©tat
            touchDragState.active = false;
            touchDragState.ghost = null;
            touchDragState.sourceBlock = null;
            touchDragState.placeholder = null;
            touchDragState.lastTargetBlock = null;
            touchDragState.lastPosition = null;
            
            // Retirer les listeners
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);
            document.removeEventListener('touchmove', handleProgramBlockTouchMove);
            document.removeEventListener('touchend', handleProgramBlockTouchEnd);
        }
        
        // ============================================
        // DRAG TACTILE POUR R√âORGANISER LES BLOCS DU PROGRAMME
        // ============================================
        
        let programDragState = {
            active: false,
            ghost: null,
            sourceBlock: null,
            placeholder: null,
            startX: 0,
            startY: 0
        };
        
        function handleProgramBlockTouchStart(e) {
            // Ne pas d√©marrer le drag si on touche un bouton, un input ou un SELECT
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
                console.log('Touche sur √©l√©ment interactif, pas de drag');
                return;
            }
            
            e.preventDefault();
            
            // NETTOYAGE PR√âVENTIF : supprimer tout fant√¥me r√©siduel
            document.querySelectorAll('#program-drag-ghost').forEach(g => g.remove());
            document.querySelectorAll('#program-drag-placeholder').forEach(p => p.remove());
            
            const touch = e.touches[0];
            
            // IMPORTANT : Trouver le bloc le PLUS PROCHE du point de touche
            // Pas e.currentTarget qui peut √™tre le parent (bloc r√©p√©ter)
            const clickedBlock = e.target.closest('.program-block');
            
            if (!clickedBlock) {
                console.log('Pas de bloc trouv√©');
                return;
            }
            
            console.log('Bloc d√©tect√©:', clickedBlock.querySelector('.block')?.dataset?.type);
            
            programDragState.startX = touch.clientX;
            programDragState.startY = touch.clientY;
            programDragState.sourceBlock = clickedBlock;  // Le bloc cliqu√©, pas currentTarget
            programDragState.active = true;
            
            // Cr√©er le bloc fant√¥me
            const ghost = programDragState.sourceBlock.cloneNode(true);
            ghost.id = 'program-drag-ghost';
            ghost.style.cssText = `
                position: fixed;
                left: ${touch.clientX - 100}px;
                top: ${touch.clientY - 30}px;
                width: ${programDragState.sourceBlock.offsetWidth}px;
                z-index: 9999;
                opacity: 0.8;
                pointer-events: none;
                transform: rotate(2deg);
                box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            `;
            document.body.appendChild(ghost);
            programDragState.ghost = ghost;
            
            // Cr√©er un placeholder
            const placeholder = document.createElement('div');
            placeholder.id = 'program-drag-placeholder';
            placeholder.style.cssText = `
                height: ${programDragState.sourceBlock.offsetHeight}px;
                border: 2px dashed #999;
                border-radius: 6px;
                margin-bottom: 10px;
                background: rgba(0,0,0,0.05);
            `;
            programDragState.sourceBlock.style.opacity = '0.3';
            programDragState.sourceBlock.parentNode.insertBefore(placeholder, programDragState.sourceBlock);
            programDragState.placeholder = placeholder;
            
            // Ajouter les listeners
            document.addEventListener('touchmove', handleProgramBlockTouchMove, { passive: false });
            document.addEventListener('touchend', handleProgramBlockTouchEnd, { passive: false });
            
            console.log('R√©organisation d√©marr√©e (bloc imbriqu√© support√©)');
        }
        
        function handleProgramBlockTouchMove(e) {
            if (!programDragState.active) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            
            // D√©placer le fant√¥me
            if (programDragState.ghost) {
                programDragState.ghost.style.left = (touch.clientX - 100) + 'px';
                programDragState.ghost.style.top = (touch.clientY - 30) + 'px';
            }
            
            // Trouver l'√©l√©ment sous le doigt
            programDragState.ghost.style.display = 'none';
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            programDragState.ghost.style.display = 'block';
            
            if (!elementBelow) return;
            
            // 1. V√©rifier si on est sur une zone nested-blocks
            const nestedBlocks = elementBelow.closest('.nested-blocks');
            if (nestedBlocks && !nestedBlocks.contains(programDragState.sourceBlock)) {
                // On survole une zone nested-blocks (et le bloc source n'y est pas d√©j√†)
                // Trouver un bloc dans cette zone pour positionner le placeholder
                const blocksInNested = Array.from(nestedBlocks.querySelectorAll(':scope > .program-block'));
                const targetBlockInNested = blocksInNested.find(block => {
                    const rect = block.getBoundingClientRect();
                    return touch.clientY >= rect.top && touch.clientY <= rect.bottom;
                });
                
                if (targetBlockInNested && targetBlockInNested !== programDragState.sourceBlock) {
                    const rect = targetBlockInNested.getBoundingClientRect();
                    const middle = rect.top + rect.height / 2;
                    
                    if (touch.clientY < middle) {
                        nestedBlocks.insertBefore(programDragState.placeholder, targetBlockInNested);
                    } else {
                        nestedBlocks.insertBefore(programDragState.placeholder, targetBlockInNested.nextSibling);
                    }
                } else if (blocksInNested.length === 0) {
                    // Zone vide, ajouter √† la fin
                    nestedBlocks.appendChild(programDragState.placeholder);
                } else {
                    // Ajouter √† la fin de la zone
                    nestedBlocks.appendChild(programDragState.placeholder);
                }
                return;
            }
            
            // 2. Sinon, d√©tecter un bloc dans le programme principal
            const programBlock = elementBelow.closest('.program-block');
            if (programBlock && programBlock !== programDragState.sourceBlock) {
                // D√©terminer si on ins√®re avant ou apr√®s
                const rect = programBlock.getBoundingClientRect();
                const middle = rect.top + rect.height / 2;
                
                if (touch.clientY < middle) {
                    // Ins√©rer avant
                    programBlock.parentNode.insertBefore(programDragState.placeholder, programBlock);
                } else {
                    // Ins√©rer apr√®s
                    if (programBlock.nextSibling) {
                        programBlock.parentNode.insertBefore(programDragState.placeholder, programBlock.nextSibling);
                    } else {
                        programBlock.parentNode.appendChild(programDragState.placeholder);
                    }
                }
            }
        }
        
        function handleProgramBlockTouchEnd(e) {
            if (!programDragState.active) return;
            e.preventDefault();
            
            // Sauvegarder l'ancien parent pour v√©rifier s'il devient vide
            const oldParent = programDragState.sourceBlock ? programDragState.sourceBlock.parentNode : null;
            
            // Replacer le bloc √† la position du placeholder
            if (programDragState.placeholder && programDragState.sourceBlock) {
                programDragState.placeholder.parentNode.insertBefore(
                    programDragState.sourceBlock,
                    programDragState.placeholder
                );
                programDragState.sourceBlock.style.opacity = '1';
                
                // Si le nouveau parent est un nested-blocks, le marquer comme non-vide
                const newParent = programDragState.sourceBlock.parentNode;
                if (newParent && newParent.classList.contains('nested-blocks')) {
                    newParent.classList.remove('empty');
                }
                
                // Si l'ancien parent est un nested-blocks et devient vide, le marquer
                if (oldParent && oldParent.classList.contains('nested-blocks')) {
                    const remainingBlocks = oldParent.querySelectorAll(':scope > .program-block');
                    if (remainingBlocks.length === 0) {
                        oldParent.classList.add('empty');
                    }
                }
            }
            
            // Nettoyer le fant√¥me
            if (programDragState.ghost) {
                programDragState.ghost.remove();
            }
            if (programDragState.placeholder) {
                programDragState.placeholder.remove();
            }
            
            // NETTOYAGE DE S√âCURIT√â : supprimer TOUS les ghosts possibles
            const allGhosts = document.querySelectorAll('#program-drag-ghost');
            allGhosts.forEach(ghost => ghost.remove());
            
            const allPlaceholders = document.querySelectorAll('#program-drag-placeholder');
            allPlaceholders.forEach(placeholder => placeholder.remove());
            
            // Restaurer l'opacit√© de TOUS les blocs au cas o√π
            document.querySelectorAll('.program-block[style*="opacity"]').forEach(block => {
                if (block.style.opacity === '0.3') {
                    block.style.opacity = '1';
                }
            });
            
            programDragState.active = false;
            programDragState.ghost = null;
            programDragState.sourceBlock = null;
            programDragState.placeholder = null;
            
            document.removeEventListener('touchmove', handleProgramBlockTouchMove);
            document.removeEventListener('touchend', handleProgramBlockTouchEnd);
            
            console.log('R√©organisation termin√©e et nettoy√©e');
        }
        
        // Initialiser le drag sur les blocs existants (y compris imbriqu√©s)
        function initProgramBlocksDrag() {
            // R√©cup√©rer TOUS les program-block, m√™me ceux dans nested-blocks
            const blocks = document.querySelectorAll('#program-blocks .program-block');
            console.log('Initialisation drag tactile sur', blocks.length, 'blocs');
            blocks.forEach(block => {
                // Supprimer l'ancien listener s'il existe pour √©viter les doublons
                block.removeEventListener('touchstart', handleProgramBlockTouchStart);
                // Ajouter le listener
                block.addEventListener('touchstart', handleProgramBlockTouchStart, { passive: false });
            });
        }
        
        // Appeler au chargement
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                initProgramBlocksDrag();
            }, 1000);
        });
        
        // ============================================
        // FIN DRAG TACTILE PROGRAMME
        // ============================================
        
        // ============================================
        // FIN SYST√àME DE DRAG TACTILE
        // ============================================
        
        // ============================================
        // GESTION DU MENU MOBILE
        // ============================================
        
        function toggleMobileMenu() {
            const panel = document.getElementById('mobile-blocks-panel');
            const overlay = document.getElementById('mobile-overlay');
            const modePanel = document.getElementById('mobile-mode-panel');
            
            // Fermer le menu mode si ouvert
            modePanel.classList.remove('active');
            
            // Toggle le menu blocs
            panel.classList.toggle('active');
            overlay.classList.toggle('active');
            
            // Peupler le panneau avec les blocs disponibles
            if (panel.classList.contains('active')) {
                populateMobileBlocks();
            }
        }
        
        function toggleMobileMode() {
            const panel = document.getElementById('mobile-mode-panel');
            const overlay = document.getElementById('mobile-overlay');
            const blocksPanel = document.getElementById('mobile-blocks-panel');
            
            console.log('üçä toggleMobileMode appel√©');
            
            // Fermer le menu blocs si ouvert
            blocksPanel.classList.remove('active');
            
            // Toggle le menu mode
            panel.classList.toggle('active');
            overlay.classList.toggle('active');
            
            console.log('   Panel active:', panel.classList.contains('active'));
            
            // Si le menu s'ouvre, synchroniser les boutons
            if (panel.classList.contains('active')) {
                console.log('   üì± Menu ouvert - synchronisation des boutons...');
                // Mettre √† jour l'affichage des boutons mode
                updateMobileModeButtons();
                // D'abord mettre √† jour les boutons conditionnels (Copier/Supprimer)
                updateCopyLinkButton();
                // Puis synchroniser les boutons en ligne (Sauvegarder/Charger)
                syncMobileTeacherButtons();
            }
        }
        
        function closeMobileMenus() {
            const blocksPanel = document.getElementById('mobile-blocks-panel');
            const modePanel = document.getElementById('mobile-mode-panel');
            const overlay = document.getElementById('mobile-overlay');
            
            blocksPanel.classList.remove('active');
            modePanel.classList.remove('active');
            overlay.classList.remove('active');
        }
        
        function closeMobileMenu() {
            const panel = document.getElementById('mobile-blocks-panel');
            const overlay = document.getElementById('mobile-overlay');
            
            panel.classList.remove('active');
            
            // Ne fermer l'overlay que si le mode panel est aussi ferm√©
            const modePanel = document.getElementById('mobile-mode-panel');
            if (!modePanel.classList.contains('active')) {
                overlay.classList.remove('active');
            }
        }
        
        function switchModeAndClose(mode) {
            // Utiliser la fonction switchMode existante
            switchMode(mode);
            
            // G√©rer l'affichage des boutons dans le menu mobile
            updateMobileModeButtons();
            
            // Fermer le menu
            closeMobileMenus();
        }
        
        function updateMobileModeButtons() {
            const mobileTeacherButtons = document.getElementById('mobile-teacher-buttons');
            const mobileStudentModeBtn = document.getElementById('mobile-student-mode-btn');
            const mobileTeacherModeBtn = document.getElementById('mobile-teacher-mode-btn');
            
            // Si on est en mode chargement √©l√®ve (lien prof), cacher les boutons de mode
            if (window.isStudentLoadMode) {
                console.log('üîç updateMobileModeButtons: Mode chargement √©l√®ve d√©tect√©');
                
                // Cacher les boutons de mode avec !important
                if (mobileStudentModeBtn) {
                    mobileStudentModeBtn.style.setProperty('display', 'none', 'important');
                    console.log('‚úì Bouton Mode √âl√®ve cach√©');
                }
                if (mobileTeacherModeBtn) {
                    mobileTeacherModeBtn.style.setProperty('display', 'none', 'important');
                    console.log('‚úì Bouton Mode Professeur cach√©');
                }
                
                // Cacher les boutons professeur
                if (mobileTeacherButtons) {
                    mobileTeacherButtons.style.setProperty('display', 'none', 'important');
                    console.log('‚úì DIV mobile-teacher-buttons cach√©');
                }
                
                // Afficher les boutons √âL√àVE (sauvegarde/chargement avec code)
                const mobileStudentButtons = document.getElementById('mobile-student-buttons');
                if (mobileStudentButtons) {
                    mobileStudentButtons.style.setProperty('display', 'block', 'important');
                    console.log('‚úì DIV mobile-student-buttons affich√©');
                }
                
                console.log('üîç Fin updateMobileModeButtons pour mode chargement √©l√®ve');
                return; // Ne pas continuer
            }
            
            if (currentMode === 'teacher') {
                // Mode professeur
                if (mobileTeacherButtons) mobileTeacherButtons.style.display = 'block';
                if (mobileStudentModeBtn) {
                    mobileStudentModeBtn.classList.remove('active');
                    mobileStudentModeBtn.style.background = '';
                    mobileStudentModeBtn.style.color = '#2196F3';
                }
                if (mobileTeacherModeBtn) {
                    mobileTeacherModeBtn.classList.add('active');
                    mobileTeacherModeBtn.style.background = 'linear-gradient(135deg, #4C97FF 0%, #3373CC 100%)';
                    mobileTeacherModeBtn.style.color = 'white';
                }
                
                // Synchroniser tous les boutons avec les versions PC
                syncMobileTeacherButtons();
            } else {
                // Mode √©l√®ve
                if (mobileTeacherButtons) mobileTeacherButtons.style.display = 'none';
                if (mobileStudentModeBtn) {
                    mobileStudentModeBtn.classList.add('active');
                    mobileStudentModeBtn.style.background = '#2196F3';
                    mobileStudentModeBtn.style.color = 'white';
                }
                if (mobileTeacherModeBtn) {
                    mobileTeacherModeBtn.classList.remove('active');
                    mobileTeacherModeBtn.style.background = '';
                    mobileTeacherModeBtn.style.color = '#2196F3';
                }
            }
        }
        
        function syncMobileTeacherButtons() {
            // En mode chargement √©l√®ve, ne pas synchroniser (les boutons mobiles sont g√©r√©s manuellement)
            if (window.isStudentLoadMode) {
                console.log('üîç syncMobileTeacherButtons: Mode chargement √©l√®ve - skip synchronisation');
                return;
            }
            
            // Synchroniser UNIQUEMENT les boutons Sauvegarder/Charger en ligne
            // Les boutons Copier/Supprimer sont g√©r√©s par updateCopyLinkButton()
            const pcSaveOnlineBtn = document.getElementById('save-online-btn');
            const pcLoadLevelsBtn = document.getElementById('load-levels-btn');
            
            const mobileSaveOnlineBtn = document.getElementById('mobile-save-online-btn');
            const mobileLoadLevelsBtn = document.getElementById('mobile-load-levels-btn');
            
            // Sauvegarder en ligne (convertir inline-block en block pour mobile)
            if (mobileSaveOnlineBtn && pcSaveOnlineBtn) {
                const pcDisplay = pcSaveOnlineBtn.style.display;
                mobileSaveOnlineBtn.style.display = (pcDisplay === 'inline-block' || pcDisplay === 'block') ? 'block' : 'none';
            }
            
            // Charger niveaux en ligne (convertir inline-block en block pour mobile)
            if (mobileLoadLevelsBtn && pcLoadLevelsBtn) {
                const pcDisplay = pcLoadLevelsBtn.style.display;
                mobileLoadLevelsBtn.style.display = (pcDisplay === 'inline-block' || pcDisplay === 'block') ? 'block' : 'none';
            }
        }
        
        function saveLevelBeforeOnlineMobile() {
            // Appeler la fonction PC
            saveLevelBeforeOnline();
            // Fermer le menu apr√®s
            closeMobileMenus();
        }
        
        function openLoadOnlineModalMobile() {
            // Appeler la fonction PC
            openLoadOnlineModal();
            // Le menu se ferme automatiquement (modal ouverte)
        }
        
        // === FONCTIONS WRAPPER POUR BOUTONS √âL√àVE MOBILE ===
        function generateStudentCodeMobile() {
            // Appeler la fonction PC
            generateStudentCode();
            // Le menu reste ouvert (modal de code affich√©e)
        }
        
        function openLoadProgressModalMobile() {
            // Appeler la fonction PC
            openLoadProgressModal();
            // Le menu reste ouvert (modal de chargement affich√©e)
        }
        
        function copyStudentLinkMobile() {
            // Appeler la fonction PC
            copyStudentLink();
            // Fermer le menu apr√®s
            closeMobileMenus();
        }
        
        function openDeleteOnlineModalMobile() {
            // Appeler la fonction PC
            openDeleteOnlineModal();
            // Le menu se ferme automatiquement (modal ouverte)
        }
        
        function generateTeacherCodeMobile() {
            // En mode professeur, la sauvegarde locale = sauvegarder les niveaux cr√©√©s
            generateStudentCode(); // R√©utilise la m√™me fonction
            // Fermer le menu apr√®s
            closeMobileMenus();
        }
        
        function openLoadTeacherProgressModalMobile() {
            // En mode professeur, charger = charger les niveaux cr√©√©s
            openLoadProgressModal(); // R√©utilise la m√™me fonction
            // Le menu se ferme automatiquement car on ouvre une modal
        }
        
        function populateMobileBlocks() {
            const container = document.getElementById('mobile-blocks-list');
            if (!container) {
                console.error('Container mobile-blocks-list non trouv√©');
                return;
            }
            
            // Vider le conteneur
            container.innerHTML = '';
            
            // R√©cup√©rer toutes les cat√©gories de blocs
            const categories = document.querySelectorAll('.blocks-palette .blocks-category');
            
            if (categories.length === 0) {
                console.error('Aucune cat√©gorie trouv√©e');
                return;
            }
            
            console.log('Cat√©gories trouv√©es:', categories.length);
            
            let isFirstCategory = true;
            
            categories.forEach((category) => {
                // Cr√©er le header de cat√©gorie
                const categoryHeader = category.querySelector('.category-header');
                if (categoryHeader) {
                    const headerClone = document.createElement('div');
                    headerClone.className = 'mobile-category-header';
                    headerClone.innerHTML = categoryHeader.innerHTML;
                    
                    // Style diff√©rent pour la premi√®re cat√©gorie
                    if (isFirstCategory) {
                        headerClone.style.cssText = `
                            font-size: 14px;
                            font-weight: bold;
                            padding: 10px;
                            margin: 5px 0 8px 65px;
                            background: #f0f0f0;
                            border-radius: 6px;
                            color: #333;
                        `;
                        isFirstCategory = false;
                    } else {
                        headerClone.style.cssText = `
                            font-size: 14px;
                            font-weight: bold;
                            padding: 10px;
                            margin: 15px 0 8px 0;
                            background: #f0f0f0;
                            border-radius: 6px;
                            color: #333;
                        `;
                    }
                    container.appendChild(headerClone);
                }
                
                // R√©cup√©rer les blocs de cette cat√©gorie
                const categoryBlocks = category.querySelector('.category-blocks');
                
                // SPECIAL : Section Variables
                const isVariableSection = categoryHeader && categoryHeader.textContent.includes('Variables');
                
                if (isVariableSection) {
                    console.log('Section Variables d√©tect√©e');
                    
                    // Ajouter le bouton "+ Cr√©er une variable"
                    const varButton = categoryBlocks.querySelector('button[onclick*="createNewVariable"]');
                    if (varButton) {
                        const mobileVarButton = varButton.cloneNode(true);
                        mobileVarButton.style.cssText = `
                            width: 100%;
                            margin: 0 0 12px 0;
                            min-height: 44px;
                            font-size: 14px;
                            padding: 10px;
                            background: #FF8C1A;
                            color: white;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                            font-weight: bold;
                        `;
                        container.appendChild(mobileVarButton);
                        console.log('Bouton cr√©er variable ajout√©');
                    }
                    
                    // V√©rifier si le div #variable-blocks est visible
                    const variableBlocksDiv = categoryBlocks.querySelector('#variable-blocks');
                    console.log('variableBlocksDiv trouv√©?', !!variableBlocksDiv);
                    
                    if (variableBlocksDiv) {
                        const computedStyle = window.getComputedStyle(variableBlocksDiv);
                        const displayValue = computedStyle.display;
                        console.log('Display de variable-blocks:', displayValue);
                        console.log('createdVariables.length:', createdVariables.length);
                        
                        const isVisible = displayValue !== 'none';
                        console.log('Variables visibles?', isVisible);
                        
                        // Si pas visible OU aucune variable cr√©√©e, NE PAS afficher les blocs
                        if (!isVisible || createdVariables.length === 0) {
                            console.log('‚úì Blocs variables masqu√©s - return');
                            return; // Sortir de CE forEach, passer √† la cat√©gorie suivante
                        }
                        
                        console.log('‚Üí Ajout des blocs variables');
                        
                        // Sinon, r√©cup√©rer les blocs DANS #variable-blocks
                        const varBlocks = variableBlocksDiv.querySelectorAll('.block');
                        console.log('Nombre de blocs variables:', varBlocks.length);
                        
                        varBlocks.forEach((block) => {
                            const mobileBlock = block.cloneNode(true);
                            
                            mobileBlock.style.minHeight = '44px';
                            mobileBlock.style.fontSize = '14px';
                            mobileBlock.style.padding = '10px';
                            mobileBlock.style.marginBottom = '8px';
                            mobileBlock.style.cursor = 'grab';
                            mobileBlock.draggable = true;
                            
                            if (block.dataset) {
                                Object.keys(block.dataset).forEach(key => {
                                    mobileBlock.dataset[key] = block.dataset[key];
                                });
                            }
                            
                            // Mettre √† jour les selects de variables avec la derni√®re variable cr√©√©e
                            if (createdVariables.length > 0) {
                                const varSelects = mobileBlock.querySelectorAll('.var-select');
                                varSelects.forEach(select => {
                                    // Vider et remplir avec toutes les variables
                                    select.innerHTML = '';
                                    createdVariables.forEach(varName => {
                                        const option = document.createElement('option');
                                        option.value = varName;
                                        option.textContent = varName;
                                        select.appendChild(option);
                                    });
                                    // S√©lectionner la derni√®re variable cr√©√©e
                                    const lastVar = createdVariables[createdVariables.length - 1];
                                    select.value = lastVar;
                                });
                            }
                            
                            // Convertir input number en text DANS LE HTML
                            if (window.innerWidth <= 768) {
                                // Remplacer dans le HTML directement
                                mobileBlock.innerHTML = mobileBlock.innerHTML.replace(/type="number"/g, 'type="text" inputmode="numeric" pattern="[0-9]*"');
                                
                                // Augmenter la taille des inputs ET forcer sans spinner
                                const allInputs = mobileBlock.querySelectorAll('input');
                                allInputs.forEach(input => {
                                    input.style.fontSize = '16px';
                                    input.style.padding = '8px';
                                    input.style.minWidth = '60px';
                                    input.style.minHeight = '40px';
                                    input.style.webkitAppearance = 'none';
                                    input.style.mozAppearance = 'textfield';
                                    input.style.appearance = 'none';
                                });
                            }
                            
                            mobileBlock.ondragstart = function(e) {
                                drag(e);
                                setTimeout(() => closeMobileMenu(), 100);
                            };
                            
                            container.appendChild(mobileBlock);
                        });
                    }
                    return; // On a trait√© la section Variables, passer √† la suivante
                }
                
                // Pour les autres sections, r√©cup√©rer les blocs normalement
                const blocks = categoryBlocks.querySelectorAll('.block:not(#variable-blocks .block), .value-block, .operator-block');
                
                blocks.forEach((block) => {
                    // Cr√©er un clone EXACT du bloc
                    const mobileBlock = block.cloneNode(true);
                    
                    // Style r√©duit et espac√©
                    mobileBlock.style.minHeight = '44px';
                    mobileBlock.style.fontSize = '14px';
                    mobileBlock.style.padding = '10px';
                    mobileBlock.style.marginBottom = '8px';
                    mobileBlock.style.cursor = 'grab';
                    mobileBlock.draggable = true;
                    
                    // Copier TOUS les attributs data-
                    if (block.dataset) {
                        Object.keys(block.dataset).forEach(key => {
                            mobileBlock.dataset[key] = block.dataset[key];
                        });
                    }
                    
                    // Sur mobile : remplacer input type="number" par type="text" DANS LE HTML
                    if (window.innerWidth <= 768) {
                        // Remplacer dans le HTML directement
                        mobileBlock.innerHTML = mobileBlock.innerHTML.replace(/type="number"/g, 'type="text" inputmode="numeric" pattern="[0-9]*"');
                        
                        // Augmenter la taille des inputs ET forcer sans spinner
                        const allInputs = mobileBlock.querySelectorAll('input');
                        allInputs.forEach(input => {
                            input.style.fontSize = '16px';
                            input.style.padding = '8px';
                            input.style.minWidth = '60px';
                            input.style.minHeight = '40px';
                            input.style.webkitAppearance = 'none';
                            input.style.mozAppearance = 'textfield';
                            input.style.appearance = 'none';
                        });
                    }
                    
                    // Handler drag desktop
                    mobileBlock.ondragstart = function(e) {
                        drag(e);
                        setTimeout(() => closeMobileMenu(), 100);
                    };
                    
                    container.appendChild(mobileBlock);
                });
            });
            
            // Initialiser le drag tactile
            initMobileTouchDrag();
            
            console.log('Menu mobile peupl√©');
        }
        
        // Initialiser au chargement
        window.addEventListener('DOMContentLoaded', () => {
            console.log('DOM charg√© - initialisation mobile');
            // Attendre que tout soit charg√©
            setTimeout(() => {
                if (window.innerWidth <= 768) {
                    populateMobileBlocks();
                }
            }, 500);
        });
        
        // Re-peupler quand on change de mode
        const originalSwitchMode = window.switchMode;
        window.switchMode = function(mode) {
            if (originalSwitchMode) {
                originalSwitchMode(mode);
            }
            // Re-peupler le menu mobile
            setTimeout(() => {
                if (window.innerWidth <= 768) {
                    populateMobileBlocks();
                }
            }, 300);
        };
    </script>
</body>
</html>
